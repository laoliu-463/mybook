---
created: 2026-02-04
source: https://redis.io/docs/manual/patterns/
status: organized
tags: [Redis, 缓存, 数据库]
---

# NotebookLM导入-Redis缓存穿透问题分析

## 📝 原始内容
# Redis 缓存穿透问题分析

## 问题描述
缓存穿透是指查询一个数据库中不存在的数据，导致请求直接打到数据库上，绕过了缓存层。

## 常见场景
1. 恶意攻击：大量请求不存在的 key
2. 业务设计缺陷：未对空值进行缓存

## 解决方案
### 1. 布隆过滤器
在缓存之前增加布隆过滤器层，快速判断 key 是否存在。

### 2. 缓存空对象
对查询结果为空的 key 也进行缓存，设置较短的过期时间。

## 参考资料
- Redis 官方文档：https://redis.io/docs/manual/patterns/
- 《Redis 设计与实现》第 8 章

## 实战案例（hmdp 项目）
在黑马点评项目中，使用了缓存空对象方案：
- 空对象 TTL：2 分钟
- 正常缓存 TTL：30 分钟

## 🤖 快速摘要（Capture）
- **一句话总结**：Redis 缓存穿透的两种解决方案：布隆过滤器和缓存空对象
- **价值点**：防止恶意攻击直接打到数据库，保护系统稳定性
- **下一步动作（TODO）**：
  - [ ] 在 hmdp 项目中实现布隆过滤器优化
  - [ ] 整理成面试题回答

---

## 💎 核心洞见（Distill）
> [!NOTE] Executive Summary
> 1. 缓存穿透本质是恶意请求绕过缓存直击数据库，核心防御策略是"在请求到达数据库前拦截"
> 2. 布隆过滤器适用于海量数据场景（空间换时间），缓存空对象适用于中小规模且允许短期内存占用的场景
> 3. hmdp 项目的实战经验：缓存空对象方案简单有效，关键是设置合理的 TTL 差异（空对象 2 分钟 vs 正常 30 分钟）

### 关键要点
- **问题本质**：数据库不存在的 key 导致缓存失效，请求穿透到数据库
- **两种方案对比**：布隆过滤器（误判率低、内存占用小）vs 缓存空对象（实现简单、有额外内存消耗）
- **TTL 设置原则**：空对象 TTL 要远小于正常缓存，避免长期占用内存
- **实战取舍**：hmdp 项目选择缓存空对象方案，因为业务规模不大且实现成本低
- **恶意攻击防护**：配合限流、黑名单等机制综合防御

### 🚀 可复用资产
- [x] 操作清单 / SOP
  **缓存穿透防御 SOP**：
  1. 评估业务规模（QPS、数据量、内存预算）
  2. 小规模：缓存空对象（TTL 2-5 分钟）
  3. 大规模/高并发：布隆过滤器 + 缓存空对象组合
  4. 监控指标：数据库穿透率、缓存命中率、空对象占用内存

- [x] 代码片段 / 模板
  **Spring Boot + Redis 缓存空对象实现模板**：
  ```java
  // 查询逻辑
  String value = redisTemplate.opsForValue().get(key);
  if (value != null) {
      return "".equals(value) ? null : value; // 空对象返回 null
  }

  // 查询数据库
  String dbValue = queryFromDB(key);
  if (dbValue == null) {
      // 缓存空对象（短 TTL）
      redisTemplate.opsForValue().set(key, "", 2, TimeUnit.MINUTES);
      return null;
  }

  // 缓存正常数据（长 TTL）
  redisTemplate.opsForValue().set(key, dbValue, 30, TimeUnit.MINUTES);
  return dbValue;
  ```

- [x] 决策模型
  **方案选择决策树**：
  - 数据量 > 1000 万 且 QPS > 10000 → 布隆过滤器
  - 数据量 < 100 万 且 QPS < 5000 → 缓存空对象
  - 其他场景 → 组合方案（布隆过滤器预判 + 缓存空对象兜底）

- [x] 常见坑点与边界
  - **坑点 1**：空对象 TTL 设置过长，导致内存浪费（建议 2-5 分钟）
  - **坑点 2**：布隆过滤器初始化后数据更新，需要重建过滤器（适合相对静态的数据）
  - **坑点 3**：只防缓存穿透不防缓存击穿/雪崩，需要配合互斥锁、过期时间随机化等方案
  - **边界条件**：恶意攻击每次请求不同 key，缓存空对象也无效，必须配合限流

### 🔗 证据与链接
- 原始来源：https://redis.io/docs/manual/patterns/
- 关联项目：hmdp-黑马点评项目
- 关联领域：Redis、数据库优化、高并发系统设计
