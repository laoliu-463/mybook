---
type: interview-qa
status: reviewed
tags:
  - 面试题
  - 缓存
  - Redis
source: "[[01-知识库/计算机/Java与后端/00-面试题库/缓存击穿问题与解决方案]]"
created: 2026-01-27
updated: 2026-01-27
---

# 缓存击穿 - 面试题速查

## Q1: 什么是缓存击穿？
- **A**: 单个热点 Key 过期瞬间，大量并发请求直接打到数据库
- **核心逻辑**: 热点数据失效 → 并发请求同时查库 → DB 压力激增
- **Source**: [[缓存击穿问题与解决方案#结论]]

## Q2: 缓存击穿有哪些解决方案？各有什么优缺点？
- **A**:
  - **互斥锁**：强一致，但等待时间长、可能死锁
  - **逻辑过期**：高可用不阻塞，但短暂数据不一致
  - **永不过期**：简单直接，但需主动刷新
- **核心逻辑**: 控制重建缓存的并发 或 避免真正过期
- **Source**: [[缓存击穿问题与解决方案#核心要点]]

## Q3: 缓存击穿、穿透、雪崩有什么区别？
- **A**:
  | 类型 | 触发条件 | 影响范围 |
  |------|----------|----------|
  | 击穿 | 热点 Key 过期 | 单点压力 |
  | 穿透 | 查询不存在的数据 | 持续攻击 |
  | 雪崩 | 大量 Key 同时过期 | 全面崩溃 |
- **Source**: [[缓存击穿问题与解决方案#击穿 vs 穿透 vs 雪崩]]

## Q4: 互斥锁方案中，为什么锁必须设置过期时间？
- **A**: 防止持有锁的线程崩溃导致死锁
- **核心逻辑**: 线程异常退出 → 锁永远无法释放 → 其他线程永久阻塞
- **Source**: [[缓存击穿问题与解决方案#易错点]]

## Q5: 逻辑过期方案为什么会有数据不一致？
- **A**: 发现过期后异步更新，更新完成前其他请求仍返回旧数据
- **核心逻辑**: 异步更新 = 非阻塞 = 短暂窗口期返回旧值
- **Source**: [[缓存击穿问题与解决方案#核心要点]]

---

## ⚠ 待确认
- 逻辑过期的异步更新线程如何触发？（原文未详细说明）
- Redisson vs SETNX 的选型标准（原文提到但未展开）
