---
title: TCP 协议练习题
type: interview
domain: [计算机网络]
tags: [TCP, 面试, 八股文, 练习题]
source: study-vault-builder
created: 2026-02-08
status: draft
---

## 基础概念题

### Q1: TCP 和 UDP 的区别？

> [!example]- 答案
> | 对比 | TCP | UDP |
> |------|-----|-----|
> | 连接 | 面向连接 | 无连接 |
> | 可靠性 | 可靠传输 | 不可靠 |
> | 顺序 | 保证顺序 | 不保证 |
> | 速度 | 较慢 | 较快 |
> | 首部 | 20-60 字节 | 8 字节 |
> | 适用 | HTTP/FTP/邮件 | DNS/视频/游戏 |

### Q2: TCP 如何保证可靠传输？

> [!example]- 答案
> 1. **序列号和确认号**：保证数据按序、检测丢包
> 2. **校验和**：检测传输错误
> 3. **超时重传**：丢包后重新发送
> 4. **流量控制**：滑动窗口防止接收方溢出
> 5. **拥塞控制**：防止网络过载

---

## 连接管理题

### Q3: 三次握手的过程？

> [!example]- 答案
> ```
> 1. 客户端 → 服务端: SYN, seq=x
> 2. 服务端 → 客户端: SYN+ACK, seq=y, ack=x+1
> 3. 客户端 → 服务端: ACK, seq=x+1, ack=y+1
> ```
> 完成后双方进入 ESTABLISHED 状态。

### Q4: 为什么是三次握手而不是两次？

> [!example]- 答案
> **防止历史连接**：
> - 两次握手时，服务端收到延迟的旧 SYN 会直接建立连接
> - 三次握手时，客户端检查 ACK 号，发现不对会发 RST 拒绝
>
> **同步双方序列号**：
> - 每个方向都需要发送 SYN 和接收 ACK（2×2=4，合并为3）

### Q5: 四次挥手的过程？

> [!example]- 答案
> ```
> 1. 主动方 → 被动方: FIN, seq=u
> 2. 被动方 → 主动方: ACK, ack=u+1
> 3. 被动方 → 主动方: FIN, seq=w
> 4. 主动方 → 被动方: ACK, ack=w+1
> ```
> 主动方进入 TIME_WAIT，等待 2MSL 后关闭。

### Q6: 为什么需要 TIME_WAIT？

> [!example]- 答案
> 1. **确保最后 ACK 到达**：ACK 丢失时可以重发
> 2. **等待旧报文消失**：2MSL 确保本连接所有报文过期，不干扰新连接

### Q7: 服务端大量 CLOSE_WAIT 怎么办？

> [!example]- 答案
> **原因**：收到 FIN 后应用层没有调用 close()
>
> **解决**：
> - 检查代码是否有资源泄漏
> - 确保 finally/defer 中释放连接
> - 使用连接池并设置超时

---

## 流量控制题

### Q8: 滑动窗口的作用？

> [!example]- 答案
> 实现**流量控制**，防止发送方发送过快导致接收方缓冲区溢出。
>
> 接收方通过 rwnd（接收窗口）通告可接收的数据量，发送方据此控制发送速率。

### Q9: 什么是零窗口？如何处理？

> [!example]- 答案
> **零窗口**：接收方缓冲区满，通告 rwnd=0，发送方停止发送。
>
> **处理**：发送方启动持续定时器，定期发送 1 字节探测报文，接收方回复当前窗口大小。

### Q10: Nagle 算法是什么？什么时候关闭？

> [!example]- 答案
> **作用**：减少小包数量，攒够数据再发送。
>
> **关闭场景**（设置 TCP_NODELAY）：
> - 实时交互（SSH、游戏）
> - 低延迟 RPC
> - 与延迟确认冲突时

---

## 拥塞控制题

### Q11: 拥塞控制的四大算法？

> [!example]- 答案
> 1. **慢启动**：cwnd 指数增长（1→2→4→8...）
> 2. **拥塞避免**：cwnd 线性增长（每 RTT +1 MSS）
> 3. **快重传**：3 个重复 ACK 立即重传
> 4. **快恢复**：ssthresh = cwnd/2, cwnd = ssthresh+3

### Q12: 超时和 3 个重复 ACK 的处理有什么区别？

> [!example]- 答案
> | 事件 | 处理 |
> |------|------|
> | **超时** | ssthresh = cwnd/2, cwnd = 1, 回到慢启动 |
> | **3×重复ACK** | ssthresh = cwnd/2, cwnd = ssthresh+3, 进入快恢复 |
>
> 超时更严重（可能严重拥塞），所以惩罚更重。

### Q13: CUBIC 和 BBR 有什么区别？

> [!example]- 答案
> | 对比 | CUBIC | BBR |
> |------|-------|-----|
> | 拥塞感知 | 基于丢包 | 基于带宽/RTT 建模 |
> | 曲线 | 三次函数 | 探测瓶颈带宽 |
> | 优势 | 高 BDP 友好 | 低延迟、抗丢包 |
> | Linux 默认 | 是 | 可选 |

---

## 综合场景题

### Q14: 描述一个完整的 HTTP 请求过程（TCP 层面）

> [!example]- 答案
> ```
> 1. 三次握手建立连接
>    C→S: SYN / S→C: SYN+ACK / C→S: ACK
>
> 2. 发送 HTTP 请求
>    C→S: [TCP Data: GET /index.html HTTP/1.1...]
>    S→C: ACK
>
> 3. 接收 HTTP 响应
>    S→C: [TCP Data: HTTP/1.1 200 OK...]
>    C→S: ACK
>
> 4. 四次挥手释放连接（或 Keep-Alive 保持）
>    C→S: FIN / S→C: ACK / S→C: FIN / C→S: ACK
> ```

### Q15: 网络出现丢包时 TCP 会如何表现？

> [!example]- 答案
> 1. **轻微丢包**：
>    - 快重传（3 个重复 ACK）
>    - 快恢复（cwnd 减半）
>    - 影响较小
>
> 2. **严重丢包/超时**：
>    - 触发超时重传
>    - cwnd 重置为 1
>    - 从慢启动重新开始
>    - 吞吐量显著下降

---

## 知识网络

- [[00-overview|TCP 协议总览]]
- [[02-三次握手]]
- [[03-四次挥手]]
- [[05-拥塞控制]]
