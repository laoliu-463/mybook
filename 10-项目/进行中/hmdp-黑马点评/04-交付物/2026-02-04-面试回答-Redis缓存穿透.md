---
created: 2026-02-04
type: 面试回答
source: 20-领域/2026-02-04-Redis缓存穿透.md
tags: [面试, Redis, 缓存]
---

# 面试回答：Redis 缓存穿透问题及解决方案

## 📌 问题场景
**面试官问**："什么是缓存穿透？在你的项目中是如何解决的？"

---

## 💬 标准回答（2-3 分钟）

### 1️⃣ 问题定义（30 秒）
缓存穿透是指**查询一个数据库中根本不存在的数据**，导致请求绕过缓存层，直接打到数据库上。

这种情况很危险，因为：
- 缓存无法发挥作用（查不到就返回 null）
- 每次请求都会穿透到数据库
- 如果是恶意攻击（大量请求不存在的 key），可能直接把数据库打垮

---

### 2️⃣ 解决方案（1 分钟）
业界有两种主流方案：

**方案一：布隆过滤器**
- 在缓存前加一层布隆过滤器，快速判断 key 是否可能存在
- 优点：内存占用小，查询速度快（O(k) 时间复杂度）
- 缺点：有误判率（可能把存在的判断为不存在），且数据更新后需要重建过滤器
- 适用场景：海量数据 + 高并发（数据量 > 1000 万，QPS > 10000）

**方案二：缓存空对象**
- 对查询结果为空的 key 也进行缓存，但设置**较短的过期时间**
- 优点：实现简单，不会误判
- 缺点：会额外占用缓存内存
- 适用场景：中小规模业务（数据量 < 100 万，QPS < 5000）

---

### 3️⃣ 项目实战（1 分钟）
在我做的**黑马点评项目**中，采用了**缓存空对象方案**，具体实现：

```java
// 查询逻辑
String value = redisTemplate.opsForValue().get(key);
if (value != null) {
    return "".equals(value) ? null : value; // 空对象返回 null
}

// 查询数据库
String dbValue = queryFromDB(key);
if (dbValue == null) {
    // 缓存空对象（短 TTL）
    redisTemplate.opsForValue().set(key, "", 2, TimeUnit.MINUTES);
    return null;
}

// 缓存正常数据（长 TTL）
redisTemplate.opsForValue().set(key, dbValue, 30, TimeUnit.MINUTES);
return dbValue;
```

**关键设计**：
- 空对象 TTL：2 分钟（避免长期占用内存）
- 正常缓存 TTL：30 分钟
- 为什么选这个方案？因为项目规模不大，实现成本低，且能有效防护

---

### 4️⃣ 补充要点（追问应对）
**如果面试官追问"还有其他防护措施吗？"**

缓存穿透只是缓存三大问题之一，实际生产中还需要：
- **限流**：配合 Sentinel/Hystrix，防止恶意攻击
- **黑名单**：识别异常 IP 或用户，提前拦截
- **监控告警**：监控数据库穿透率、缓存命中率

**如果面试官问"布隆过滤器的坑是什么？"**

主要有两个：
1. 数据更新后需要重建过滤器（适合相对静态的数据）
2. 有一定误判率（可能把存在的数据判断为不存在，但不会把不存在的判断为存在）

---

## ✅ 交付检查清单

回答前检查：
- [ ] 是否清晰定义了"缓存穿透"的概念
- [ ] 是否对比了两种方案的优缺点和适用场景
- [ ] 是否结合了项目实战经验（hmdp）
- [ ] 是否给出了具体的代码实现
- [ ] 是否准备了追问应对（限流、监控、布隆过滤器的坑）

回答结构：
- [ ] 控制在 2-3 分钟内
- [ ] 逻辑清晰：问题定义 → 解决方案 → 项目实战 → 补充要点
- [ ] 体现深度思考（为什么选这个方案？TTL 如何设置？）

---

## 🔗 关联资料
- 原始笔记：[[20-领域/2026-02-04-Redis缓存穿透]]
- 项目主页：[[10-项目/进行中/hmdp-黑马点评/00-项目主页]]
- 参考文档：https://redis.io/docs/manual/patterns/
