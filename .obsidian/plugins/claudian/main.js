var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ClaudianPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian29 = require("obsidian");

// src/core/agents/AgentManager.ts
var fs = __toESM(require("fs"));
var os = __toESM(require("os"));
var path = __toESM(require("path"));

// src/core/agents/AgentStorage.ts
var import_obsidian = require("obsidian");
function parseAgentFile(content) {
  const match = content.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n([\s\S]*)$/);
  if (!match) return null;
  try {
    const parsed = (0, import_obsidian.parseYaml)(match[1]);
    if (!parsed || typeof parsed !== "object") {
      return null;
    }
    const frontmatter = parsed;
    const body = match[2].trim();
    if (typeof frontmatter.name !== "string" || !frontmatter.name.trim()) {
      return null;
    }
    if (typeof frontmatter.description !== "string" || !frontmatter.description.trim()) {
      return null;
    }
    if (frontmatter.tools !== void 0 && !isStringOrArray(frontmatter.tools)) {
      return null;
    }
    if (frontmatter.disallowedTools !== void 0 && !isStringOrArray(frontmatter.disallowedTools)) {
      return null;
    }
    return { frontmatter, body };
  } catch (e2) {
    return null;
  }
}
function isStringOrArray(value) {
  return typeof value === "string" || Array.isArray(value);
}
function parseToolsList(tools) {
  if (tools === void 0) return void 0;
  if (Array.isArray(tools)) {
    return tools.map((t2) => String(t2).trim()).filter(Boolean);
  }
  if (typeof tools === "string") {
    const trimmed = tools.trim();
    if (!trimmed) return void 0;
    return trimmed.split(",").map((t2) => t2.trim()).filter(Boolean);
  }
  return void 0;
}
var VALID_MODELS = ["sonnet", "opus", "haiku", "inherit"];
function parseModel(model) {
  if (!model) return "inherit";
  const normalized = model.toLowerCase().trim();
  if (VALID_MODELS.includes(normalized)) {
    return normalized;
  }
  return "inherit";
}

// src/core/agents/AgentManager.ts
var GLOBAL_AGENTS_DIR = path.join(os.homedir(), ".claude", "agents");
var VAULT_AGENTS_DIR = ".claude/agents";
var PLUGIN_AGENTS_DIR = "agents";
var BUILTIN_AGENTS = [
  {
    id: "Explore",
    name: "Explore",
    description: "Fast codebase exploration and search",
    prompt: "",
    // Built-in - prompt managed by SDK
    source: "builtin"
  },
  {
    id: "Plan",
    name: "Plan",
    description: "Implementation planning and architecture",
    prompt: "",
    source: "builtin"
  },
  {
    id: "Bash",
    name: "Bash",
    description: "Command execution specialist",
    prompt: "",
    source: "builtin"
  },
  {
    id: "general-purpose",
    name: "General Purpose",
    description: "Multi-step tasks and complex workflows",
    prompt: "",
    source: "builtin"
  }
];
var AgentManager = class {
  constructor(vaultPath, pluginManager) {
    this.agents = [];
    this.vaultPath = vaultPath;
    this.pluginManager = pluginManager;
  }
  /**
   * Load all agent definitions from all sources.
   * Call this on plugin load and when agents may have changed.
   */
  async loadAgents() {
    this.agents = [];
    this.agents.push(...BUILTIN_AGENTS);
    await this.loadPluginAgents();
    await this.loadVaultAgents();
    await this.loadGlobalAgents();
  }
  /**
   * Get all available agents in load order (reflects source priority).
   */
  getAvailableAgents() {
    return [...this.agents];
  }
  /**
   * Get agent by ID (exact match).
   */
  getAgentById(id) {
    return this.agents.find((a) => a.id === id);
  }
  /**
   * Search agents by ID, name, or description (for @ mention filtering).
   */
  searchAgents(query) {
    const q = query.toLowerCase();
    return this.agents.filter(
      (a) => a.name.toLowerCase().includes(q) || a.id.toLowerCase().includes(q) || a.description.toLowerCase().includes(q)
    );
  }
  /**
   * Load agents from enabled plugins.
   */
  async loadPluginAgents() {
    for (const plugin of this.pluginManager.getPlugins()) {
      if (!plugin.enabled || plugin.status !== "available") continue;
      await this.loadAgentsFromDirectory(
        path.join(plugin.installPath, PLUGIN_AGENTS_DIR),
        "plugin",
        plugin.name
      );
    }
  }
  /**
   * Load agents from vault .claude/agents directory.
   */
  async loadVaultAgents() {
    await this.loadAgentsFromDirectory(path.join(this.vaultPath, VAULT_AGENTS_DIR), "vault");
  }
  /**
   * Load agents from global ~/.claude/agents directory.
   */
  async loadGlobalAgents() {
    await this.loadAgentsFromDirectory(GLOBAL_AGENTS_DIR, "global");
  }
  /**
   * Load agents from a directory into this.agents.
   */
  async loadAgentsFromDirectory(dir, source, pluginName) {
    if (!fs.existsSync(dir)) return;
    for (const filePath of this.listMarkdownFiles(dir)) {
      const agent = await this.parseAgentFromFile(filePath, source, pluginName);
      if (agent) this.agents.push(agent);
    }
  }
  /**
   * List all .md files in a directory (non-recursive).
   */
  listMarkdownFiles(dir) {
    const files = [];
    try {
      const entries = fs.readdirSync(dir, { withFileTypes: true });
      for (const entry of entries) {
        if (entry.isFile() && entry.name.endsWith(".md")) {
          files.push(path.join(dir, entry.name));
        }
      }
    } catch (e2) {
    }
    return files;
  }
  /**
   * Parse an agent definition from a markdown file.
   */
  async parseAgentFromFile(filePath, source, pluginName) {
    try {
      const content = fs.readFileSync(filePath, "utf-8");
      const parsed = parseAgentFile(content);
      if (!parsed) return null;
      const { frontmatter, body } = parsed;
      let id;
      if (source === "plugin" && pluginName) {
        const normalizedPluginName = pluginName.toLowerCase().replace(/\s+/g, "-");
        id = `${normalizedPluginName}:${frontmatter.name}`;
      } else {
        id = frontmatter.name;
      }
      if (this.agents.find((a) => a.id === id)) return null;
      return {
        id,
        name: frontmatter.name,
        description: frontmatter.description,
        prompt: body,
        tools: parseToolsList(frontmatter.tools),
        disallowedTools: parseToolsList(frontmatter.disallowedTools),
        model: parseModel(frontmatter.model),
        source,
        pluginName: source === "plugin" ? pluginName : void 0,
        filePath
      };
    } catch (e2) {
      return null;
    }
  }
};

// src/core/mcp/McpServerManager.ts
var McpServerManager = class {
  constructor(storage) {
    this.servers = [];
    this.storage = storage;
  }
  async loadServers() {
    this.servers = await this.storage.load();
  }
  getServers() {
    return this.servers;
  }
  getEnabledCount() {
    return this.servers.filter((s) => s.enabled).length;
  }
  /**
   * Get servers to include in SDK options.
   *
   * A server is included if:
   * - It is enabled AND
   * - Either context-saving is disabled OR the server is @-mentioned
   *
   * @param mentionedNames Set of server names that were @-mentioned in the prompt
   */
  getActiveServers(mentionedNames) {
    const result = {};
    for (const server of this.servers) {
      if (!server.enabled) continue;
      if (server.contextSaving && !mentionedNames.has(server.name)) {
        continue;
      }
      result[server.name] = server.config;
    }
    return result;
  }
  /**
   * Get disabled MCP tools formatted for SDK disallowedTools option.
   *
   * Only returns disabled tools from servers that would be active (same filter as getActiveServers).
   *
   * @param mentionedNames Set of server names that were @-mentioned in the prompt
   */
  getDisallowedMcpTools(mentionedNames) {
    const disallowed = /* @__PURE__ */ new Set();
    for (const server of this.servers) {
      if (!server.enabled) continue;
      if (server.contextSaving && !mentionedNames.has(server.name)) {
        continue;
      }
      if (!server.disabledTools || server.disabledTools.length === 0) continue;
      for (const tool of server.disabledTools) {
        const normalized = tool.trim();
        if (!normalized) continue;
        disallowed.add(`mcp__${server.name}__${normalized}`);
      }
    }
    return Array.from(disallowed);
  }
  /**
   * Get all disabled MCP tools from ALL enabled servers (ignoring @-mentions).
   *
   * Used for persistent queries to pre-register all disabled tools upfront,
   * so @-mentioning servers doesn't require cold start.
   */
  getAllDisallowedMcpTools() {
    const disallowed = /* @__PURE__ */ new Set();
    for (const server of this.servers) {
      if (!server.enabled) continue;
      if (!server.disabledTools || server.disabledTools.length === 0) continue;
      for (const tool of server.disabledTools) {
        const normalized = tool.trim();
        if (!normalized) continue;
        disallowed.add(`mcp__${server.name}__${normalized}`);
      }
    }
    return Array.from(disallowed).sort();
  }
  hasServers() {
    return this.servers.length > 0;
  }
};

// src/utils/mcp.ts
function extractMcpMentions(text, validNames) {
  const mentions = /* @__PURE__ */ new Set();
  const regex = /@([a-zA-Z0-9._-]+)(?!\/)/g;
  let match;
  while ((match = regex.exec(text)) !== null) {
    const name = match[1];
    if (validNames.has(name)) {
      mentions.add(name);
    }
  }
  return mentions;
}
function transformMcpMentions(text, validNames) {
  if (validNames.size === 0) return text;
  const sortedNames = Array.from(validNames).sort((a, b3) => b3.length - a.length);
  const escapedNames = sortedNames.map(escapeRegExp).join("|");
  const pattern = new RegExp(
    `@(${escapedNames})(?! MCP)(?!/)(?![a-zA-Z0-9_-])(?!\\.[a-zA-Z0-9_-])`,
    "g"
  );
  return text.replace(pattern, "@$1 MCP");
}
function escapeRegExp(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function parseCommand(command, providedArgs) {
  if (providedArgs && providedArgs.length > 0) {
    return { cmd: command, args: providedArgs };
  }
  const parts = splitCommandString(command);
  if (parts.length === 0) {
    return { cmd: "", args: [] };
  }
  return { cmd: parts[0], args: parts.slice(1) };
}
function splitCommandString(cmdStr) {
  const parts = [];
  let current = "";
  let inQuote = false;
  let quoteChar = "";
  for (let i2 = 0; i2 < cmdStr.length; i2++) {
    const char = cmdStr[i2];
    if ((char === '"' || char === "'") && !inQuote) {
      inQuote = true;
      quoteChar = char;
      continue;
    }
    if (char === quoteChar && inQuote) {
      inQuote = false;
      quoteChar = "";
      continue;
    }
    if (/\s/.test(char) && !inQuote) {
      if (current) {
        parts.push(current);
        current = "";
      }
      continue;
    }
    current += char;
  }
  if (current) {
    parts.push(current);
  }
  return parts;
}
function parseSseEvent(raw) {
  const lines = raw.split(/\r?\n/);
  let event;
  const dataLines = [];
  for (const line of lines) {
    if (!line || line.startsWith(":")) continue;
    if (line.startsWith("event:")) {
      event = line.slice("event:".length).trim();
      continue;
    }
    if (line.startsWith("data:")) {
      dataLines.push(line.slice("data:".length).trimStart());
    }
  }
  if (!event && dataLines.length === 0) {
    return null;
  }
  return { event, data: dataLines.join("\n") };
}
async function consumeSseStream(body, onEvent) {
  const reader = body.getReader();
  const decoder = new TextDecoder();
  let buffer = "";
  try {
    let done = false;
    while (!done) {
      const result = await reader.read();
      done = result.done;
      const value = result.value;
      if (done) break;
      buffer += decoder.decode(value, { stream: true });
      const parts = buffer.split(/\r?\n\r?\n/);
      buffer = parts.pop() || "";
      for (const part of parts) {
        const event = parseSseEvent(part);
        if (event) {
          onEvent(event);
        }
      }
    }
  } catch (e2) {
  } finally {
    reader.releaseLock();
  }
}
function parseRpcId(id) {
  if (typeof id === "number" && Number.isFinite(id)) return id;
  if (typeof id === "string" && id.trim()) {
    const asNumber = Number(id);
    if (Number.isFinite(asNumber)) return asNumber;
  }
  return null;
}
function tryParseJson(data) {
  if (!data) return null;
  try {
    return JSON.parse(data);
  } catch (e2) {
    return null;
  }
}
function resolveSseEndpoint(data, baseUrl) {
  const payload = tryParseJson(data);
  if (payload && typeof payload === "object") {
    const record = payload;
    const endpoint = typeof record.endpoint === "string" && record.endpoint || typeof record.messageEndpoint === "string" && record.messageEndpoint || typeof record.url === "string" && record.url || typeof record.messageUrl === "string" && record.messageUrl;
    if (endpoint) {
      try {
        return new URL(endpoint, baseUrl);
      } catch (e2) {
        return null;
      }
    }
  }
  const trimmed = data.trim();
  if (!trimmed) return null;
  try {
    return new URL(trimmed, baseUrl);
  } catch (e2) {
    return null;
  }
}
function waitForRpcResponse(pending, id, timeoutMs) {
  return new Promise((resolve3, reject) => {
    const timer = setTimeout(() => {
      pending.delete(id);
      reject(new Error(`Response timeout (${timeoutMs}ms)`));
    }, timeoutMs);
    pending.set(id, (msg) => {
      clearTimeout(timer);
      pending.delete(id);
      resolve3(msg);
    });
  });
}
async function postJsonRpc(url, headers, payload, options = {}) {
  const requestHeaders = { ...headers };
  if (!requestHeaders["Content-Type"]) {
    requestHeaders["Content-Type"] = "application/json";
  }
  let controller = null;
  let timeoutId = null;
  let signal = options.signal;
  if (options.timeoutMs !== void 0 || options.signal) {
    controller = new AbortController();
    signal = controller.signal;
  }
  const abortHandler = () => controller == null ? void 0 : controller.abort();
  if (controller && options.signal) {
    if (options.signal.aborted) {
      controller.abort();
    } else {
      options.signal.addEventListener("abort", abortHandler, { once: true });
    }
  }
  if (controller && options.timeoutMs !== void 0) {
    timeoutId = setTimeout(() => controller == null ? void 0 : controller.abort(), options.timeoutMs);
  }
  const requestInit = {
    method: "POST",
    headers: requestHeaders,
    body: JSON.stringify(payload)
  };
  if (signal) {
    requestInit.signal = signal;
  }
  try {
    return await fetch(url.toString(), requestInit);
  } finally {
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
    }
    if (controller && options.signal) {
      options.signal.removeEventListener("abort", abortHandler);
    }
  }
}

// src/core/mcp/McpService.ts
var McpService = class {
  constructor(manager) {
    this.manager = manager;
  }
  async loadServers() {
    return this.manager.loadServers();
  }
  getServers() {
    return this.manager.getServers();
  }
  getEnabledCount() {
    return this.manager.getEnabledCount();
  }
  getActiveServers(mentionedNames) {
    return this.manager.getActiveServers(mentionedNames);
  }
  hasServers() {
    return this.manager.hasServers();
  }
  getServerNames() {
    return this.manager.getServers().map((s) => s.name);
  }
  getEnabledServerNames() {
    return this.manager.getServers().filter((s) => s.enabled).map((s) => s.name);
  }
  getContextSavingServers() {
    return this.manager.getServers().filter((s) => s.enabled && s.contextSaving);
  }
  isValidMcpMention(name) {
    return this.manager.getServers().some((s) => s.name === name && s.enabled && s.contextSaving);
  }
  /** Only matches against enabled servers with context-saving mode. */
  extractMentions(text) {
    const validNames = new Set(
      this.manager.getServers().filter((s) => s.enabled && s.contextSaving).map((s) => s.name)
    );
    return extractMcpMentions(text, validNames);
  }
  hasContextSavingServers() {
    return this.manager.getServers().some((s) => s.enabled && s.contextSaving);
  }
  /**
   * Transform MCP mentions in text by appending " MCP" after each valid @mention.
   * This is applied to API requests only, not shown in UI.
   */
  transformMentions(text) {
    const validNames = new Set(
      this.manager.getServers().filter((s) => s.enabled && s.contextSaving).map((s) => s.name)
    );
    return transformMcpMentions(text, validNames);
  }
  getManager() {
    return this.manager;
  }
};

// src/core/mcp/McpTester.ts
var import_child_process = require("child_process");
var http = __toESM(require("http"));
var https = __toESM(require("https"));

// src/utils/env.ts
var fs3 = __toESM(require("fs"));
var os3 = __toESM(require("os"));
var path3 = __toESM(require("path"));

// src/utils/path.ts
var fs2 = __toESM(require("fs"));
var os2 = __toESM(require("os"));
var path2 = __toESM(require("path"));
function getVaultPath(app) {
  const adapter = app.vault.adapter;
  if ("basePath" in adapter) {
    return adapter.basePath;
  }
  return null;
}
function getEnvValue(key) {
  const hasKey = (name) => Object.prototype.hasOwnProperty.call(process.env, name);
  if (hasKey(key)) {
    return process.env[key];
  }
  if (process.platform !== "win32") {
    return void 0;
  }
  const upper = key.toUpperCase();
  if (hasKey(upper)) {
    return process.env[upper];
  }
  const lower = key.toLowerCase();
  if (hasKey(lower)) {
    return process.env[lower];
  }
  const matchKey = Object.keys(process.env).find((name) => name.toLowerCase() === key.toLowerCase());
  return matchKey ? process.env[matchKey] : void 0;
}
function expandEnvironmentVariables(value) {
  if (!value.includes("%") && !value.includes("$") && !value.includes("!")) {
    return value;
  }
  const isWindows2 = process.platform === "win32";
  let expanded = value;
  expanded = expanded.replace(/%([A-Za-z_][A-Za-z0-9_]*(?:\([A-Za-z0-9_]+\))?[A-Za-z0-9_]*)%/g, (match, name) => {
    const envValue = getEnvValue(name);
    return envValue !== void 0 ? envValue : match;
  });
  if (isWindows2) {
    expanded = expanded.replace(/!([A-Za-z_][A-Za-z0-9_]*)!/g, (match, name) => {
      const envValue = getEnvValue(name);
      return envValue !== void 0 ? envValue : match;
    });
    expanded = expanded.replace(/\$env:([A-Za-z_][A-Za-z0-9_]*)/gi, (match, name) => {
      const envValue = getEnvValue(name);
      return envValue !== void 0 ? envValue : match;
    });
  }
  expanded = expanded.replace(/\$([A-Za-z_][A-Za-z0-9_]*)|\$\{([A-Za-z_][A-Za-z0-9_]*)\}/g, (match, name1, name2) => {
    const key = name1 != null ? name1 : name2;
    if (!key) return match;
    const envValue = getEnvValue(key);
    return envValue !== void 0 ? envValue : match;
  });
  return expanded;
}
function expandHomePath(p2) {
  const expanded = expandEnvironmentVariables(p2);
  if (expanded === "~") {
    return os2.homedir();
  }
  if (expanded.startsWith("~/")) {
    return path2.join(os2.homedir(), expanded.slice(2));
  }
  if (expanded.startsWith("~\\")) {
    return path2.join(os2.homedir(), expanded.slice(2));
  }
  return expanded;
}
function stripSurroundingQuotes(value) {
  if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
    return value.slice(1, -1);
  }
  return value;
}
function parsePathEntries(pathValue) {
  if (!pathValue) {
    return [];
  }
  const delimiter = process.platform === "win32" ? ";" : ":";
  return pathValue.split(delimiter).map((segment) => stripSurroundingQuotes(segment.trim())).filter((segment) => {
    if (!segment) return false;
    const upper = segment.toUpperCase();
    return upper !== "$PATH" && upper !== "${PATH}" && upper !== "%PATH%";
  }).map((segment) => translateMsysPath(expandHomePath(segment)));
}
function dedupePaths(entries) {
  const seen = /* @__PURE__ */ new Set();
  return entries.filter((entry) => {
    const key = process.platform === "win32" ? entry.toLowerCase() : entry;
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });
}
function findFirstExistingPath(entries, candidates) {
  for (const dir of entries) {
    if (!dir) continue;
    for (const candidate of candidates) {
      const fullPath = path2.join(dir, candidate);
      if (isExistingFile(fullPath)) {
        return fullPath;
      }
    }
  }
  return null;
}
function isExistingFile(filePath) {
  try {
    if (fs2.existsSync(filePath)) {
      const stat = fs2.statSync(filePath);
      return stat.isFile();
    }
  } catch (e2) {
  }
  return false;
}
function resolveCliJsNearPathEntry(entry, isWindows2) {
  const directCandidate = path2.join(entry, "node_modules", "@anthropic-ai", "claude-code", "cli.js");
  if (isExistingFile(directCandidate)) {
    return directCandidate;
  }
  const baseName = path2.basename(entry).toLowerCase();
  if (baseName === "bin") {
    const prefix = path2.dirname(entry);
    const candidate = isWindows2 ? path2.join(prefix, "node_modules", "@anthropic-ai", "claude-code", "cli.js") : path2.join(prefix, "lib", "node_modules", "@anthropic-ai", "claude-code", "cli.js");
    if (isExistingFile(candidate)) {
      return candidate;
    }
  }
  return null;
}
function resolveCliJsFromPathEntries(entries, isWindows2) {
  for (const entry of entries) {
    const candidate = resolveCliJsNearPathEntry(entry, isWindows2);
    if (candidate) {
      return candidate;
    }
  }
  return null;
}
function resolveClaudeFromPathEntries(entries, isWindows2) {
  if (entries.length === 0) {
    return null;
  }
  if (!isWindows2) {
    const unixCandidate = findFirstExistingPath(entries, ["claude"]);
    return unixCandidate;
  }
  const exeCandidate = findFirstExistingPath(entries, ["claude.exe", "claude"]);
  if (exeCandidate) {
    return exeCandidate;
  }
  const cliJsCandidate = resolveCliJsFromPathEntries(entries, isWindows2);
  if (cliJsCandidate) {
    return cliJsCandidate;
  }
  return null;
}
function getNpmGlobalPrefix() {
  if (process.env.npm_config_prefix) {
    return process.env.npm_config_prefix;
  }
  if (process.platform === "win32") {
    const appDataNpm = process.env.APPDATA ? path2.join(process.env.APPDATA, "npm") : null;
    if (appDataNpm && fs2.existsSync(appDataNpm)) {
      return appDataNpm;
    }
  }
  return null;
}
function getNpmCliJsPaths() {
  const homeDir = os2.homedir();
  const isWindows2 = process.platform === "win32";
  const cliJsPaths = [];
  if (isWindows2) {
    cliJsPaths.push(
      path2.join(homeDir, "AppData", "Roaming", "npm", "node_modules", "@anthropic-ai", "claude-code", "cli.js")
    );
    const npmPrefix = getNpmGlobalPrefix();
    if (npmPrefix) {
      cliJsPaths.push(
        path2.join(npmPrefix, "node_modules", "@anthropic-ai", "claude-code", "cli.js")
      );
    }
    const programFiles = process.env.ProgramFiles || "C:\\Program Files";
    const programFilesX86 = process.env["ProgramFiles(x86)"] || "C:\\Program Files (x86)";
    cliJsPaths.push(
      path2.join(programFiles, "nodejs", "node_global", "node_modules", "@anthropic-ai", "claude-code", "cli.js"),
      path2.join(programFilesX86, "nodejs", "node_global", "node_modules", "@anthropic-ai", "claude-code", "cli.js")
    );
    cliJsPaths.push(
      path2.join("D:", "Program Files", "nodejs", "node_global", "node_modules", "@anthropic-ai", "claude-code", "cli.js")
    );
  } else {
    cliJsPaths.push(
      path2.join(homeDir, ".npm-global", "lib", "node_modules", "@anthropic-ai", "claude-code", "cli.js"),
      "/usr/local/lib/node_modules/@anthropic-ai/claude-code/cli.js",
      "/usr/lib/node_modules/@anthropic-ai/claude-code/cli.js"
    );
    if (process.env.npm_config_prefix) {
      cliJsPaths.push(
        path2.join(process.env.npm_config_prefix, "lib", "node_modules", "@anthropic-ai", "claude-code", "cli.js")
      );
    }
  }
  return cliJsPaths;
}
function findClaudeCLIPath(pathValue) {
  const homeDir = os2.homedir();
  const isWindows2 = process.platform === "win32";
  const customEntries = dedupePaths(parsePathEntries(pathValue));
  if (customEntries.length > 0) {
    const customResolution = resolveClaudeFromPathEntries(customEntries, isWindows2);
    if (customResolution) {
      return customResolution;
    }
  }
  if (isWindows2) {
    const exePaths = [
      path2.join(homeDir, ".claude", "local", "claude.exe"),
      path2.join(homeDir, "AppData", "Local", "Claude", "claude.exe"),
      path2.join(process.env.ProgramFiles || "C:\\Program Files", "Claude", "claude.exe"),
      path2.join(process.env["ProgramFiles(x86)"] || "C:\\Program Files (x86)", "Claude", "claude.exe"),
      path2.join(homeDir, ".local", "bin", "claude.exe")
    ];
    for (const p2 of exePaths) {
      if (isExistingFile(p2)) {
        return p2;
      }
    }
    const cliJsPaths = getNpmCliJsPaths();
    for (const p2 of cliJsPaths) {
      if (isExistingFile(p2)) {
        return p2;
      }
    }
  }
  const commonPaths = [
    path2.join(homeDir, ".claude", "local", "claude"),
    path2.join(homeDir, ".local", "bin", "claude"),
    path2.join(homeDir, ".volta", "bin", "claude"),
    path2.join(homeDir, ".asdf", "shims", "claude"),
    path2.join(homeDir, ".asdf", "bin", "claude"),
    "/usr/local/bin/claude",
    "/opt/homebrew/bin/claude",
    path2.join(homeDir, "bin", "claude"),
    path2.join(homeDir, ".npm-global", "bin", "claude")
  ];
  const npmPrefix = getNpmGlobalPrefix();
  if (npmPrefix) {
    commonPaths.push(path2.join(npmPrefix, "bin", "claude"));
  }
  for (const p2 of commonPaths) {
    if (isExistingFile(p2)) {
      return p2;
    }
  }
  if (!isWindows2) {
    const cliJsPaths = getNpmCliJsPaths();
    for (const p2 of cliJsPaths) {
      if (isExistingFile(p2)) {
        return p2;
      }
    }
  }
  const envEntries = dedupePaths(parsePathEntries(getEnvValue("PATH")));
  if (envEntries.length > 0) {
    const envResolution = resolveClaudeFromPathEntries(envEntries, isWindows2);
    if (envResolution) {
      return envResolution;
    }
  }
  return null;
}
function resolveRealPath(p2) {
  var _a;
  const realpathFn = (_a = fs2.realpathSync.native) != null ? _a : fs2.realpathSync;
  try {
    return realpathFn(p2);
  } catch (e2) {
    const absolute = path2.resolve(p2);
    let current = absolute;
    const suffix = [];
    while (true) {
      try {
        if (fs2.existsSync(current)) {
          const resolvedExisting = realpathFn(current);
          return suffix.length > 0 ? path2.join(resolvedExisting, ...suffix.reverse()) : resolvedExisting;
        }
      } catch (e3) {
      }
      const parent = path2.dirname(current);
      if (parent === current) {
        return absolute;
      }
      suffix.push(path2.basename(current));
      current = parent;
    }
  }
}
function translateMsysPath(value) {
  var _a;
  if (process.platform !== "win32") {
    return value;
  }
  const msysMatch = value.match(/^\/([a-zA-Z])(\/.*)?$/);
  if (msysMatch) {
    const driveLetter = msysMatch[1].toUpperCase();
    const restOfPath = (_a = msysMatch[2]) != null ? _a : "";
    return `${driveLetter}:${restOfPath.replace(/\//g, "\\")}`;
  }
  return value;
}
function normalizePathBeforeResolution(p2) {
  const expanded = expandHomePath(p2);
  return translateMsysPath(expanded);
}
function normalizeWindowsPathPrefix(value) {
  if (process.platform !== "win32") {
    return value;
  }
  const normalized = translateMsysPath(value);
  if (normalized.startsWith("\\\\?\\UNC\\")) {
    return `\\\\${normalized.slice("\\\\?\\UNC\\".length)}`;
  }
  if (normalized.startsWith("\\\\?\\")) {
    return normalized.slice("\\\\?\\".length);
  }
  return normalized;
}
function normalizePathForFilesystem(value) {
  if (!value || typeof value !== "string") {
    return "";
  }
  const expanded = normalizePathBeforeResolution(value);
  let normalized = expanded;
  try {
    normalized = process.platform === "win32" ? path2.win32.normalize(expanded) : path2.normalize(expanded);
  } catch (e2) {
    normalized = expanded;
  }
  return normalizeWindowsPathPrefix(normalized);
}
function normalizePathForComparison(value) {
  if (!value || typeof value !== "string") {
    return "";
  }
  const expanded = normalizePathBeforeResolution(value);
  let normalized = expanded;
  try {
    normalized = process.platform === "win32" ? path2.win32.normalize(expanded) : path2.normalize(expanded);
  } catch (e2) {
    normalized = expanded;
  }
  normalized = normalizeWindowsPathPrefix(normalized);
  normalized = normalized.replace(/\\/g, "/").replace(/\/+$/, "");
  return process.platform === "win32" ? normalized.toLowerCase() : normalized;
}
function isPathWithinVault(candidatePath, vaultPath) {
  const vaultReal = normalizePathForComparison(resolveRealPath(vaultPath));
  const normalizedPath = normalizePathBeforeResolution(candidatePath);
  const absCandidate = path2.isAbsolute(normalizedPath) ? normalizedPath : path2.resolve(vaultPath, normalizedPath);
  const resolvedCandidate = normalizePathForComparison(resolveRealPath(absCandidate));
  return resolvedCandidate === vaultReal || resolvedCandidate.startsWith(vaultReal + "/");
}
function normalizePathForVault(rawPath, vaultPath) {
  if (!rawPath) return null;
  const normalizedRaw = normalizePathForFilesystem(rawPath);
  if (!normalizedRaw) return null;
  if (vaultPath && isPathWithinVault(normalizedRaw, vaultPath)) {
    const absolute = path2.isAbsolute(normalizedRaw) ? normalizedRaw : path2.resolve(vaultPath, normalizedRaw);
    const relative4 = path2.relative(vaultPath, absolute);
    return relative4 ? relative4.replace(/\\/g, "/") : null;
  }
  return normalizedRaw.replace(/\\/g, "/");
}
function getPathAccessType(candidatePath, allowedContextPaths, allowedExportPaths, vaultPath) {
  if (!candidatePath) return "none";
  const vaultReal = normalizePathForComparison(resolveRealPath(vaultPath));
  const normalizedCandidate = normalizePathBeforeResolution(candidatePath);
  const absCandidate = path2.isAbsolute(normalizedCandidate) ? normalizedCandidate : path2.resolve(vaultPath, normalizedCandidate);
  const resolvedCandidate = normalizePathForComparison(resolveRealPath(absCandidate));
  if (resolvedCandidate === vaultReal || resolvedCandidate.startsWith(vaultReal + "/")) {
    return "vault";
  }
  const claudeDir = normalizePathForComparison(resolveRealPath(path2.join(os2.homedir(), ".claude")));
  if (resolvedCandidate === claudeDir || resolvedCandidate.startsWith(claudeDir + "/")) {
    return "vault";
  }
  const roots = /* @__PURE__ */ new Map();
  const addRoot = (rawPath, kind) => {
    var _a;
    const trimmed = rawPath.trim();
    if (!trimmed) return;
    const normalized = normalizePathBeforeResolution(trimmed);
    const resolved = normalizePathForComparison(resolveRealPath(normalized));
    const existing = (_a = roots.get(resolved)) != null ? _a : { context: false, export: false };
    existing[kind] = true;
    roots.set(resolved, existing);
  };
  for (const contextPath of allowedContextPaths != null ? allowedContextPaths : []) {
    addRoot(contextPath, "context");
  }
  for (const exportPath of allowedExportPaths != null ? allowedExportPaths : []) {
    addRoot(exportPath, "export");
  }
  let bestRoot = null;
  let bestFlags = null;
  for (const [root, flags] of roots) {
    if (resolvedCandidate === root || resolvedCandidate.startsWith(root + "/")) {
      if (!bestRoot || root.length > bestRoot.length) {
        bestRoot = root;
        bestFlags = flags;
      }
    }
  }
  if (!bestRoot || !bestFlags) return "none";
  if (bestFlags.context && bestFlags.export) return "readwrite";
  if (bestFlags.context) return "context";
  if (bestFlags.export) return "export";
  return "none";
}

// src/utils/env.ts
var isWindows = process.platform === "win32";
var PATH_SEPARATOR = isWindows ? ";" : ":";
var NODE_EXECUTABLE = isWindows ? "node.exe" : "node";
function getHomeDir() {
  return process.env.HOME || process.env.USERPROFILE || "";
}
function getExtraBinaryPaths() {
  const home = getHomeDir();
  if (isWindows) {
    const paths = [];
    const localAppData = process.env.LOCALAPPDATA;
    const appData = process.env.APPDATA;
    const programFiles = process.env.ProgramFiles || "C:\\Program Files";
    const programFilesX86 = process.env["ProgramFiles(x86)"] || "C:\\Program Files (x86)";
    const programData = process.env.ProgramData || "C:\\ProgramData";
    if (appData) {
      paths.push(path3.join(appData, "npm"));
    }
    if (localAppData) {
      paths.push(path3.join(localAppData, "Programs", "nodejs"));
      paths.push(path3.join(localAppData, "Programs", "node"));
    }
    paths.push(path3.join(programFiles, "nodejs"));
    paths.push(path3.join(programFilesX86, "nodejs"));
    const nvmSymlink = process.env.NVM_SYMLINK;
    if (nvmSymlink) {
      paths.push(nvmSymlink);
    }
    const nvmHome = process.env.NVM_HOME;
    if (nvmHome) {
      paths.push(nvmHome);
    } else if (appData) {
      paths.push(path3.join(appData, "nvm"));
    }
    const voltaHome = process.env.VOLTA_HOME;
    if (voltaHome) {
      paths.push(path3.join(voltaHome, "bin"));
    } else if (home) {
      paths.push(path3.join(home, ".volta", "bin"));
    }
    const fnmMultishell = process.env.FNM_MULTISHELL_PATH;
    if (fnmMultishell) {
      paths.push(fnmMultishell);
    }
    const fnmDir = process.env.FNM_DIR;
    if (fnmDir) {
      paths.push(fnmDir);
    } else if (localAppData) {
      paths.push(path3.join(localAppData, "fnm"));
    }
    const chocolateyInstall = process.env.ChocolateyInstall;
    if (chocolateyInstall) {
      paths.push(path3.join(chocolateyInstall, "bin"));
    } else {
      paths.push(path3.join(programData, "chocolatey", "bin"));
    }
    const scoopDir = process.env.SCOOP;
    if (scoopDir) {
      paths.push(path3.join(scoopDir, "shims"));
      paths.push(path3.join(scoopDir, "apps", "nodejs", "current", "bin"));
      paths.push(path3.join(scoopDir, "apps", "nodejs", "current"));
    } else if (home) {
      paths.push(path3.join(home, "scoop", "shims"));
      paths.push(path3.join(home, "scoop", "apps", "nodejs", "current", "bin"));
      paths.push(path3.join(home, "scoop", "apps", "nodejs", "current"));
    }
    paths.push(path3.join(programFiles, "Docker", "Docker", "resources", "bin"));
    if (home) {
      paths.push(path3.join(home, ".local", "bin"));
    }
    return paths;
  } else {
    const paths = [
      "/usr/local/bin",
      "/opt/homebrew/bin",
      // macOS ARM Homebrew
      "/usr/bin",
      "/bin"
    ];
    const voltaHome = process.env.VOLTA_HOME;
    if (voltaHome) {
      paths.push(path3.join(voltaHome, "bin"));
    }
    const asdfRoot = process.env.ASDF_DATA_DIR || process.env.ASDF_DIR;
    if (asdfRoot) {
      paths.push(path3.join(asdfRoot, "shims"));
      paths.push(path3.join(asdfRoot, "bin"));
    }
    const fnmMultishell = process.env.FNM_MULTISHELL_PATH;
    if (fnmMultishell) {
      paths.push(fnmMultishell);
    }
    const fnmDir = process.env.FNM_DIR;
    if (fnmDir) {
      paths.push(fnmDir);
    }
    if (home) {
      paths.push(path3.join(home, ".local", "bin"));
      paths.push(path3.join(home, ".docker", "bin"));
      paths.push(path3.join(home, ".volta", "bin"));
      paths.push(path3.join(home, ".asdf", "shims"));
      paths.push(path3.join(home, ".asdf", "bin"));
      paths.push(path3.join(home, ".fnm"));
      const nvmBin = process.env.NVM_BIN;
      if (nvmBin) {
        paths.push(nvmBin);
      }
    }
    return paths;
  }
}
function findNodeDirectory(additionalPaths) {
  const searchPaths = getExtraBinaryPaths();
  const currentPath = process.env.PATH || "";
  const pathDirs = parsePathEntries(currentPath);
  const additionalDirs = additionalPaths ? parsePathEntries(additionalPaths) : [];
  const allPaths = [...additionalDirs, ...searchPaths, ...pathDirs];
  for (const dir of allPaths) {
    if (!dir) continue;
    try {
      const nodePath = path3.join(dir, NODE_EXECUTABLE);
      if (fs3.existsSync(nodePath)) {
        const stat = fs3.statSync(nodePath);
        if (stat.isFile()) {
          return dir;
        }
      }
    } catch (e2) {
    }
  }
  return null;
}
function findNodeExecutable(additionalPaths) {
  const nodeDir = findNodeDirectory(additionalPaths);
  if (nodeDir) {
    return path3.join(nodeDir, NODE_EXECUTABLE);
  }
  return null;
}
function cliPathRequiresNode(cliPath) {
  const jsExtensions = [".js", ".mjs", ".cjs", ".ts", ".tsx", ".jsx"];
  const lower = cliPath.toLowerCase();
  if (jsExtensions.some((ext) => lower.endsWith(ext))) {
    return true;
  }
  try {
    if (!fs3.existsSync(cliPath)) {
      return false;
    }
    const stat = fs3.statSync(cliPath);
    if (!stat.isFile()) {
      return false;
    }
    let fd = null;
    try {
      fd = fs3.openSync(cliPath, "r");
      const buffer = Buffer.alloc(200);
      const bytesRead = fs3.readSync(fd, buffer, 0, buffer.length, 0);
      const header = buffer.slice(0, bytesRead).toString("utf8");
      return header.startsWith("#!") && header.toLowerCase().includes("node");
    } finally {
      if (fd !== null) {
        try {
          fs3.closeSync(fd);
        } catch (e2) {
        }
      }
    }
  } catch (e2) {
    return false;
  }
}
function getMissingNodeError(cliPath, enhancedPath) {
  if (!cliPathRequiresNode(cliPath)) {
    return null;
  }
  const nodePath = findNodeExecutable(enhancedPath);
  if (nodePath) {
    return null;
  }
  return "Claude Code CLI requires Node.js, but Node was not found on PATH. Install Node.js or use the native Claude Code binary, then restart Obsidian.";
}
function getEnhancedPath(additionalPaths, cliPath) {
  const extraPaths = getExtraBinaryPaths().filter((p2) => p2);
  const currentPath = process.env.PATH || "";
  const segments = [];
  if (additionalPaths) {
    segments.push(...parsePathEntries(additionalPaths));
  }
  let cliDirHasNode = false;
  if (cliPath) {
    try {
      const cliDir = path3.dirname(cliPath);
      const nodeInCliDir = path3.join(cliDir, NODE_EXECUTABLE);
      if (fs3.existsSync(nodeInCliDir)) {
        const stat = fs3.statSync(nodeInCliDir);
        if (stat.isFile()) {
          segments.push(cliDir);
          cliDirHasNode = true;
        }
      }
    } catch (e2) {
    }
  }
  if (cliPath && cliPathRequiresNode(cliPath) && !cliDirHasNode) {
    const nodeDir = findNodeDirectory();
    if (nodeDir) {
      segments.push(nodeDir);
    }
  }
  segments.push(...extraPaths);
  if (currentPath) {
    segments.push(...parsePathEntries(currentPath));
  }
  const seen = /* @__PURE__ */ new Set();
  const unique = segments.filter((p2) => {
    const normalized = isWindows ? p2.toLowerCase() : p2;
    if (seen.has(normalized)) return false;
    seen.add(normalized);
    return true;
  });
  return unique.join(PATH_SEPARATOR);
}
var CUSTOM_MODEL_ENV_KEYS = [
  "ANTHROPIC_MODEL",
  "ANTHROPIC_DEFAULT_OPUS_MODEL",
  "ANTHROPIC_DEFAULT_SONNET_MODEL",
  "ANTHROPIC_DEFAULT_HAIKU_MODEL"
];
function getModelTypeFromEnvKey(envKey) {
  if (envKey === "ANTHROPIC_MODEL") return "model";
  const match = envKey.match(/ANTHROPIC_DEFAULT_(\w+)_MODEL/);
  return match ? match[1].toLowerCase() : envKey;
}
function parseEnvironmentVariables(input) {
  const result = {};
  for (const line of input.split(/\r?\n/)) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith("#")) continue;
    const normalized = trimmed.startsWith("export ") ? trimmed.slice(7) : trimmed;
    const eqIndex = normalized.indexOf("=");
    if (eqIndex > 0) {
      const key = normalized.substring(0, eqIndex).trim();
      let value = normalized.substring(eqIndex + 1).trim();
      if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
        value = value.slice(1, -1);
      }
      if (key) {
        result[key] = value;
      }
    }
  }
  return result;
}
function getModelsFromEnvironment(envVars) {
  const modelMap = /* @__PURE__ */ new Map();
  for (const envKey of CUSTOM_MODEL_ENV_KEYS) {
    const type = getModelTypeFromEnvKey(envKey);
    const modelValue = envVars[envKey];
    if (modelValue) {
      const label = modelValue.includes("/") ? modelValue.split("/").pop() || modelValue : modelValue.replace(/-/g, " ").replace(/\b\w/g, (l3) => l3.toUpperCase());
      if (!modelMap.has(modelValue)) {
        modelMap.set(modelValue, { types: [type], label });
      } else {
        modelMap.get(modelValue).types.push(type);
      }
    }
  }
  const models = [];
  const typePriority = { "model": 4, "haiku": 3, "sonnet": 2, "opus": 1 };
  const sortedEntries = Array.from(modelMap.entries()).sort(([, aInfo], [, bInfo]) => {
    const aPriority = Math.max(...aInfo.types.map((t2) => typePriority[t2] || 0));
    const bPriority = Math.max(...bInfo.types.map((t2) => typePriority[t2] || 0));
    return bPriority - aPriority;
  });
  for (const [modelValue, info] of sortedEntries) {
    const sortedTypes = info.types.sort(
      (a, b3) => (typePriority[b3] || 0) - (typePriority[a] || 0)
    );
    models.push({
      value: modelValue,
      label: info.label,
      description: `Custom model (${sortedTypes.join(", ")})`
    });
  }
  return models;
}
function getCurrentModelFromEnvironment(envVars) {
  if (envVars.ANTHROPIC_MODEL) {
    return envVars.ANTHROPIC_MODEL;
  }
  if (envVars.ANTHROPIC_DEFAULT_HAIKU_MODEL) {
    return envVars.ANTHROPIC_DEFAULT_HAIKU_MODEL;
  }
  if (envVars.ANTHROPIC_DEFAULT_SONNET_MODEL) {
    return envVars.ANTHROPIC_DEFAULT_SONNET_MODEL;
  }
  if (envVars.ANTHROPIC_DEFAULT_OPUS_MODEL) {
    return envVars.ANTHROPIC_DEFAULT_OPUS_MODEL;
  }
  return null;
}
function getHostnameKey() {
  return os3.hostname();
}
var MIN_CONTEXT_LIMIT = 1e3;
var MAX_CONTEXT_LIMIT = 1e7;
function getCustomModelIds(envVars) {
  const modelIds = /* @__PURE__ */ new Set();
  for (const envKey of CUSTOM_MODEL_ENV_KEYS) {
    const modelId = envVars[envKey];
    if (modelId) {
      modelIds.add(modelId);
    }
  }
  return modelIds;
}
function parseContextLimit(input) {
  var _a;
  const trimmed = input.trim().toLowerCase().replace(/,/g, "");
  if (!trimmed) return null;
  const match = trimmed.match(/^(\d+(?:\.\d+)?)\s*(k|m)?$/);
  if (!match) return null;
  const value = parseFloat(match[1]);
  const suffix = match[2];
  if (isNaN(value) || value <= 0) return null;
  const MULTIPLIERS = { k: 1e3, m: 1e6 };
  const multiplier = suffix ? (_a = MULTIPLIERS[suffix]) != null ? _a : 1 : 1;
  const result = Math.round(value * multiplier);
  if (result < MIN_CONTEXT_LIMIT || result > MAX_CONTEXT_LIMIT) return null;
  return result;
}
function formatContextLimit(tokens) {
  if (tokens >= 1e6 && tokens % 1e6 === 0) {
    return `${tokens / 1e6}m`;
  }
  if (tokens >= 1e3 && tokens % 1e3 === 0) {
    return `${tokens / 1e3}k`;
  }
  return tokens.toLocaleString();
}

// src/core/types/chat.ts
var VIEW_TYPE_CLAUDIAN = "claudian-view";

// src/core/types/models.ts
var DEFAULT_CLAUDE_MODELS = [
  { value: "haiku", label: "Haiku", description: "Fast and efficient" },
  { value: "sonnet", label: "Sonnet", description: "Balanced performance" },
  { value: "opus", label: "Opus", description: "Most capable" }
];
var BETA_1M_CONTEXT = "context-1m-2025-08-07";
function resolveModelWithBetas(model, include1MBeta = false) {
  if (!model || typeof model !== "string") {
    throw new Error("resolveModelWithBetas: model is required and must be a non-empty string");
  }
  if (include1MBeta) {
    return {
      model,
      betas: [BETA_1M_CONTEXT]
    };
  }
  return { model };
}
var THINKING_BUDGETS = [
  { value: "off", label: "Off", tokens: 0 },
  { value: "low", label: "Low", tokens: 4e3 },
  { value: "medium", label: "Med", tokens: 8e3 },
  { value: "high", label: "High", tokens: 16e3 },
  { value: "xhigh", label: "Ultra", tokens: 32e3 }
];
var DEFAULT_THINKING_BUDGET = {
  "haiku": "off",
  "sonnet": "low",
  "opus": "medium"
};
var CONTEXT_WINDOW_STANDARD = 2e5;
var CONTEXT_WINDOW_1M = 1e6;
function getContextWindowSize(model, is1MEnabled = false, customLimits) {
  if (customLimits && model in customLimits) {
    const limit = customLimits[model];
    if (typeof limit === "number" && limit > 0 && !isNaN(limit) && isFinite(limit)) {
      return limit;
    }
  }
  if (is1MEnabled && model.includes("sonnet")) {
    return CONTEXT_WINDOW_1M;
  }
  return CONTEXT_WINDOW_STANDARD;
}

// src/core/types/settings.ts
var UNIX_BLOCKED_COMMANDS = [
  "rm -rf",
  "chmod 777",
  "chmod -R 777"
];
var WINDOWS_BLOCKED_COMMANDS = [
  // CMD commands
  "del /s /q",
  "rd /s /q",
  "rmdir /s /q",
  "format",
  "diskpart",
  // PowerShell Remove-Item variants (full and abbreviated flags)
  "Remove-Item -Recurse -Force",
  "Remove-Item -Force -Recurse",
  "Remove-Item -r -fo",
  "Remove-Item -fo -r",
  "Remove-Item -Recurse",
  "Remove-Item -r",
  // PowerShell aliases for Remove-Item
  "ri -Recurse",
  "ri -r",
  "ri -Force",
  "ri -fo",
  "rm -r -fo",
  "rm -Recurse",
  "rm -Force",
  "del -Recurse",
  "del -Force",
  "erase -Recurse",
  "erase -Force",
  // PowerShell directory removal aliases
  "rd -Recurse",
  "rmdir -Recurse",
  // Dangerous disk/volume commands
  "Format-Volume",
  "Clear-Disk",
  "Initialize-Disk",
  "Remove-Partition"
];
function getDefaultBlockedCommands() {
  return {
    unix: [...UNIX_BLOCKED_COMMANDS],
    windows: [...WINDOWS_BLOCKED_COMMANDS]
  };
}
function getCurrentPlatformKey() {
  return process.platform === "win32" ? "windows" : "unix";
}
function getCurrentPlatformBlockedCommands(commands) {
  return commands[getCurrentPlatformKey()];
}
function getBashToolBlockedCommands(commands) {
  if (process.platform === "win32") {
    return Array.from(/* @__PURE__ */ new Set([...commands.unix, ...commands.windows]));
  }
  return getCurrentPlatformBlockedCommands(commands);
}
function getCliPlatformKey() {
  switch (process.platform) {
    case "darwin":
      return "macos";
    case "win32":
      return "windows";
    default:
      return "linux";
  }
}
function createPermissionRule(rule) {
  return rule;
}
var DEFAULT_SETTINGS = {
  // User preferences
  userName: "",
  // Security
  enableBlocklist: true,
  blockedCommands: getDefaultBlockedCommands(),
  permissionMode: "yolo",
  // Model & thinking
  model: "haiku",
  thinkingBudget: "off",
  enableAutoTitleGeneration: true,
  titleGenerationModel: "",
  // Empty = auto (ANTHROPIC_DEFAULT_HAIKU_MODEL or claude-haiku-4-5)
  show1MModel: false,
  // Hidden by default
  enableChrome: false,
  // Disabled by default
  // Content settings
  excludedTags: [],
  mediaFolder: "",
  systemPrompt: "",
  allowedExportPaths: ["~/Desktop", "~/Downloads"],
  persistentExternalContextPaths: [],
  // Environment
  environmentVariables: "",
  envSnippets: [],
  customContextLimits: {},
  // UI settings
  keyboardNavigation: {
    scrollUpKey: "w",
    scrollDownKey: "s",
    focusInputKey: "i"
  },
  // Internationalization
  locale: "en",
  // Default to English
  // CLI paths
  claudeCliPath: "",
  // Legacy field (empty = not migrated)
  claudeCliPathsByHost: {},
  // Per-device paths keyed by hostname
  loadUserClaudeSettings: true,
  // Default on for compatibility
  lastClaudeModel: "haiku",
  lastCustomModel: "",
  lastEnvHash: "",
  // Slash commands (loaded separately)
  slashCommands: [],
  // UI preferences
  maxTabs: 3,
  // Default to 3 tabs (safe resource usage)
  tabBarPosition: "input",
  // Default to input mode (current behavior)
  enableAutoScroll: true,
  // Default to auto-scroll enabled
  // Slash commands
  hiddenSlashCommands: []
  // No commands hidden by default
};
var DEFAULT_CC_SETTINGS = {
  $schema: "https://json.schemastore.org/claude-code-settings.json",
  permissions: {
    allow: [],
    deny: [],
    ask: []
  }
};
var DEFAULT_CC_PERMISSIONS = {
  allow: [],
  deny: [],
  ask: []
};
function legacyPermissionToCCRule(legacy) {
  const pattern = legacy.pattern.trim();
  if (!pattern || pattern === "*" || pattern.startsWith("{")) {
    return createPermissionRule(legacy.toolName);
  }
  return createPermissionRule(`${legacy.toolName}(${pattern})`);
}
function legacyPermissionsToCCPermissions(legacyPermissions) {
  const allow = [];
  for (const perm of legacyPermissions) {
    if (perm.scope === "always") {
      allow.push(legacyPermissionToCCRule(perm));
    }
  }
  return {
    allow: [...new Set(allow)],
    // Deduplicate
    deny: [],
    ask: []
  };
}
function parseCCPermissionRule(rule) {
  const match = rule.match(/^(\w+)(?:\((.+)\))?$/);
  if (!match) {
    return { tool: rule };
  }
  const [, tool, pattern] = match;
  return { tool, pattern };
}

// src/core/types/mcp.ts
function getMcpServerType(config) {
  if (config.type === "sse") return "sse";
  if (config.type === "http") return "http";
  if ("url" in config) return "http";
  return "stdio";
}
function isValidMcpServerConfig(obj) {
  if (!obj || typeof obj !== "object") return false;
  const config = obj;
  if (config.command && typeof config.command === "string") return true;
  if (config.url && typeof config.url === "string") return true;
  return false;
}
var DEFAULT_MCP_SERVER = {
  enabled: true,
  contextSaving: true
};

// src/core/mcp/McpTester.ts
function getMcpError(response) {
  const error = response.error;
  return error == null ? void 0 : error.message;
}
async function testMcpServer(server) {
  const type = getMcpServerType(server.config);
  try {
    if (type === "stdio") {
      return await testStdioServer(server);
    } else if (type === "sse") {
      return await testSseServer(server);
    } else {
      return await testHttpServer(server);
    }
  } catch (error) {
    return {
      success: false,
      tools: [],
      error: error instanceof Error ? error.message : "Unknown error"
    };
  }
}
async function testStdioServer(server) {
  const config = server.config;
  const { cmd, args } = parseCommand(config.command, config.args);
  return new Promise((resolve3) => {
    var _a, _b, _c, _d;
    let child = null;
    let stdout = "";
    let stderr = "";
    let resolved = false;
    let initReceived = false;
    let serverInfo = {};
    const cleanup = () => {
      if (child && !child.killed) {
        child.kill();
      }
    };
    const timeout = setTimeout(() => {
      if (!resolved) {
        resolved = true;
        cleanup();
        resolve3({
          success: false,
          tools: [],
          error: "Connection timeout (10s)"
        });
      }
    }, 1e4);
    try {
      if (!cmd) {
        clearTimeout(timeout);
        resolve3({
          success: false,
          tools: [],
          error: "Missing command"
        });
        return;
      }
      child = (0, import_child_process.spawn)(cmd, args, {
        env: { ...process.env, ...config.env, PATH: getEnhancedPath((_a = config.env) == null ? void 0 : _a.PATH) },
        stdio: ["pipe", "pipe", "pipe"]
      });
      (_b = child.stdout) == null ? void 0 : _b.on("data", (data) => {
        var _a2, _b2, _c2, _d2, _e;
        stdout += data.toString();
        const lines = stdout.split("\n");
        stdout = lines.pop() || "";
        for (const line of lines) {
          if (!line.trim()) continue;
          try {
            const msg = JSON.parse(line);
            if (msg.id === 1) {
              if (msg.error) {
                if (!resolved) {
                  resolved = true;
                  clearTimeout(timeout);
                  cleanup();
                  resolve3({
                    success: false,
                    tools: [],
                    error: msg.error.message || "Initialize failed"
                  });
                }
                return;
              }
              if (msg.result) {
                initReceived = true;
                serverInfo = {
                  name: (_a2 = msg.result.serverInfo) == null ? void 0 : _a2.name,
                  version: (_b2 = msg.result.serverInfo) == null ? void 0 : _b2.version
                };
                const initializedNotification = {
                  jsonrpc: "2.0",
                  method: "notifications/initialized"
                };
                (_c2 = child == null ? void 0 : child.stdin) == null ? void 0 : _c2.write(JSON.stringify(initializedNotification) + "\n");
                const toolsRequest = {
                  jsonrpc: "2.0",
                  id: 2,
                  method: "tools/list",
                  params: {}
                };
                (_d2 = child == null ? void 0 : child.stdin) == null ? void 0 : _d2.write(JSON.stringify(toolsRequest) + "\n");
              }
            }
            if (msg.id === 2) {
              if (!resolved) {
                resolved = true;
                clearTimeout(timeout);
                cleanup();
                if (msg.error) {
                  resolve3({
                    success: true,
                    serverName: serverInfo.name,
                    serverVersion: serverInfo.version,
                    tools: []
                  });
                  return;
                }
                const tools = (((_e = msg.result) == null ? void 0 : _e.tools) || []).map(
                  (t2) => ({
                    name: t2.name,
                    description: t2.description,
                    inputSchema: t2.inputSchema
                  })
                );
                resolve3({
                  success: true,
                  serverName: serverInfo.name,
                  serverVersion: serverInfo.version,
                  tools
                });
              }
              return;
            }
          } catch (e2) {
          }
        }
      });
      (_c = child.stderr) == null ? void 0 : _c.on("data", (data) => {
        stderr += data.toString();
      });
      child.on("error", (error) => {
        if (!resolved) {
          resolved = true;
          clearTimeout(timeout);
          resolve3({
            success: false,
            tools: [],
            error: `Failed to start: ${error.message}`
          });
        }
      });
      child.on("close", (code) => {
        if (!resolved) {
          resolved = true;
          clearTimeout(timeout);
          if (initReceived) {
            resolve3({
              success: true,
              serverName: serverInfo.name,
              serverVersion: serverInfo.version,
              tools: []
            });
          } else if (code !== 0) {
            resolve3({
              success: false,
              tools: [],
              error: stderr || `Process exited with code ${code}`
            });
          }
        }
      });
      const initRequest = {
        jsonrpc: "2.0",
        id: 1,
        method: "initialize",
        params: {
          protocolVersion: "2024-11-05",
          capabilities: {},
          clientInfo: { name: "claudian-tester", version: "1.0.0" }
        }
      };
      (_d = child.stdin) == null ? void 0 : _d.write(JSON.stringify(initRequest) + "\n");
    } catch (error) {
      resolved = true;
      clearTimeout(timeout);
      resolve3({
        success: false,
        tools: [],
        error: error instanceof Error ? error.message : "Failed to spawn process"
      });
    }
  });
}
function httpRequest(url, headers, body) {
  return new Promise((resolve3, reject) => {
    const isHttps = url.protocol === "https:";
    const httpModule = isHttps ? https : http;
    const req = httpModule.request(
      {
        hostname: url.hostname,
        port: url.port || (isHttps ? 443 : 80),
        path: url.pathname + url.search,
        method: "POST",
        headers: {
          ...headers,
          "Content-Length": Buffer.byteLength(body)
        }
      },
      (res) => {
        let data = "";
        res.on("data", (chunk) => {
          data += chunk;
        });
        res.on("end", () => {
          resolve3({ statusCode: res.statusCode || 0, data });
        });
      }
    );
    req.on("error", reject);
    req.write(body);
    req.end();
  });
}
function parseJsonOrSse(data) {
  const trimmed = data.trim();
  try {
    return JSON.parse(trimmed);
  } catch (e2) {
    const dataMatch = trimmed.match(/^data:\s*(.+)$/m);
    if (dataMatch) {
      try {
        return JSON.parse(dataMatch[1]);
      } catch (e3) {
      }
    }
  }
  return null;
}
async function testHttpServer(server) {
  const config = server.config;
  return new Promise((resolve3) => {
    const timeout = setTimeout(() => {
      resolve3({
        success: false,
        tools: [],
        error: "Connection timeout (10s)"
      });
    }, 1e4);
    (async () => {
      try {
        const url = new URL(config.url);
        const headers = {
          "Content-Type": "application/json",
          Accept: "application/json, text/event-stream",
          ...config.headers
        };
        const initRequest = JSON.stringify({
          jsonrpc: "2.0",
          id: 1,
          method: "initialize",
          params: {
            protocolVersion: "2024-11-05",
            capabilities: {},
            clientInfo: { name: "claudian-tester", version: "1.0.0" }
          }
        });
        const initResponse = await httpRequest(url, headers, initRequest);
        let serverName;
        let serverVersion;
        const initResult = parseJsonOrSse(initResponse.data);
        if (!initResult) {
          clearTimeout(timeout);
          resolve3({
            success: false,
            tools: [],
            error: `Invalid response: ${initResponse.data.slice(0, 200)}`
          });
          return;
        }
        const initError = getMcpError(initResult);
        if (initError) {
          clearTimeout(timeout);
          resolve3({
            success: false,
            tools: [],
            error: initError
          });
          return;
        }
        const resultField = initResult.result;
        if (resultField == null ? void 0 : resultField.serverInfo) {
          serverName = resultField.serverInfo.name;
          serverVersion = resultField.serverInfo.version;
        }
        const initializedNotification = JSON.stringify({
          jsonrpc: "2.0",
          method: "notifications/initialized"
        });
        httpRequest(url, headers, initializedNotification).catch(() => {
        });
        const toolsRequest = JSON.stringify({
          jsonrpc: "2.0",
          id: 2,
          method: "tools/list",
          params: {}
        });
        const toolsResponse = await httpRequest(url, headers, toolsRequest);
        const toolsResult = parseJsonOrSse(toolsResponse.data);
        clearTimeout(timeout);
        if (!toolsResult) {
          resolve3({
            success: true,
            serverName,
            serverVersion,
            tools: []
          });
          return;
        }
        if (getMcpError(toolsResult)) {
          resolve3({
            success: true,
            serverName,
            serverVersion,
            tools: []
          });
          return;
        }
        const resultObj = toolsResult.result;
        const tools = ((resultObj == null ? void 0 : resultObj.tools) || []).map(
          (t2) => ({
            name: t2.name,
            description: t2.description,
            inputSchema: t2.inputSchema
          })
        );
        resolve3({
          success: true,
          serverName,
          serverVersion,
          tools
        });
      } catch (error) {
        clearTimeout(timeout);
        resolve3({
          success: false,
          tools: [],
          error: error instanceof Error ? error.message : "Request failed"
        });
      }
    })();
  });
}
async function testSseServer(server) {
  var _a, _b, _c, _d, _e;
  const config = server.config;
  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), 1e4);
  try {
    const sseUrl = new URL(config.url);
    const headers = {
      Accept: "text/event-stream",
      ...config.headers
    };
    const response = await fetch(sseUrl.toString(), {
      method: "GET",
      headers,
      signal: controller.signal
    });
    if (!response.ok || !response.body) {
      clearTimeout(timeout);
      return {
        success: false,
        tools: [],
        error: `HTTP ${response.status}: ${response.statusText}`
      };
    }
    let endpointResolved = false;
    let resolveEndpoint = null;
    const endpointPromise = new Promise((resolve3) => {
      resolveEndpoint = resolve3;
    });
    const pending = /* @__PURE__ */ new Map();
    const streamPromise = consumeSseStream(response.body, (event) => {
      if (!endpointResolved) {
        const candidate = resolveSseEndpoint(event.data, sseUrl);
        if (candidate) {
          endpointResolved = true;
          resolveEndpoint == null ? void 0 : resolveEndpoint(candidate);
        }
      }
      const payload = tryParseJson(event.data);
      if (payload && typeof payload === "object") {
        const record = payload;
        const id = parseRpcId(record.id);
        if (id !== null) {
          const handler = pending.get(id);
          if (handler) {
            handler(record);
          }
        }
      }
    }).catch(() => {
    });
    let endpointTimeout = null;
    const endpointTimeoutPromise = new Promise((_, reject) => {
      endpointTimeout = setTimeout(() => reject(new Error("SSE endpoint not advertised")), 5e3);
    });
    let postUrl;
    try {
      postUrl = await Promise.race([endpointPromise, endpointTimeoutPromise]);
    } finally {
      if (endpointTimeout) clearTimeout(endpointTimeout);
    }
    const postOptions = { signal: controller.signal, timeoutMs: 8e3 };
    const initRequest = {
      jsonrpc: "2.0",
      id: 1,
      method: "initialize",
      params: {
        protocolVersion: "2024-11-05",
        capabilities: {},
        clientInfo: { name: "claudian-tester", version: "1.0.0" }
      }
    };
    const initResponsePromise = waitForRpcResponse(pending, 1, 8e3);
    initResponsePromise.catch(() => {
    });
    const initPost = await postJsonRpc(postUrl, (_a = config.headers) != null ? _a : {}, initRequest, postOptions);
    if (initPost.status >= 400) {
      initResponsePromise.catch(() => {
      });
      clearTimeout(timeout);
      controller.abort();
      return {
        success: false,
        tools: [],
        error: `HTTP ${initPost.status}: ${initPost.statusText}`
      };
    }
    const initResponse = await initResponsePromise;
    const initError = initResponse.error;
    if (initError) {
      clearTimeout(timeout);
      controller.abort();
      return {
        success: false,
        tools: [],
        error: initError.message || "Initialize failed"
      };
    }
    const serverInfo = initResponse.result;
    const serverName = (_b = serverInfo == null ? void 0 : serverInfo.serverInfo) == null ? void 0 : _b.name;
    const serverVersion = (_c = serverInfo == null ? void 0 : serverInfo.serverInfo) == null ? void 0 : _c.version;
    await postJsonRpc(postUrl, (_d = config.headers) != null ? _d : {}, {
      jsonrpc: "2.0",
      method: "notifications/initialized"
    }, postOptions).catch(() => {
    });
    const toolsResponsePromise = waitForRpcResponse(pending, 2, 8e3);
    toolsResponsePromise.catch(() => {
    });
    await postJsonRpc(postUrl, (_e = config.headers) != null ? _e : {}, {
      jsonrpc: "2.0",
      id: 2,
      method: "tools/list",
      params: {}
    }, postOptions);
    let tools = [];
    try {
      const toolsResponse = await toolsResponsePromise;
      const toolsError = toolsResponse.error;
      if (!toolsError) {
        const result = toolsResponse.result;
        tools = ((result == null ? void 0 : result.tools) || []).map(
          (t2) => ({
            name: t2.name,
            description: t2.description,
            inputSchema: t2.inputSchema
          })
        );
      }
    } catch (e2) {
    }
    clearTimeout(timeout);
    controller.abort();
    await streamPromise;
    return {
      success: true,
      serverName,
      serverVersion,
      tools
    };
  } catch (error) {
    clearTimeout(timeout);
    controller.abort();
    return {
      success: false,
      tools: [],
      error: error instanceof Error ? error.message : "Request failed"
    };
  }
}

// src/core/plugins/PluginManager.ts
var PluginManager = class {
  constructor(pluginStorage, ccSettingsStorage) {
    this.plugins = [];
    /** Map of plugin ID to enabled state from CC settings. */
    this.enabledState = {};
    this.pluginStorage = pluginStorage;
    this.ccSettingsStorage = ccSettingsStorage;
  }
  /**
   * Get plugins that are both enabled and available.
   */
  getActivePlugins() {
    return this.plugins.filter((plugin) => plugin.enabled && plugin.status === "available");
  }
  /**
   * Check if a plugin is enabled based on CC settings.
   * Plugins are enabled by default unless explicitly set to false.
   */
  isPluginEnabled(pluginId) {
    const state = this.enabledState[pluginId];
    return state !== false;
  }
  applyEnabledState() {
    for (const plugin of this.plugins) {
      plugin.enabled = this.isPluginEnabled(plugin.id);
    }
  }
  /**
   * Load enabled state from CC settings.
   * Call this before or after loadPlugins().
   */
  async loadEnabledState() {
    this.enabledState = await this.ccSettingsStorage.getEnabledPlugins();
    this.applyEnabledState();
  }
  /**
   * Load plugins from the registry and apply enabled state.
   */
  async loadPlugins() {
    this.plugins = this.pluginStorage.loadPlugins();
    this.applyEnabledState();
  }
  /**
   * Get all discovered plugins.
   * Returns a copy of the plugins array (sorted by PluginStorage: project/local first, then user).
   */
  getPlugins() {
    return [...this.plugins];
  }
  getActivePluginConfigs() {
    return this.getActivePlugins().map((plugin) => ({
      type: "local",
      path: plugin.pluginPath
    }));
  }
  hasEnabledPlugins() {
    return this.getActivePlugins().length > 0;
  }
  getEnabledCount() {
    return this.getActivePlugins().length;
  }
  /**
   * Get a stable key representing active plugin configuration.
   * Used to detect changes that require restarting the persistent query.
   */
  getPluginsKey() {
    const activePlugins = this.getActivePlugins().sort((a, b3) => a.id.localeCompare(b3.id));
    if (activePlugins.length === 0) {
      return "";
    }
    return activePlugins.map((plugin) => `${plugin.id}:${plugin.pluginPath}`).join("|");
  }
  /**
   * Toggle a plugin's enabled state.
   * Writes to .claude/settings.json so CLI respects the state.
   */
  async togglePlugin(pluginId) {
    const plugin = this.plugins.find((p2) => p2.id === pluginId);
    if (!plugin) {
      return;
    }
    const newEnabled = !plugin.enabled;
    this.enabledState[pluginId] = newEnabled;
    plugin.enabled = newEnabled;
    await this.ccSettingsStorage.setPluginEnabled(pluginId, newEnabled);
  }
  async enablePlugin(pluginId) {
    const plugin = this.plugins.find((p2) => p2.id === pluginId);
    if (!plugin || plugin.enabled) {
      return;
    }
    this.enabledState[pluginId] = true;
    plugin.enabled = true;
    await this.ccSettingsStorage.setPluginEnabled(pluginId, true);
  }
  async disablePlugin(pluginId) {
    const plugin = this.plugins.find((p2) => p2.id === pluginId);
    if (!plugin || !plugin.enabled) {
      return;
    }
    this.enabledState[pluginId] = false;
    plugin.enabled = false;
    await this.ccSettingsStorage.setPluginEnabled(pluginId, false);
  }
  hasPlugins() {
    return this.plugins.length > 0;
  }
  /**
   * Get install paths for enabled and available plugins.
   * Returns array of { pluginName, commandsPath } for each active plugin.
   * Note: Actual command existence is verified by loadPluginCommands().
   */
  getPluginCommandPaths() {
    return this.getActivePlugins().map((plugin) => ({
      pluginName: plugin.name,
      commandsPath: plugin.installPath
      // The commands subdirectory is appended by loadPluginCommands()
    }));
  }
};

// src/core/plugins/PluginStorage.ts
var fs4 = __toESM(require("fs"));
var os4 = __toESM(require("os"));
var path4 = __toESM(require("path"));

// src/utils/slashCommand.ts
function parseSlashCommandContent(content) {
  var _a, _b;
  const frontmatterPattern = /^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/;
  const match = content.match(frontmatterPattern);
  if (!match) {
    return { promptContent: content };
  }
  const yamlContent = match[1];
  const promptContent = match[2];
  const result = { promptContent };
  const lines = yamlContent.split(/\r?\n/);
  let arrayKey = null;
  let arrayItems = [];
  let blockScalarKey = null;
  let blockScalarStyle = null;
  let blockScalarLines = [];
  let blockScalarIndent = null;
  const flushArray = () => {
    if (arrayKey === "allowed-tools") {
      result.allowedTools = arrayItems;
    }
    arrayKey = null;
    arrayItems = [];
  };
  const flushBlockScalar = () => {
    if (!blockScalarKey) return;
    let value;
    if (blockScalarStyle === "literal") {
      value = blockScalarLines.join("\n");
    } else {
      value = blockScalarLines.join("\n").replace(/(?<!\n)\n(?!\n)/g, " ").trim();
    }
    switch (blockScalarKey) {
      case "description":
        result.description = value;
        break;
      case "argument-hint":
        result.argumentHint = value;
        break;
      case "model":
        result.model = value;
        break;
    }
    blockScalarKey = null;
    blockScalarStyle = null;
    blockScalarLines = [];
    blockScalarIndent = null;
  };
  for (let i2 = 0; i2 < lines.length; i2++) {
    const line = lines[i2];
    const trimmedLine = line.trim();
    if (blockScalarKey) {
      if (trimmedLine === "") {
        blockScalarLines.push("");
        continue;
      }
      const leadingSpaces = (_b = (_a = line.match(/^(\s*)/)) == null ? void 0 : _a[1].length) != null ? _b : 0;
      if (blockScalarIndent === null) {
        if (leadingSpaces === 0) {
          flushBlockScalar();
        } else {
          blockScalarIndent = leadingSpaces;
          const content2 = line.slice(blockScalarIndent);
          blockScalarLines.push(content2);
          continue;
        }
      } else if (leadingSpaces >= blockScalarIndent) {
        const content2 = line.slice(blockScalarIndent);
        blockScalarLines.push(content2);
        continue;
      } else {
        flushBlockScalar();
      }
    }
    if (arrayKey) {
      if (trimmedLine.startsWith("- ")) {
        arrayItems.push(unquoteYamlString(trimmedLine.slice(2).trim()));
        continue;
      }
      if (trimmedLine === "") {
        continue;
      }
      flushArray();
    }
    const colonIndex = line.indexOf(":");
    if (colonIndex <= 0) {
      continue;
    }
    const key = line.slice(0, colonIndex).trim();
    const value = line.slice(colonIndex + 1).trim();
    const blockScalarMatch = value.match(/^([|>])([+-])?$/);
    if (blockScalarMatch && (key === "description" || key === "argument-hint" || key === "model")) {
      blockScalarKey = key;
      blockScalarStyle = blockScalarMatch[1] === "|" ? "literal" : "folded";
      blockScalarLines = [];
      blockScalarIndent = null;
      continue;
    }
    switch (key) {
      case "description":
        result.description = unquoteYamlString(value);
        break;
      case "argument-hint":
        result.argumentHint = unquoteYamlString(value);
        break;
      case "model":
        result.model = unquoteYamlString(value);
        break;
      case "allowed-tools":
        if (!value) {
          arrayKey = key;
          arrayItems = [];
          break;
        }
        if (value.startsWith("[") && value.endsWith("]")) {
          result.allowedTools = value.slice(1, -1).split(",").map((s) => unquoteYamlString(s.trim())).filter(Boolean);
          break;
        }
        result.allowedTools = [unquoteYamlString(value)].filter(Boolean);
        break;
    }
  }
  if (blockScalarKey) {
    flushBlockScalar();
  }
  if (arrayKey) {
    flushArray();
  }
  return result;
}
function unquoteYamlString(value) {
  if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
    return value.slice(1, -1);
  }
  return value;
}

// src/core/plugins/PluginStorage.ts
var INSTALLED_PLUGINS_PATH = path4.join(os4.homedir(), ".claude", "plugins", "installed_plugins.json");
var PLUGIN_MANIFEST_FILE = "plugin.json";
var MARKETPLACE_MANIFEST_FILE = "marketplace.json";
var PLUGIN_DIR_NAME = ".claude-plugin";
function isValidPluginEntry(entry) {
  if (typeof entry !== "object" || entry === null) return false;
  const e2 = entry;
  return typeof e2.installPath === "string" && typeof e2.version === "string" && typeof e2.installedAt === "string" && (e2.scope === void 0 || ["user", "project", "local"].includes(e2.scope));
}
function parseInstalledPluginsFile(content) {
  try {
    const data = JSON.parse(content);
    if (typeof data !== "object" || data === null) {
      return { data: null, error: "Invalid format: expected object at root" };
    }
    if (typeof data.version !== "number") {
      return { data: null, error: "Invalid format: missing or invalid version field" };
    }
    if (typeof data.plugins !== "object" || data.plugins === null) {
      return { data: null, error: "Invalid format: missing or invalid plugins field" };
    }
    for (const [pluginId, entries] of Object.entries(data.plugins)) {
      if (!Array.isArray(entries)) {
        continue;
      }
      data.plugins[pluginId] = entries.filter((entry) => isValidPluginEntry(entry));
    }
    return { data };
  } catch (err) {
    const message = err instanceof Error ? err.message : "Unknown parse error";
    return { data: null, error: `JSON parse error: ${message}` };
  }
}
function readJsonFile(filePath) {
  try {
    if (!fs4.existsSync(filePath)) return { data: null };
    const content = fs4.readFileSync(filePath, "utf-8");
    return { data: JSON.parse(content) };
  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : String(err);
    return { data: null, error: errorMessage };
  }
}
var NUMERIC_IDENTIFIER_RE = /^[0-9]+$/;
function parseSemver(version) {
  const trimmed = version.trim();
  const normalized = trimmed.startsWith("v") || trimmed.startsWith("V") ? trimmed.slice(1) : trimmed;
  const [coreAndPre] = normalized.split("+", 1);
  const [corePart, prereleasePart] = coreAndPre.split("-", 2);
  if (!corePart) {
    return { core: [], prerelease: [], valid: false };
  }
  const coreSegments = corePart.split(".");
  const core = [];
  for (const segment of coreSegments) {
    if (!segment || !NUMERIC_IDENTIFIER_RE.test(segment)) {
      return { core: [], prerelease: [], valid: false };
    }
    core.push(Number(segment));
  }
  const prerelease = prereleasePart ? prereleasePart.split(".").map((id) => NUMERIC_IDENTIFIER_RE.test(id) ? Number(id) : id) : [];
  return { core, prerelease, valid: true };
}
function comparePrerelease(a, b3) {
  if (a.length === 0 && b3.length === 0) return 0;
  if (a.length === 0) return 1;
  if (b3.length === 0) return -1;
  const maxLen = Math.max(a.length, b3.length);
  for (let i2 = 0; i2 < maxLen; i2++) {
    const aId = a[i2];
    const bId = b3[i2];
    if (aId === void 0) return -1;
    if (bId === void 0) return 1;
    if (aId === bId) continue;
    const aIsNumber = typeof aId === "number";
    const bIsNumber = typeof bId === "number";
    if (aIsNumber && bIsNumber) {
      return aId > bId ? 1 : -1;
    }
    if (aIsNumber !== bIsNumber) {
      return aIsNumber ? -1 : 1;
    }
    return String(aId).localeCompare(String(bId));
  }
  return 0;
}
function compareSemver(a, b3) {
  var _a, _b;
  const parsedA = parseSemver(a);
  const parsedB = parseSemver(b3);
  if (!parsedA.valid || !parsedB.valid) {
    return a.localeCompare(b3, void 0, { numeric: true, sensitivity: "base" });
  }
  const maxLen = Math.max(3, parsedA.core.length, parsedB.core.length);
  for (let i2 = 0; i2 < maxLen; i2++) {
    const aVal = (_a = parsedA.core[i2]) != null ? _a : 0;
    const bVal = (_b = parsedB.core[i2]) != null ? _b : 0;
    if (aVal > bVal) return 1;
    if (aVal < bVal) return -1;
  }
  return comparePrerelease(parsedA.prerelease, parsedB.prerelease);
}
function pickNewestEntry(entries) {
  if (entries.length === 0) return null;
  if (entries.length === 1) return entries[0];
  return entries.reduce((newest, current) => {
    var _a, _b;
    const newestDate = (_a = newest.lastUpdated) != null ? _a : newest.installedAt;
    const currentDate = (_b = current.lastUpdated) != null ? _b : current.installedAt;
    if (currentDate > newestDate) return current;
    if (currentDate < newestDate) return newest;
    return compareSemver(current.version, newest.version) > 0 ? current : newest;
  });
}
function determineScope(entry) {
  var _a, _b;
  if (!entry.projectPath) return (_a = entry.scope) != null ? _a : "user";
  const homeDir = normalizePathForComparison(os4.homedir());
  const entryPath = normalizePathForComparison(entry.projectPath);
  if (entryPath === homeDir) {
    return "user";
  }
  return (_b = entry.scope) != null ? _b : "project";
}
function determinePluginStatus(installPathExists, manifestError) {
  if (!installPathExists) {
    return "unavailable";
  }
  if (manifestError) {
    return "invalid-manifest";
  }
  return "available";
}
function shouldIncludeEntry(entry, vaultPath) {
  const scope = determineScope(entry);
  if (scope === "user") {
    return true;
  }
  if (!entry.projectPath) return false;
  const normalizedVault = normalizePathForComparison(vaultPath);
  const normalizedProjectPath = normalizePathForComparison(entry.projectPath);
  return normalizedVault === normalizedProjectPath || normalizedVault.startsWith(normalizedProjectPath + "/");
}
function loadPluginManifest(installPath, pluginId) {
  const pluginDir = path4.join(installPath, PLUGIN_DIR_NAME);
  if (!fs4.existsSync(pluginDir)) {
    return {
      manifest: null,
      pluginPath: "",
      error: "Plugin directory not found"
    };
  }
  const singleManifestPath = path4.join(pluginDir, PLUGIN_MANIFEST_FILE);
  if (fs4.existsSync(singleManifestPath)) {
    const { data: manifest, error } = readJsonFile(singleManifestPath);
    if (manifest) {
      return {
        manifest,
        pluginPath: pluginDir
      };
    }
    if (error) {
      return {
        manifest: null,
        pluginPath: "",
        error: `Failed to read plugin.json: ${error}`
      };
    }
  }
  const marketplaceManifestPath = path4.join(pluginDir, MARKETPLACE_MANIFEST_FILE);
  if (fs4.existsSync(marketplaceManifestPath)) {
    const { data: marketplaceManifest, error } = readJsonFile(marketplaceManifestPath);
    if (error) {
      return {
        manifest: null,
        pluginPath: "",
        error: `Failed to read marketplace.json: ${error}`
      };
    }
    if (marketplaceManifest == null ? void 0 : marketplaceManifest.plugins) {
      const pluginName = pluginId.replace(/@.*$/, "");
      const matchingPlugin = marketplaceManifest.plugins.find((p2) => {
        const normalizedName = p2.name.toLowerCase().replace(/\s+/g, "-");
        return normalizedName === pluginName.toLowerCase();
      });
      if (matchingPlugin) {
        const pluginPath = matchingPlugin.source ? path4.join(pluginDir, matchingPlugin.source) : pluginDir;
        return {
          manifest: {
            name: matchingPlugin.name,
            description: matchingPlugin.description
          },
          pluginPath
        };
      }
      if (marketplaceManifest.plugins.length > 0) {
        const firstPlugin = marketplaceManifest.plugins[0];
        const pluginPath = firstPlugin.source ? path4.join(pluginDir, firstPlugin.source) : pluginDir;
        return {
          manifest: {
            name: firstPlugin.name,
            description: firstPlugin.description
          },
          pluginPath
        };
      }
    }
  }
  return {
    manifest: null,
    pluginPath: "",
    error: "Invalid or missing manifest"
  };
}
var PluginStorage = class {
  constructor(vaultPath) {
    this.vaultPath = vaultPath;
  }
  /**
   * Load all plugins from the global registry.
   * Filters by projectPath against the current vault.
   */
  loadPlugins() {
    var _a;
    const content = this.readInstalledPluginsFile();
    if (!content) {
      return [];
    }
    const { data: pluginsFile } = parseInstalledPluginsFile(content);
    if (!pluginsFile) {
      return [];
    }
    const plugins = [];
    for (const [pluginId, entries] of Object.entries(pluginsFile.plugins)) {
      const applicableEntries = entries.filter(
        (entry2) => shouldIncludeEntry(entry2, this.vaultPath)
      );
      if (applicableEntries.length === 0) {
        continue;
      }
      const entry = pickNewestEntry(applicableEntries);
      if (!entry) continue;
      const { manifest, pluginPath, error } = loadPluginManifest(entry.installPath, pluginId);
      const scope = determineScope(entry);
      const installPathExists = fs4.existsSync(entry.installPath);
      const status = determinePluginStatus(installPathExists, error);
      const errorMessage = !installPathExists ? "Plugin directory not found" : error;
      plugins.push({
        id: pluginId,
        name: (_a = manifest == null ? void 0 : manifest.name) != null ? _a : pluginId,
        description: manifest == null ? void 0 : manifest.description,
        version: entry.version,
        installPath: entry.installPath,
        pluginPath: pluginPath || entry.installPath,
        scope,
        projectPath: entry.projectPath,
        enabled: false,
        // Will be set by PluginManager
        status,
        error: errorMessage
      });
    }
    return plugins.sort((a, b3) => {
      const scopeOrder = { local: 0, project: 1, user: 2 };
      return scopeOrder[a.scope] - scopeOrder[b3.scope];
    });
  }
  readInstalledPluginsFile() {
    try {
      if (!fs4.existsSync(INSTALLED_PLUGINS_PATH)) {
        return null;
      }
      return fs4.readFileSync(INSTALLED_PLUGINS_PATH, "utf-8");
    } catch (e2) {
      return null;
    }
  }
};
function loadPluginCommands(installPath, pluginName) {
  const commandsDir = path4.join(installPath, "commands");
  const commands = [];
  if (!fs4.existsSync(commandsDir)) {
    return commands;
  }
  try {
    const files = listMarkdownFilesRecursive(commandsDir);
    for (const filePath of files) {
      try {
        const content = fs4.readFileSync(filePath, "utf-8");
        const command = parsePluginCommandFile(content, filePath, commandsDir, pluginName);
        if (command) {
          commands.push(command);
        }
      } catch (e2) {
      }
    }
  } catch (e2) {
  }
  return commands;
}
function listMarkdownFilesRecursive(dir) {
  const files = [];
  if (!fs4.existsSync(dir)) {
    return files;
  }
  const entries = fs4.readdirSync(dir, { withFileTypes: true });
  for (const entry of entries) {
    const fullPath = path4.join(dir, entry.name);
    if (entry.isDirectory()) {
      files.push(...listMarkdownFilesRecursive(fullPath));
    } else if (entry.isFile() && entry.name.endsWith(".md")) {
      files.push(fullPath);
    }
  }
  return files;
}
function parsePluginCommandFile(content, filePath, commandsDir, pluginName) {
  const parsed = parseSlashCommandContent(content);
  const relativePath = path4.relative(commandsDir, filePath);
  const nameWithoutExt = relativePath.replace(/\.md$/, "").replace(/\\/g, "/");
  const name = `${pluginName.toLowerCase().replace(/\s+/g, "-")}:${nameWithoutExt}`;
  const escapedName = name.replace(/-/g, "-_").replace(/:/g, "--");
  const id = `plugin-${escapedName}`;
  return {
    id,
    name,
    description: parsed.description,
    argumentHint: parsed.argumentHint,
    allowedTools: parsed.allowedTools,
    model: parsed.model,
    content: parsed.promptContent
  };
}

// src/core/storage/migrationConstants.ts
var CLAUDIAN_ONLY_FIELDS = /* @__PURE__ */ new Set([
  // User preferences
  "userName",
  // Security settings
  "enableBlocklist",
  "blockedCommands",
  "permissionMode",
  "lastNonPlanPermissionMode",
  // Model & thinking
  "model",
  "thinkingBudget",
  "enableAutoTitleGeneration",
  "titleGenerationModel",
  // Content settings
  "excludedTags",
  "mediaFolder",
  "systemPrompt",
  "allowedExportPaths",
  "persistentExternalContextPaths",
  // Environment (Claudian uses string format + snippets)
  "environmentVariables",
  "envSnippets",
  // UI settings
  "keyboardNavigation",
  // CLI paths
  "claudeCliPath",
  "claudeCliPaths",
  "loadUserClaudeSettings",
  // Deprecated fields (removed completely, not migrated)
  "allowedContextPaths",
  "showToolUse",
  "toolCallExpandedByDefault"
]);
function convertEnvObjectToString(env) {
  if (!env || typeof env !== "object") {
    return "";
  }
  return Object.entries(env).filter(([key, value]) => typeof key === "string" && typeof value === "string").map(([key, value]) => `${key}=${value}`).join("\n");
}
function mergeEnvironmentVariables(existing, additional) {
  const envMap = /* @__PURE__ */ new Map();
  for (const line of existing.split("\n")) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith("#")) continue;
    const eqIndex = trimmed.indexOf("=");
    if (eqIndex > 0) {
      const key = trimmed.slice(0, eqIndex);
      const value = trimmed.slice(eqIndex + 1);
      envMap.set(key, value);
    }
  }
  for (const line of additional.split("\n")) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith("#")) continue;
    const eqIndex = trimmed.indexOf("=");
    if (eqIndex > 0) {
      const key = trimmed.slice(0, eqIndex);
      const value = trimmed.slice(eqIndex + 1);
      envMap.set(key, value);
    }
  }
  return Array.from(envMap.entries()).map(([key, value]) => `${key}=${value}`).join("\n");
}

// src/core/storage/CCSettingsStorage.ts
var CC_SETTINGS_PATH = ".claude/settings.json";
var CC_SETTINGS_SCHEMA = "https://json.schemastore.org/claude-code-settings.json";
function hasClaudianOnlyFields(data) {
  return Object.keys(data).some((key) => CLAUDIAN_ONLY_FIELDS.has(key));
}
function isLegacyPermissionsFormat(data) {
  if (!data || typeof data !== "object") return false;
  const obj = data;
  if (!Array.isArray(obj.permissions)) return false;
  if (obj.permissions.length === 0) return false;
  const first = obj.permissions[0];
  return typeof first === "object" && first !== null && "toolName" in first && "pattern" in first;
}
function normalizePermissions(permissions) {
  if (!permissions || typeof permissions !== "object") {
    return { ...DEFAULT_CC_PERMISSIONS };
  }
  const p2 = permissions;
  return {
    allow: Array.isArray(p2.allow) ? p2.allow.filter((r2) => typeof r2 === "string").map((r2) => r2) : [],
    deny: Array.isArray(p2.deny) ? p2.deny.filter((r2) => typeof r2 === "string").map((r2) => r2) : [],
    ask: Array.isArray(p2.ask) ? p2.ask.filter((r2) => typeof r2 === "string").map((r2) => r2) : [],
    defaultMode: typeof p2.defaultMode === "string" ? p2.defaultMode : void 0,
    additionalDirectories: Array.isArray(p2.additionalDirectories) ? p2.additionalDirectories.filter((d) => typeof d === "string") : void 0
  };
}
var CCSettingsStorage = class {
  constructor(adapter) {
    this.adapter = adapter;
  }
  /**
   * Load CC settings from .claude/settings.json.
   * Returns default settings if file doesn't exist.
   * Throws if file exists but cannot be read or parsed.
   */
  async load() {
    if (!await this.adapter.exists(CC_SETTINGS_PATH)) {
      return { ...DEFAULT_CC_SETTINGS };
    }
    const content = await this.adapter.read(CC_SETTINGS_PATH);
    const stored = JSON.parse(content);
    if (isLegacyPermissionsFormat(stored)) {
      const legacyPerms = stored.permissions;
      const ccPerms = legacyPermissionsToCCPermissions(legacyPerms);
      return {
        $schema: CC_SETTINGS_SCHEMA,
        ...stored,
        permissions: ccPerms
      };
    }
    return {
      $schema: CC_SETTINGS_SCHEMA,
      ...stored,
      permissions: normalizePermissions(stored.permissions)
    };
  }
  /**
   * Save CC settings to .claude/settings.json.
   * Preserves unknown fields for CC compatibility.
   *
   * @param stripClaudianFields - If true, remove Claudian-only fields (only during migration)
   */
  async save(settings11, stripClaudianFields = false) {
    var _a;
    let existing = {};
    if (await this.adapter.exists(CC_SETTINGS_PATH)) {
      try {
        const content2 = await this.adapter.read(CC_SETTINGS_PATH);
        const parsed = JSON.parse(content2);
        if (stripClaudianFields && (isLegacyPermissionsFormat(parsed) || hasClaudianOnlyFields(parsed))) {
          existing = {};
          for (const [key, value] of Object.entries(parsed)) {
            if (!CLAUDIAN_ONLY_FIELDS.has(key)) {
              existing[key] = value;
            }
          }
          if (Array.isArray(existing.permissions)) {
            delete existing.permissions;
          }
        } else {
          existing = parsed;
        }
      } catch (e2) {
      }
    }
    const merged = {
      ...existing,
      $schema: CC_SETTINGS_SCHEMA,
      permissions: (_a = settings11.permissions) != null ? _a : { ...DEFAULT_CC_PERMISSIONS }
    };
    if (settings11.enabledPlugins !== void 0) {
      merged.enabledPlugins = settings11.enabledPlugins;
    }
    const content = JSON.stringify(merged, null, 2);
    await this.adapter.write(CC_SETTINGS_PATH, content);
  }
  async exists() {
    return this.adapter.exists(CC_SETTINGS_PATH);
  }
  async getPermissions() {
    var _a;
    const settings11 = await this.load();
    return (_a = settings11.permissions) != null ? _a : { ...DEFAULT_CC_PERMISSIONS };
  }
  async updatePermissions(permissions) {
    const settings11 = await this.load();
    settings11.permissions = permissions;
    await this.save(settings11);
  }
  async addAllowRule(rule) {
    var _a, _b;
    const permissions = await this.getPermissions();
    if (!((_a = permissions.allow) == null ? void 0 : _a.includes(rule))) {
      permissions.allow = [...(_b = permissions.allow) != null ? _b : [], rule];
      await this.updatePermissions(permissions);
    }
  }
  async addDenyRule(rule) {
    var _a, _b;
    const permissions = await this.getPermissions();
    if (!((_a = permissions.deny) == null ? void 0 : _a.includes(rule))) {
      permissions.deny = [...(_b = permissions.deny) != null ? _b : [], rule];
      await this.updatePermissions(permissions);
    }
  }
  async addAskRule(rule) {
    var _a, _b;
    const permissions = await this.getPermissions();
    if (!((_a = permissions.ask) == null ? void 0 : _a.includes(rule))) {
      permissions.ask = [...(_b = permissions.ask) != null ? _b : [], rule];
      await this.updatePermissions(permissions);
    }
  }
  /**
   * Remove a rule from all lists.
   */
  async removeRule(rule) {
    var _a, _b, _c;
    const permissions = await this.getPermissions();
    permissions.allow = (_a = permissions.allow) == null ? void 0 : _a.filter((r2) => r2 !== rule);
    permissions.deny = (_b = permissions.deny) == null ? void 0 : _b.filter((r2) => r2 !== rule);
    permissions.ask = (_c = permissions.ask) == null ? void 0 : _c.filter((r2) => r2 !== rule);
    await this.updatePermissions(permissions);
  }
  // ============================================
  // Plugin Methods
  // ============================================
  /**
   * Get enabled plugins map from CC settings.
   * Returns empty object if not set.
   */
  async getEnabledPlugins() {
    var _a;
    const settings11 = await this.load();
    return (_a = settings11.enabledPlugins) != null ? _a : {};
  }
  /**
   * Set plugin enabled state.
   * Writes to .claude/settings.json so CLI respects the state.
   *
   * @param pluginId - Full plugin ID (e.g., "plugin-name@source")
   * @param enabled - true to enable, false to disable
   */
  async setPluginEnabled(pluginId, enabled) {
    var _a;
    const settings11 = await this.load();
    const enabledPlugins = (_a = settings11.enabledPlugins) != null ? _a : {};
    enabledPlugins[pluginId] = enabled;
    settings11.enabledPlugins = enabledPlugins;
    await this.save(settings11);
  }
  /**
   * Get list of plugin IDs that are explicitly enabled.
   * Used for PluginManager initialization.
   */
  async getExplicitlyEnabledPluginIds() {
    const enabledPlugins = await this.getEnabledPlugins();
    return Object.entries(enabledPlugins).filter(([, enabled]) => enabled).map(([id]) => id);
  }
  /**
   * Check if a plugin is explicitly disabled.
   * Returns true only if the plugin is set to false.
   * Returns false if not set (inherits from global) or set to true.
   */
  async isPluginDisabled(pluginId) {
    const enabledPlugins = await this.getEnabledPlugins();
    return enabledPlugins[pluginId] === false;
  }
};

// src/core/storage/ClaudianSettingsStorage.ts
var CLAUDIAN_SETTINGS_PATH = ".claude/claudian-settings.json";
function normalizeCommandList(value, fallback) {
  if (!Array.isArray(value)) {
    return [...fallback];
  }
  return value.filter((item) => typeof item === "string").map((item) => item.trim()).filter((item) => item.length > 0);
}
function normalizeBlockedCommands(value) {
  const defaults = getDefaultBlockedCommands();
  if (Array.isArray(value)) {
    return {
      unix: normalizeCommandList(value, defaults.unix),
      windows: [...defaults.windows]
    };
  }
  if (!value || typeof value !== "object") {
    return defaults;
  }
  const candidate = value;
  return {
    unix: normalizeCommandList(candidate.unix, defaults.unix),
    windows: normalizeCommandList(candidate.windows, defaults.windows)
  };
}
function normalizeHostnameCliPaths(value) {
  if (!value || typeof value !== "object") {
    return {};
  }
  const result = {};
  for (const [key, val] of Object.entries(value)) {
    if (typeof val === "string" && val.trim()) {
      result[key] = val.trim();
    }
  }
  return result;
}
var ClaudianSettingsStorage = class {
  constructor(adapter) {
    this.adapter = adapter;
  }
  /**
  * Load Claudian settings from .claude/claudian-settings.json.
  * Returns default settings if file doesn't exist.
  * Throws if file exists but cannot be read or parsed.
  */
  async load() {
    if (!await this.adapter.exists(CLAUDIAN_SETTINGS_PATH)) {
      return this.getDefaults();
    }
    const content = await this.adapter.read(CLAUDIAN_SETTINGS_PATH);
    const stored = JSON.parse(content);
    const { activeConversationId: _activeConversationId, ...storedWithoutLegacy } = stored;
    const blockedCommands = normalizeBlockedCommands(stored.blockedCommands);
    const hostnameCliPaths = normalizeHostnameCliPaths(stored.claudeCliPathsByHost);
    const legacyCliPath = typeof stored.claudeCliPath === "string" ? stored.claudeCliPath : "";
    return {
      ...this.getDefaults(),
      ...storedWithoutLegacy,
      blockedCommands,
      claudeCliPath: legacyCliPath,
      claudeCliPathsByHost: hostnameCliPaths
    };
  }
  async save(settings11) {
    const content = JSON.stringify(settings11, null, 2);
    await this.adapter.write(CLAUDIAN_SETTINGS_PATH, content);
  }
  async exists() {
    return this.adapter.exists(CLAUDIAN_SETTINGS_PATH);
  }
  async update(updates) {
    const current = await this.load();
    await this.save({ ...current, ...updates });
  }
  /**
   * Read legacy activeConversationId from claudian-settings.json, if present.
   * Used only for one-time migration to tabManagerState.
   */
  async getLegacyActiveConversationId() {
    if (!await this.adapter.exists(CLAUDIAN_SETTINGS_PATH)) {
      return null;
    }
    const content = await this.adapter.read(CLAUDIAN_SETTINGS_PATH);
    const stored = JSON.parse(content);
    const value = stored.activeConversationId;
    if (typeof value === "string") {
      return value;
    }
    return null;
  }
  /**
   * Remove legacy activeConversationId from claudian-settings.json.
   */
  async clearLegacyActiveConversationId() {
    if (!await this.adapter.exists(CLAUDIAN_SETTINGS_PATH)) {
      return;
    }
    const content = await this.adapter.read(CLAUDIAN_SETTINGS_PATH);
    const stored = JSON.parse(content);
    if (!("activeConversationId" in stored)) {
      return;
    }
    delete stored.activeConversationId;
    const nextContent = JSON.stringify(stored, null, 2);
    await this.adapter.write(CLAUDIAN_SETTINGS_PATH, nextContent);
  }
  async setLastModel(model, isCustom) {
    if (isCustom) {
      await this.update({ lastCustomModel: model });
    } else {
      await this.update({ lastClaudeModel: model });
    }
  }
  async setLastEnvHash(hash) {
    await this.update({ lastEnvHash: hash });
  }
  /**
   * Get default settings (excluding separately loaded fields).
   */
  getDefaults() {
    const {
      slashCommands: _,
      ...defaults
    } = DEFAULT_SETTINGS;
    return defaults;
  }
};

// src/core/storage/McpStorage.ts
var MCP_CONFIG_PATH = ".claude/mcp.json";
var McpStorage = class _McpStorage {
  constructor(adapter) {
    this.adapter = adapter;
  }
  async load() {
    var _a, _b, _c, _d, _e;
    try {
      if (!await this.adapter.exists(MCP_CONFIG_PATH)) {
        return [];
      }
      const content = await this.adapter.read(MCP_CONFIG_PATH);
      const file = JSON.parse(content);
      if (!file.mcpServers || typeof file.mcpServers !== "object") {
        return [];
      }
      const claudianMeta = (_b = (_a = file._claudian) == null ? void 0 : _a.servers) != null ? _b : {};
      const servers = [];
      for (const [name, config] of Object.entries(file.mcpServers)) {
        if (!isValidMcpServerConfig(config)) {
          continue;
        }
        const meta = (_c = claudianMeta[name]) != null ? _c : {};
        const disabledTools = Array.isArray(meta.disabledTools) ? meta.disabledTools.filter((tool) => typeof tool === "string") : void 0;
        const normalizedDisabledTools = disabledTools && disabledTools.length > 0 ? disabledTools : void 0;
        servers.push({
          name,
          config,
          enabled: (_d = meta.enabled) != null ? _d : DEFAULT_MCP_SERVER.enabled,
          contextSaving: (_e = meta.contextSaving) != null ? _e : DEFAULT_MCP_SERVER.contextSaving,
          disabledTools: normalizedDisabledTools,
          description: meta.description
        });
      }
      return servers;
    } catch (e2) {
      return [];
    }
  }
  async save(servers) {
    var _a;
    const mcpServers = {};
    const claudianServers = {};
    for (const server of servers) {
      mcpServers[server.name] = server.config;
      const meta = {};
      if (server.enabled !== DEFAULT_MCP_SERVER.enabled) {
        meta.enabled = server.enabled;
      }
      if (server.contextSaving !== DEFAULT_MCP_SERVER.contextSaving) {
        meta.contextSaving = server.contextSaving;
      }
      const normalizedDisabledTools = (_a = server.disabledTools) == null ? void 0 : _a.map((tool) => tool.trim()).filter((tool) => tool.length > 0);
      if (normalizedDisabledTools && normalizedDisabledTools.length > 0) {
        meta.disabledTools = normalizedDisabledTools;
      }
      if (server.description) {
        meta.description = server.description;
      }
      if (Object.keys(meta).length > 0) {
        claudianServers[server.name] = meta;
      }
    }
    let existing = null;
    if (await this.adapter.exists(MCP_CONFIG_PATH)) {
      try {
        const raw = await this.adapter.read(MCP_CONFIG_PATH);
        const parsed = JSON.parse(raw);
        if (parsed && typeof parsed === "object") {
          existing = parsed;
        }
      } catch (e2) {
        existing = null;
      }
    }
    const file = existing ? { ...existing } : {};
    file.mcpServers = mcpServers;
    const existingClaudian = existing && typeof existing._claudian === "object" ? existing._claudian : null;
    if (Object.keys(claudianServers).length > 0) {
      file._claudian = { ...existingClaudian != null ? existingClaudian : {}, servers: claudianServers };
    } else if (existingClaudian) {
      const { servers: _servers, ...rest } = existingClaudian;
      if (Object.keys(rest).length > 0) {
        file._claudian = rest;
      } else {
        delete file._claudian;
      }
    } else {
      delete file._claudian;
    }
    const content = JSON.stringify(file, null, 2);
    await this.adapter.write(MCP_CONFIG_PATH, content);
  }
  async exists() {
    return this.adapter.exists(MCP_CONFIG_PATH);
  }
  /**
   * Parse pasted JSON (supports multiple formats).
   *
   * Formats supported:
   * 1. Full Claude Code format: { "mcpServers": { "name": {...} } }
   * 2. Single server with name: { "name": { "command": "..." } }
   * 3. Single server without name: { "command": "..." }
   */
  static parseClipboardConfig(json) {
    try {
      const parsed = JSON.parse(json);
      if (!parsed || typeof parsed !== "object") {
        throw new Error("Invalid JSON object");
      }
      if (parsed.mcpServers && typeof parsed.mcpServers === "object") {
        const servers2 = [];
        for (const [name, config] of Object.entries(parsed.mcpServers)) {
          if (isValidMcpServerConfig(config)) {
            servers2.push({ name, config });
          }
        }
        if (servers2.length === 0) {
          throw new Error("No valid server configs found in mcpServers");
        }
        return { servers: servers2, needsName: false };
      }
      if (isValidMcpServerConfig(parsed)) {
        return {
          servers: [{ name: "", config: parsed }],
          needsName: true
        };
      }
      const entries = Object.entries(parsed);
      if (entries.length === 1) {
        const [name, config] = entries[0];
        if (isValidMcpServerConfig(config)) {
          return {
            servers: [{ name, config }],
            needsName: false
          };
        }
      }
      const servers = [];
      for (const [name, config] of entries) {
        if (isValidMcpServerConfig(config)) {
          servers.push({ name, config });
        }
      }
      if (servers.length > 0) {
        return { servers, needsName: false };
      }
      throw new Error("Invalid MCP configuration format");
    } catch (error) {
      if (error instanceof SyntaxError) {
        throw new Error("Invalid JSON");
      }
      throw error;
    }
  }
  /**
   * Try to parse clipboard content as MCP config.
   * Returns null if not valid MCP config.
   */
  static tryParseClipboardConfig(text) {
    const trimmed = text.trim();
    if (!trimmed.startsWith("{")) {
      return null;
    }
    try {
      return _McpStorage.parseClipboardConfig(trimmed);
    } catch (e2) {
      return null;
    }
  }
};

// src/core/storage/SessionStorage.ts
var SESSIONS_PATH = ".claude/sessions";
var SessionStorage = class {
  constructor(adapter) {
    this.adapter = adapter;
  }
  async loadConversation(id) {
    const filePath = this.getFilePath(id);
    try {
      if (!await this.adapter.exists(filePath)) {
        return null;
      }
      const content = await this.adapter.read(filePath);
      return this.parseJSONL(content);
    } catch (e2) {
      return null;
    }
  }
  async saveConversation(conversation) {
    const filePath = this.getFilePath(conversation.id);
    const content = this.serializeToJSONL(conversation);
    await this.adapter.write(filePath, content);
  }
  async deleteConversation(id) {
    const filePath = this.getFilePath(id);
    await this.adapter.delete(filePath);
  }
  /** List all conversation metadata (without loading full messages). */
  async listConversations() {
    const metas = [];
    try {
      const files = await this.adapter.listFiles(SESSIONS_PATH);
      for (const filePath of files) {
        if (!filePath.endsWith(".jsonl")) continue;
        try {
          const meta = await this.loadMetaOnly(filePath);
          if (meta) {
            metas.push(meta);
          }
        } catch (e2) {
        }
      }
      metas.sort((a, b3) => b3.updatedAt - a.updatedAt);
    } catch (e2) {
    }
    return metas;
  }
  async loadAllConversations() {
    const conversations = [];
    let failedCount = 0;
    try {
      const files = await this.adapter.listFiles(SESSIONS_PATH);
      for (const filePath of files) {
        if (!filePath.endsWith(".jsonl")) continue;
        try {
          const content = await this.adapter.read(filePath);
          const conversation = this.parseJSONL(content);
          if (conversation) {
            conversations.push(conversation);
          } else {
            failedCount++;
          }
        } catch (e2) {
          failedCount++;
        }
      }
      conversations.sort((a, b3) => b3.updatedAt - a.updatedAt);
    } catch (e2) {
    }
    return { conversations, failedCount };
  }
  async hasSessions() {
    const files = await this.adapter.listFiles(SESSIONS_PATH);
    return files.some((f3) => f3.endsWith(".jsonl"));
  }
  getFilePath(id) {
    return `${SESSIONS_PATH}/${id}.jsonl`;
  }
  async loadMetaOnly(filePath) {
    const content = await this.adapter.read(filePath);
    const firstLine = content.split(/\r?\n/)[0];
    if (!firstLine) return null;
    try {
      const record = JSON.parse(firstLine);
      if (record.type !== "meta") return null;
      const lines = content.split(/\r?\n/).filter((l3) => l3.trim());
      const messageCount = lines.length - 1;
      let preview = "New conversation";
      for (let i2 = 1; i2 < lines.length; i2++) {
        try {
          const msgRecord = JSON.parse(lines[i2]);
          if (msgRecord.type === "message" && msgRecord.message.role === "user") {
            const content2 = msgRecord.message.content;
            preview = content2.substring(0, 50) + (content2.length > 50 ? "..." : "");
            break;
          }
        } catch (e2) {
          continue;
        }
      }
      return {
        id: record.id,
        title: record.title,
        createdAt: record.createdAt,
        updatedAt: record.updatedAt,
        lastResponseAt: record.lastResponseAt,
        messageCount,
        preview,
        titleGenerationStatus: record.titleGenerationStatus
      };
    } catch (e2) {
      return null;
    }
  }
  parseJSONL(content) {
    const lines = content.split(/\r?\n/).filter((l3) => l3.trim());
    if (lines.length === 0) return null;
    let meta = null;
    const messages = [];
    for (const line of lines) {
      try {
        const record = JSON.parse(line);
        if (record.type === "meta") {
          meta = record;
        } else if (record.type === "message") {
          messages.push(record.message);
        }
      } catch (e2) {
      }
    }
    if (!meta) return null;
    return {
      id: meta.id,
      title: meta.title,
      createdAt: meta.createdAt,
      updatedAt: meta.updatedAt,
      lastResponseAt: meta.lastResponseAt,
      sessionId: meta.sessionId,
      messages,
      currentNote: meta.currentNote,
      usage: meta.usage,
      titleGenerationStatus: meta.titleGenerationStatus
    };
  }
  serializeToJSONL(conversation) {
    const lines = [];
    const meta = {
      type: "meta",
      id: conversation.id,
      title: conversation.title,
      createdAt: conversation.createdAt,
      updatedAt: conversation.updatedAt,
      lastResponseAt: conversation.lastResponseAt,
      sessionId: conversation.sessionId,
      currentNote: conversation.currentNote,
      usage: conversation.usage,
      titleGenerationStatus: conversation.titleGenerationStatus
    };
    lines.push(JSON.stringify(meta));
    for (const message of conversation.messages) {
      const storedMessage = this.prepareMessageForStorage(message);
      const record = {
        type: "message",
        message: storedMessage
      };
      lines.push(JSON.stringify(record));
    }
    return lines.join("\n");
  }
  prepareMessageForStorage(message) {
    return message;
  }
  // ============================================
  // SDK-Native Session Metadata (Phase 1)
  // ============================================
  /**
   * Detects if a session uses SDK-native storage.
   * A session is "native" if no legacy JSONL file exists.
   *
   * Legacy sessions have id.jsonl (and optionally id.meta.json).
   * Native sessions have only id.meta.json or no files yet (SDK stores messages).
   */
  async isNativeSession(id) {
    const legacyPath = `${SESSIONS_PATH}/${id}.jsonl`;
    const legacyExists = await this.adapter.exists(legacyPath);
    return !legacyExists;
  }
  getMetadataPath(id) {
    return `${SESSIONS_PATH}/${id}.meta.json`;
  }
  async saveMetadata(metadata) {
    const filePath = this.getMetadataPath(metadata.id);
    const content = JSON.stringify(metadata, null, 2);
    await this.adapter.write(filePath, content);
  }
  async loadMetadata(id) {
    const filePath = this.getMetadataPath(id);
    try {
      if (!await this.adapter.exists(filePath)) {
        return null;
      }
      const content = await this.adapter.read(filePath);
      return JSON.parse(content);
    } catch (e2) {
      return null;
    }
  }
  async deleteMetadata(id) {
    const filePath = this.getMetadataPath(id);
    await this.adapter.delete(filePath);
  }
  /** List all native session metadata (.meta.json files without .jsonl counterparts). */
  async listNativeMetadata() {
    const metas = [];
    try {
      const files = await this.adapter.listFiles(SESSIONS_PATH);
      const metaFiles = files.filter((f3) => f3.endsWith(".meta.json"));
      for (const filePath of metaFiles) {
        const fileName = filePath.split("/").pop() || "";
        const id = fileName.replace(".meta.json", "");
        const legacyPath = `${SESSIONS_PATH}/${id}.jsonl`;
        const legacyExists = await this.adapter.exists(legacyPath);
        if (legacyExists) {
          continue;
        }
        try {
          const content = await this.adapter.read(filePath);
          const meta = JSON.parse(content);
          metas.push(meta);
        } catch (e2) {
        }
      }
    } catch (e2) {
    }
    return metas;
  }
  /**
   * List all conversations, merging legacy JSONL and native metadata sources.
   * Legacy conversations take precedence if both exist.
   */
  async listAllConversations() {
    const metas = [];
    const legacyMetas = await this.listConversations();
    metas.push(...legacyMetas);
    const nativeMetas = await this.listNativeMetadata();
    const legacyIds = new Set(legacyMetas.map((m) => m.id));
    for (const meta of nativeMetas) {
      if (!legacyIds.has(meta.id)) {
        metas.push({
          id: meta.id,
          title: meta.title,
          createdAt: meta.createdAt,
          updatedAt: meta.updatedAt,
          lastResponseAt: meta.lastResponseAt,
          messageCount: 0,
          // Native sessions don't track message count in metadata
          preview: "SDK session",
          // SDK stores messages, we don't parse them for preview
          titleGenerationStatus: meta.titleGenerationStatus,
          isNative: true
        });
      }
    }
    return metas.sort(
      (a, b3) => {
        var _a, _b;
        return ((_a = b3.lastResponseAt) != null ? _a : b3.createdAt) - ((_b = a.lastResponseAt) != null ? _b : a.createdAt);
      }
    );
  }
  toSessionMetadata(conversation) {
    const subagentData = this.extractSubagentData(conversation.messages);
    return {
      id: conversation.id,
      title: conversation.title,
      titleGenerationStatus: conversation.titleGenerationStatus,
      createdAt: conversation.createdAt,
      updatedAt: conversation.updatedAt,
      lastResponseAt: conversation.lastResponseAt,
      sessionId: conversation.sessionId,
      sdkSessionId: conversation.sdkSessionId,
      previousSdkSessionIds: conversation.previousSdkSessionIds,
      currentNote: conversation.currentNote,
      externalContextPaths: conversation.externalContextPaths,
      enabledMcpServers: conversation.enabledMcpServers,
      usage: conversation.usage,
      legacyCutoffAt: conversation.legacyCutoffAt,
      subagentData: Object.keys(subagentData).length > 0 ? subagentData : void 0
    };
  }
  /**
   * Extracts subagentData from messages for persistence.
   * Collects subagent info from all assistant messages.
   */
  extractSubagentData(messages) {
    const result = {};
    for (const msg of messages) {
      if (msg.role !== "assistant" || !msg.subagents) continue;
      for (const subagent of msg.subagents) {
        result[subagent.id] = subagent;
      }
    }
    return result;
  }
};

// src/core/storage/SlashCommandStorage.ts
var COMMANDS_PATH = ".claude/commands";
var SlashCommandStorage = class {
  constructor(adapter) {
    this.adapter = adapter;
  }
  async loadAll() {
    const commands = [];
    try {
      const files = await this.adapter.listFilesRecursive(COMMANDS_PATH);
      for (const filePath of files) {
        if (!filePath.endsWith(".md")) continue;
        try {
          const command = await this.loadFromFile(filePath);
          if (command) {
            commands.push(command);
          }
        } catch (e2) {
        }
      }
    } catch (e2) {
    }
    return commands;
  }
  async loadFromFile(filePath) {
    try {
      const content = await this.adapter.read(filePath);
      return this.parseFile(content, filePath);
    } catch (e2) {
      return null;
    }
  }
  async save(command) {
    const filePath = this.getFilePath(command);
    const content = this.serializeCommand(command);
    await this.adapter.write(filePath, content);
  }
  async delete(commandId) {
    const files = await this.adapter.listFilesRecursive(COMMANDS_PATH);
    for (const filePath of files) {
      if (!filePath.endsWith(".md")) continue;
      const id = this.filePathToId(filePath);
      if (id === commandId) {
        await this.adapter.delete(filePath);
        return;
      }
    }
  }
  async hasCommands() {
    const files = await this.adapter.listFilesRecursive(COMMANDS_PATH);
    return files.some((f3) => f3.endsWith(".md"));
  }
  getFilePath(command) {
    const safeName = command.name.replace(/[^a-zA-Z0-9_/-]/g, "-");
    return `${COMMANDS_PATH}/${safeName}.md`;
  }
  parseFile(content, filePath) {
    const parsed = parseSlashCommandContent(content);
    const id = this.filePathToId(filePath);
    const name = this.filePathToName(filePath);
    return {
      id,
      name,
      description: parsed.description,
      argumentHint: parsed.argumentHint,
      allowedTools: parsed.allowedTools,
      model: parsed.model,
      content: parsed.promptContent
    };
  }
  filePathToId(filePath) {
    const relativePath = filePath.replace(`${COMMANDS_PATH}/`, "").replace(/\.md$/, "");
    const escaped = relativePath.replace(/-/g, "-_").replace(/\//g, "--");
    return `cmd-${escaped}`;
  }
  filePathToName(filePath) {
    return filePath.replace(`${COMMANDS_PATH}/`, "").replace(/\.md$/, "");
  }
  /** Serialize a command to Markdown with YAML frontmatter. */
  serializeCommand(command) {
    const lines = ["---"];
    if (command.description) {
      lines.push(`description: ${this.yamlString(command.description)}`);
    }
    if (command.argumentHint) {
      lines.push(`argument-hint: ${this.yamlString(command.argumentHint)}`);
    }
    if (command.allowedTools && command.allowedTools.length > 0) {
      lines.push("allowed-tools:");
      for (const tool of command.allowedTools) {
        lines.push(`  - ${tool}`);
      }
    }
    if (command.model) {
      lines.push(`model: ${command.model}`);
    }
    if (lines.length === 1) {
      lines.push("");
    }
    lines.push("---");
    const parsed = parseSlashCommandContent(command.content);
    lines.push(parsed.promptContent);
    return lines.join("\n");
  }
  yamlString(value) {
    if (value.includes(":") || value.includes("#") || value.includes("\n") || value.startsWith(" ") || value.endsWith(" ")) {
      return `"${value.replace(/"/g, '\\"')}"`;
    }
    return value;
  }
};

// src/core/storage/VaultFileAdapter.ts
var VaultFileAdapter = class {
  constructor(app) {
    this.app = app;
  }
  async exists(path10) {
    return this.app.vault.adapter.exists(path10);
  }
  async read(path10) {
    return this.app.vault.adapter.read(path10);
  }
  async write(path10, content) {
    const folder = path10.substring(0, path10.lastIndexOf("/"));
    if (folder && !await this.exists(folder)) {
      await this.ensureFolder(folder);
    }
    await this.app.vault.adapter.write(path10, content);
  }
  async append(path10, content) {
    const folder = path10.substring(0, path10.lastIndexOf("/"));
    if (folder && !await this.exists(folder)) {
      await this.ensureFolder(folder);
    }
    if (await this.exists(path10)) {
      const existing = await this.read(path10);
      await this.app.vault.adapter.write(path10, existing + content);
    } else {
      await this.app.vault.adapter.write(path10, content);
    }
  }
  async delete(path10) {
    if (await this.exists(path10)) {
      await this.app.vault.adapter.remove(path10);
    }
  }
  async listFiles(folder) {
    if (!await this.exists(folder)) {
      return [];
    }
    const listing = await this.app.vault.adapter.list(folder);
    return listing.files;
  }
  /** List subfolders in a folder. Returns relative paths from the folder. */
  async listFolders(folder) {
    if (!await this.exists(folder)) {
      return [];
    }
    const listing = await this.app.vault.adapter.list(folder);
    return listing.folders;
  }
  /** Recursively list all files in a folder and subfolders. */
  async listFilesRecursive(folder) {
    const allFiles = [];
    const processFolder = async (currentFolder) => {
      if (!await this.exists(currentFolder)) return;
      const listing = await this.app.vault.adapter.list(currentFolder);
      allFiles.push(...listing.files);
      for (const subfolder of listing.folders) {
        await processFolder(subfolder);
      }
    };
    await processFolder(folder);
    return allFiles;
  }
  /** Ensure a folder exists, creating it and parent folders if needed. */
  async ensureFolder(path10) {
    if (await this.exists(path10)) return;
    const parts = path10.split("/").filter(Boolean);
    let current = "";
    for (const part of parts) {
      current = current ? `${current}/${part}` : part;
      if (!await this.exists(current)) {
        await this.app.vault.adapter.mkdir(current);
      }
    }
  }
  /** Rename/move a file. */
  async rename(oldPath, newPath) {
    await this.app.vault.adapter.rename(oldPath, newPath);
  }
  async stat(path10) {
    try {
      const stat = await this.app.vault.adapter.stat(path10);
      if (!stat) return null;
      return { mtime: stat.mtime, size: stat.size };
    } catch (e2) {
      return null;
    }
  }
};

// src/core/storage/StorageService.ts
var CLAUDE_PATH = ".claude";
var StorageService = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.app = plugin.app;
    this.adapter = new VaultFileAdapter(this.app);
    this.ccSettings = new CCSettingsStorage(this.adapter);
    this.claudianSettings = new ClaudianSettingsStorage(this.adapter);
    this.commands = new SlashCommandStorage(this.adapter);
    this.sessions = new SessionStorage(this.adapter);
    this.mcp = new McpStorage(this.adapter);
  }
  async initialize() {
    await this.ensureDirectories();
    await this.runMigrations();
    const cc = await this.ccSettings.load();
    const claudian = await this.claudianSettings.load();
    return { cc, claudian };
  }
  async runMigrations() {
    const ccExists = await this.ccSettings.exists();
    const claudianExists = await this.claudianSettings.exists();
    const dataJson = await this.loadDataJson();
    if (ccExists && !claudianExists) {
      await this.migrateFromOldSettingsJson();
    }
    if (dataJson) {
      const hasState = this.hasStateToMigrate(dataJson);
      const hasLegacyContent = this.hasLegacyContentToMigrate(dataJson);
      if (hasState) {
        await this.migrateFromDataJson(dataJson);
      }
      let legacyContentHadErrors = false;
      if (hasLegacyContent) {
        const result = await this.migrateLegacyDataJsonContent(dataJson);
        legacyContentHadErrors = result.hadErrors;
      }
      if ((hasState || hasLegacyContent) && !legacyContentHadErrors) {
        await this.clearLegacyDataJson();
      }
    }
  }
  hasStateToMigrate(data) {
    return data.lastEnvHash !== void 0 || data.lastClaudeModel !== void 0 || data.lastCustomModel !== void 0;
  }
  hasLegacyContentToMigrate(data) {
    var _a, _b, _c, _d;
    return ((_b = (_a = data.slashCommands) == null ? void 0 : _a.length) != null ? _b : 0) > 0 || ((_d = (_c = data.conversations) == null ? void 0 : _c.length) != null ? _d : 0) > 0;
  }
  /**
   * Migrate from old settings.json (with Claudian fields) to split format.
   *
   * Handles:
   * - Legacy Claudian fields (userName, model, etc.)  claudian-settings.json
   * - Legacy permissions array  CC permissions object
   * - CC env object  Claudian environmentVariables string
   * - Preserves existing CC permissions if already in CC format
   */
  async migrateFromOldSettingsJson() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q2, _r, _s;
    const content = await this.adapter.read(CC_SETTINGS_PATH);
    const oldSettings = JSON.parse(content);
    const hasClaudianFields = Array.from(CLAUDIAN_ONLY_FIELDS).some(
      (field) => oldSettings[field] !== void 0
    );
    if (!hasClaudianFields) {
      return;
    }
    let environmentVariables = (_a = oldSettings.environmentVariables) != null ? _a : "";
    if (oldSettings.env && typeof oldSettings.env === "object") {
      const envFromCC = convertEnvObjectToString(oldSettings.env);
      if (envFromCC) {
        environmentVariables = mergeEnvironmentVariables(environmentVariables, envFromCC);
      }
    }
    const claudianFields = {
      userName: (_b = oldSettings.userName) != null ? _b : DEFAULT_SETTINGS.userName,
      enableBlocklist: (_c = oldSettings.enableBlocklist) != null ? _c : DEFAULT_SETTINGS.enableBlocklist,
      blockedCommands: normalizeBlockedCommands(oldSettings.blockedCommands),
      model: (_d = oldSettings.model) != null ? _d : DEFAULT_SETTINGS.model,
      thinkingBudget: (_e = oldSettings.thinkingBudget) != null ? _e : DEFAULT_SETTINGS.thinkingBudget,
      permissionMode: (_f = oldSettings.permissionMode) != null ? _f : DEFAULT_SETTINGS.permissionMode,
      excludedTags: (_g = oldSettings.excludedTags) != null ? _g : DEFAULT_SETTINGS.excludedTags,
      mediaFolder: (_h = oldSettings.mediaFolder) != null ? _h : DEFAULT_SETTINGS.mediaFolder,
      environmentVariables,
      // Merged from both sources
      envSnippets: (_i = oldSettings.envSnippets) != null ? _i : DEFAULT_SETTINGS.envSnippets,
      systemPrompt: (_j = oldSettings.systemPrompt) != null ? _j : DEFAULT_SETTINGS.systemPrompt,
      allowedExportPaths: (_k = oldSettings.allowedExportPaths) != null ? _k : DEFAULT_SETTINGS.allowedExportPaths,
      persistentExternalContextPaths: DEFAULT_SETTINGS.persistentExternalContextPaths,
      keyboardNavigation: (_l = oldSettings.keyboardNavigation) != null ? _l : DEFAULT_SETTINGS.keyboardNavigation,
      claudeCliPath: (_m = oldSettings.claudeCliPath) != null ? _m : DEFAULT_SETTINGS.claudeCliPath,
      claudeCliPathsByHost: DEFAULT_SETTINGS.claudeCliPathsByHost,
      // Migration to hostname-based handled in main.ts
      loadUserClaudeSettings: (_n = oldSettings.loadUserClaudeSettings) != null ? _n : DEFAULT_SETTINGS.loadUserClaudeSettings,
      enableAutoTitleGeneration: (_o = oldSettings.enableAutoTitleGeneration) != null ? _o : DEFAULT_SETTINGS.enableAutoTitleGeneration,
      titleGenerationModel: (_p = oldSettings.titleGenerationModel) != null ? _p : DEFAULT_SETTINGS.titleGenerationModel,
      lastClaudeModel: DEFAULT_SETTINGS.lastClaudeModel,
      lastCustomModel: DEFAULT_SETTINGS.lastCustomModel,
      lastEnvHash: DEFAULT_SETTINGS.lastEnvHash
    };
    await this.claudianSettings.save(claudianFields);
    const savedClaudian = await this.claudianSettings.load();
    if (!savedClaudian || savedClaudian.userName === void 0) {
      throw new Error("Failed to verify claudian-settings.json was saved correctly");
    }
    let ccPermissions;
    if (isLegacyPermissionsFormat(oldSettings)) {
      ccPermissions = legacyPermissionsToCCPermissions(oldSettings.permissions);
    } else if (oldSettings.permissions && typeof oldSettings.permissions === "object" && !Array.isArray(oldSettings.permissions)) {
      const existingPerms = oldSettings.permissions;
      ccPermissions = {
        allow: (_q2 = existingPerms.allow) != null ? _q2 : [],
        deny: (_r = existingPerms.deny) != null ? _r : [],
        ask: (_s = existingPerms.ask) != null ? _s : [],
        defaultMode: existingPerms.defaultMode,
        additionalDirectories: existingPerms.additionalDirectories
      };
    } else {
      ccPermissions = { ...DEFAULT_CC_PERMISSIONS };
    }
    const ccSettings = {
      $schema: "https://json.schemastore.org/claude-code-settings.json",
      permissions: ccPermissions
    };
    await this.ccSettings.save(ccSettings, true);
  }
  async migrateFromDataJson(dataJson) {
    const claudian = await this.claudianSettings.load();
    if (dataJson.lastEnvHash !== void 0 && !claudian.lastEnvHash) {
      claudian.lastEnvHash = dataJson.lastEnvHash;
    }
    if (dataJson.lastClaudeModel !== void 0 && !claudian.lastClaudeModel) {
      claudian.lastClaudeModel = dataJson.lastClaudeModel;
    }
    if (dataJson.lastCustomModel !== void 0 && !claudian.lastCustomModel) {
      claudian.lastCustomModel = dataJson.lastCustomModel;
    }
    await this.claudianSettings.save(claudian);
  }
  async migrateLegacyDataJsonContent(dataJson) {
    let hadErrors = false;
    if (dataJson.slashCommands && dataJson.slashCommands.length > 0) {
      for (const command of dataJson.slashCommands) {
        try {
          const filePath = this.commands.getFilePath(command);
          if (await this.adapter.exists(filePath)) {
            continue;
          }
          await this.commands.save(command);
        } catch (e2) {
          hadErrors = true;
        }
      }
    }
    if (dataJson.conversations && dataJson.conversations.length > 0) {
      for (const conversation of dataJson.conversations) {
        try {
          const filePath = this.sessions.getFilePath(conversation.id);
          if (await this.adapter.exists(filePath)) {
            continue;
          }
          await this.sessions.saveConversation(conversation);
        } catch (e2) {
          hadErrors = true;
        }
      }
    }
    return { hadErrors };
  }
  async clearLegacyDataJson() {
    const dataJson = await this.loadDataJson();
    if (!dataJson) {
      return;
    }
    const cleaned = { ...dataJson };
    delete cleaned.lastEnvHash;
    delete cleaned.lastClaudeModel;
    delete cleaned.lastCustomModel;
    delete cleaned.conversations;
    delete cleaned.slashCommands;
    delete cleaned.migrationVersion;
    if (Object.keys(cleaned).length === 0) {
      await this.plugin.saveData({});
      return;
    }
    await this.plugin.saveData(cleaned);
  }
  async loadDataJson() {
    try {
      const data = await this.plugin.loadData();
      return data || null;
    } catch (e2) {
      return null;
    }
  }
  async ensureDirectories() {
    await this.adapter.ensureFolder(CLAUDE_PATH);
    await this.adapter.ensureFolder(COMMANDS_PATH);
    await this.adapter.ensureFolder(SESSIONS_PATH);
  }
  getAdapter() {
    return this.adapter;
  }
  // ============================================================================
  // Convenience methods for common operations
  // ============================================================================
  async getPermissions() {
    return this.ccSettings.getPermissions();
  }
  async updatePermissions(permissions) {
    return this.ccSettings.updatePermissions(permissions);
  }
  async addAllowRule(rule) {
    return this.ccSettings.addAllowRule(createPermissionRule(rule));
  }
  async addDenyRule(rule) {
    return this.ccSettings.addDenyRule(createPermissionRule(rule));
  }
  /**
   * Remove a permission rule from all lists.
   */
  async removePermissionRule(rule) {
    return this.ccSettings.removeRule(createPermissionRule(rule));
  }
  async updateClaudianSettings(updates) {
    return this.claudianSettings.update(updates);
  }
  async saveClaudianSettings(settings11) {
    return this.claudianSettings.save(settings11);
  }
  async loadClaudianSettings() {
    return this.claudianSettings.load();
  }
  /**
   * Get legacy activeConversationId from storage (claudian-settings.json or data.json).
   */
  async getLegacyActiveConversationId() {
    const fromSettings = await this.claudianSettings.getLegacyActiveConversationId();
    if (fromSettings) {
      return fromSettings;
    }
    const dataJson = await this.loadDataJson();
    if (dataJson && typeof dataJson.activeConversationId === "string") {
      return dataJson.activeConversationId;
    }
    return null;
  }
  /**
   * Remove legacy activeConversationId from storage after migration.
   */
  async clearLegacyActiveConversationId() {
    await this.claudianSettings.clearLegacyActiveConversationId();
    const dataJson = await this.loadDataJson();
    if (!dataJson || !("activeConversationId" in dataJson)) {
      return;
    }
    const cleaned = { ...dataJson };
    delete cleaned.activeConversationId;
    await this.plugin.saveData(cleaned);
  }
  // ============================================================================
  // Tab Manager State Persistence
  // ============================================================================
  /**
   * Get tab manager state from data.json with runtime validation.
   */
  async getTabManagerState() {
    try {
      const data = await this.plugin.loadData();
      if (data == null ? void 0 : data.tabManagerState) {
        return this.validateTabManagerState(data.tabManagerState);
      }
      return null;
    } catch (e2) {
      return null;
    }
  }
  /**
   * Validates and sanitizes tab manager state from storage.
   * Returns null if the data is invalid or corrupted.
   */
  validateTabManagerState(data) {
    if (!data || typeof data !== "object") {
      return null;
    }
    const state = data;
    if (!Array.isArray(state.openTabs)) {
      return null;
    }
    const validatedTabs = [];
    for (const tab of state.openTabs) {
      if (!tab || typeof tab !== "object") {
        continue;
      }
      const tabObj = tab;
      if (typeof tabObj.tabId !== "string") {
        continue;
      }
      validatedTabs.push({
        tabId: tabObj.tabId,
        conversationId: typeof tabObj.conversationId === "string" ? tabObj.conversationId : null
      });
    }
    const activeTabId = typeof state.activeTabId === "string" ? state.activeTabId : null;
    return {
      openTabs: validatedTabs,
      activeTabId
    };
  }
  async setTabManagerState(state) {
    try {
      const data = await this.plugin.loadData() || {};
      data.tabManagerState = state;
      await this.plugin.saveData(data);
    } catch (e2) {
    }
  }
};

// src/features/chat/ClaudianView.ts
var import_obsidian20 = require("obsidian");

// src/features/chat/constants.ts
var LOGO_SVG = {
  viewBox: "0 -.01 39.5 39.53",
  width: "18",
  height: "18",
  path: "m7.75 26.27 7.77-4.36.13-.38-.13-.21h-.38l-1.3-.08-4.44-.12-3.85-.16-3.73-.2-.94-.2-.88-1.16.09-.58.79-.53 1.13.1 2.5.17 3.75.26 2.72.16 4.03.42h.64l.09-.26-.22-.16-.17-.16-3.88-2.63-4.2-2.78-2.2-1.6-1.19-.81-.6-.76-.26-1.66 1.08-1.19 1.45.1.37.1 1.47 1.13 3.14 2.43 4.1 3.02.6.5.24-.17.03-.12-.27-.45-2.23-4.03-2.38-4.1-1.06-1.7-.28-1.02c-.1-.42-.17-.77-.17-1.2l1.23-1.67.68-.22 1.64.22.69.6 1.02 2.33 1.65 3.67 2.56 4.99.75 1.48.4 1.37.15.42h.26v-.24l.21-2.81.39-3.45.38-4.44.13-1.25.62-1.5 1.23-.81.96.46.79 1.13-.11.73-.47 3.05-.92 4.78-.6 3.2h.35l.4-.4 1.62-2.15 2.72-3.4 1.2-1.35 1.4-1.49.9-.71h1.7l1.25 1.86-.56 1.92-1.75 2.22-1.45 1.88-2.08 2.8-1.3 2.24.12.18.31-.03 4.7-1 2.54-.46 3.03-.52 1.37.64.15.65-.54 1.33-3.24.8-3.8.76-5.66 1.34-.07.05.08.1 2.55.24 1.09.06h2.67l4.97.37 1.3.86.78 1.05-.13.8-2 1.02-2.7-.64-6.3-1.5-2.16-.54h-.3v.18l1.8 1.76 3.3 2.98 4.13 3.84.21.95-.53.75-.56-.08-3.63-2.73-1.4-1.23-3.17-2.67h-.21v.28l.73 1.07 3.86 5.8.2 1.78-.28.58-1 .35-1.1-.2-2.26-3.17-2.33-3.57-1.88-3.2-.23.13-1.11 11.95-.52.61-1.2.46-1-.76-.53-1.23.53-2.43.64-3.17.52-2.52.47-3.13.28-1.04-.02-.07-.23.03-2.36 3.24-3.59 4.85-2.84 3.04-.68.27-1.18-.61.11-1.09.66-.97 3.93-5 2.37-3.1 1.53-1.79-.01-.26h-.09l-10.44 6.78-1.86.24-.8-.75.1-1.23.38-.4 3.14-2.16z",
  fill: "#d97757"
};
var COMPLETION_FLAVOR_WORDS = [
  "Baked",
  "Cooked",
  "Crunched",
  "Brewed",
  "Crafted",
  "Forged",
  "Conjured",
  "Whipped up",
  "Stirred",
  "Simmered",
  "Toasted",
  "Saut\xE9ed",
  "Finagled",
  "Marinated",
  "Distilled",
  "Fermented",
  "Percolated",
  "Steeped",
  "Roasted",
  "Cured",
  "Smoked"
];
var FLAVOR_TEXTS = [
  // Classic
  "Thinking...",
  "Pondering...",
  "Processing...",
  "Analyzing...",
  "Considering...",
  "Working on it...",
  "One moment...",
  "On it...",
  // Thoughtful
  "Ruminating...",
  "Contemplating...",
  "Reflecting...",
  "Mulling it over...",
  "Let me think...",
  "Hmm...",
  "Cogitating...",
  "Deliberating...",
  "Weighing options...",
  "Gathering thoughts...",
  // Playful
  "Brewing ideas...",
  "Connecting dots...",
  "Assembling thoughts...",
  "Spinning up neurons...",
  "Loading brilliance...",
  "Consulting the oracle...",
  "Summoning knowledge...",
  "Crunching thoughts...",
  "Dusting off neurons...",
  "Wrangling ideas...",
  "Herding thoughts...",
  "Juggling concepts...",
  "Untangling this...",
  "Piecing it together...",
  // Cozy
  "Sipping coffee...",
  "Warming up...",
  "Getting cozy with this...",
  "Settling in...",
  "Making tea...",
  "Grabbing a snack...",
  // Technical
  "Parsing...",
  "Compiling thoughts...",
  "Running inference...",
  "Querying the void...",
  "Defragmenting brain...",
  "Allocating memory...",
  "Optimizing...",
  "Indexing...",
  "Syncing neurons...",
  // Zen
  "Breathing...",
  "Finding clarity...",
  "Channeling focus...",
  "Centering...",
  "Aligning chakras...",
  "Meditating on this...",
  // Whimsical
  "Asking the stars...",
  "Reading tea leaves...",
  "Shaking the magic 8-ball...",
  "Consulting ancient scrolls...",
  "Decoding the matrix...",
  "Communing with the ether...",
  "Peering into the abyss...",
  "Channeling the cosmos...",
  // Action
  "Diving in...",
  "Rolling up sleeves...",
  "Getting to work...",
  "Tackling this...",
  "On the case...",
  "Investigating...",
  "Exploring...",
  "Digging deeper...",
  // Casual
  "Bear with me...",
  "Hang tight...",
  "Just a sec...",
  "Working my magic...",
  "Almost there...",
  "Give me a moment..."
];

// node_modules/@anthropic-ai/claude-agent-sdk/sdk.mjs
var import_path3 = require("path");
var import_url = require("url");
var import_events = require("events");
var import_child_process2 = require("child_process");
var import_readline = require("readline");
var f = __toESM(require("fs"), 1);
var import_promises = require("fs/promises");
var import_path4 = require("path");
var import_os = require("os");
var import_path5 = require("path");
var import_process = require("process");
var import_fs = require("fs");
var import_crypto = require("crypto");
var import_crypto2 = require("crypto");
var import_fs2 = require("fs");
var import_path6 = require("path");
var import_crypto3 = require("crypto");
var import_path7 = require("path");
var import_url2 = require("url");
var import_meta = {};
var XK = Object.create;
var { getPrototypeOf: QK, defineProperty: Y8, getOwnPropertyNames: $K } = Object;
var YK = Object.prototype.hasOwnProperty;
var K7 = (X, Q, $) => {
  $ = X != null ? XK(QK(X)) : {};
  let Y = Q || !X || !X.__esModule ? Y8($, "default", { value: X, enumerable: true }) : $;
  for (let W of $K(X)) if (!YK.call(Y, W)) Y8(Y, W, { get: () => X[W], enumerable: true });
  return Y;
};
var P = (X, Q) => () => (Q || X((Q = { exports: {} }).exports, Q), Q.exports);
var U7 = (X, Q) => {
  for (var $ in Q) Y8(X, $, { get: Q[$], enumerable: true, configurable: true, set: (Y) => Q[$] = () => Y });
};
var fX = P((YG) => {
  Object.defineProperty(YG, "__esModule", { value: true });
  YG.regexpCode = YG.getEsmExportName = YG.getProperty = YG.safeStringify = YG.stringify = YG.strConcat = YG.addCodeArg = YG.str = YG._ = YG.nil = YG._Code = YG.Name = YG.IDENTIFIER = YG._CodeOrName = void 0;
  class D9 {
  }
  YG._CodeOrName = D9;
  YG.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class h6 extends D9 {
    constructor(X) {
      super();
      if (!YG.IDENTIFIER.test(X)) throw Error("CodeGen: name must be a valid identifier");
      this.str = X;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return false;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  YG.Name = h6;
  class s0 extends D9 {
    constructor(X) {
      super();
      this._items = typeof X === "string" ? [X] : X;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1) return false;
      let X = this._items[0];
      return X === "" || X === '""';
    }
    get str() {
      var X;
      return (X = this._str) !== null && X !== void 0 ? X : this._str = this._items.reduce((Q, $) => `${Q}${$}`, "");
    }
    get names() {
      var X;
      return (X = this._names) !== null && X !== void 0 ? X : this._names = this._items.reduce((Q, $) => {
        if ($ instanceof h6) Q[$.str] = (Q[$.str] || 0) + 1;
        return Q;
      }, {});
    }
  }
  YG._Code = s0;
  YG.nil = new s0("");
  function QG(X, ...Q) {
    let $ = [X[0]], Y = 0;
    while (Y < Q.length) s$($, Q[Y]), $.push(X[++Y]);
    return new s0($);
  }
  YG._ = QG;
  var a$ = new s0("+");
  function $G(X, ...Q) {
    let $ = [hX(X[0])], Y = 0;
    while (Y < Q.length) $.push(a$), s$($, Q[Y]), $.push(a$, hX(X[++Y]));
    return BN($), new s0($);
  }
  YG.str = $G;
  function s$(X, Q) {
    if (Q instanceof s0) X.push(...Q._items);
    else if (Q instanceof h6) X.push(Q);
    else X.push(UN(Q));
  }
  YG.addCodeArg = s$;
  function BN(X) {
    let Q = 1;
    while (Q < X.length - 1) {
      if (X[Q] === a$) {
        let $ = zN(X[Q - 1], X[Q + 1]);
        if ($ !== void 0) {
          X.splice(Q - 1, 3, $);
          continue;
        }
        X[Q++] = "+";
      }
      Q++;
    }
  }
  function zN(X, Q) {
    if (Q === '""') return X;
    if (X === '""') return Q;
    if (typeof X == "string") {
      if (Q instanceof h6 || X[X.length - 1] !== '"') return;
      if (typeof Q != "string") return `${X.slice(0, -1)}${Q}"`;
      if (Q[0] === '"') return X.slice(0, -1) + Q.slice(1);
      return;
    }
    if (typeof Q == "string" && Q[0] === '"' && !(X instanceof h6)) return `"${X}${Q.slice(1)}`;
    return;
  }
  function KN(X, Q) {
    return Q.emptyStr() ? X : X.emptyStr() ? Q : $G`${X}${Q}`;
  }
  YG.strConcat = KN;
  function UN(X) {
    return typeof X == "number" || typeof X == "boolean" || X === null ? X : hX(Array.isArray(X) ? X.join(",") : X);
  }
  function VN(X) {
    return new s0(hX(X));
  }
  YG.stringify = VN;
  function hX(X) {
    return JSON.stringify(X).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  YG.safeStringify = hX;
  function LN(X) {
    return typeof X == "string" && YG.IDENTIFIER.test(X) ? new s0(`.${X}`) : QG`[${X}]`;
  }
  YG.getProperty = LN;
  function qN(X) {
    if (typeof X == "string" && YG.IDENTIFIER.test(X)) return new s0(`${X}`);
    throw Error(`CodeGen: invalid export name: ${X}, use explicit $id name mapping`);
  }
  YG.getEsmExportName = qN;
  function FN(X) {
    return new s0(X.toString());
  }
  YG.regexpCode = FN;
});
var $Y = P((HG) => {
  Object.defineProperty(HG, "__esModule", { value: true });
  HG.ValueScope = HG.ValueScopeName = HG.Scope = HG.varKinds = HG.UsedValueState = void 0;
  var x0 = fX();
  class JG extends Error {
    constructor(X) {
      super(`CodeGen: "code" for ${X} not defined`);
      this.value = X.value;
    }
  }
  var w9;
  (function(X) {
    X[X.Started = 0] = "Started", X[X.Completed = 1] = "Completed";
  })(w9 || (HG.UsedValueState = w9 = {}));
  HG.varKinds = { const: new x0.Name("const"), let: new x0.Name("let"), var: new x0.Name("var") };
  class XY {
    constructor({ prefixes: X, parent: Q } = {}) {
      this._names = {}, this._prefixes = X, this._parent = Q;
    }
    toName(X) {
      return X instanceof x0.Name ? X : this.name(X);
    }
    name(X) {
      return new x0.Name(this._newName(X));
    }
    _newName(X) {
      let Q = this._names[X] || this._nameGroup(X);
      return `${X}${Q.index++}`;
    }
    _nameGroup(X) {
      var Q, $;
      if ((($ = (Q = this._parent) === null || Q === void 0 ? void 0 : Q._prefixes) === null || $ === void 0 ? void 0 : $.has(X)) || this._prefixes && !this._prefixes.has(X)) throw Error(`CodeGen: prefix "${X}" is not allowed in this scope`);
      return this._names[X] = { prefix: X, index: 0 };
    }
  }
  HG.Scope = XY;
  class QY extends x0.Name {
    constructor(X, Q) {
      super(Q);
      this.prefix = X;
    }
    setValue(X, { property: Q, itemIndex: $ }) {
      this.value = X, this.scopePath = x0._`.${new x0.Name(Q)}[${$}]`;
    }
  }
  HG.ValueScopeName = QY;
  var SN = x0._`\n`;
  class GG extends XY {
    constructor(X) {
      super(X);
      this._values = {}, this._scope = X.scope, this.opts = { ...X, _n: X.lines ? SN : x0.nil };
    }
    get() {
      return this._scope;
    }
    name(X) {
      return new QY(X, this._newName(X));
    }
    value(X, Q) {
      var $;
      if (Q.ref === void 0) throw Error("CodeGen: ref must be passed in value");
      let Y = this.toName(X), { prefix: W } = Y, J = ($ = Q.key) !== null && $ !== void 0 ? $ : Q.ref, G = this._values[W];
      if (G) {
        let z = G.get(J);
        if (z) return z;
      } else G = this._values[W] = /* @__PURE__ */ new Map();
      G.set(J, Y);
      let H = this._scope[W] || (this._scope[W] = []), B = H.length;
      return H[B] = Q.ref, Y.setValue(Q, { property: W, itemIndex: B }), Y;
    }
    getValue(X, Q) {
      let $ = this._values[X];
      if (!$) return;
      return $.get(Q);
    }
    scopeRefs(X, Q = this._values) {
      return this._reduceValues(Q, ($) => {
        if ($.scopePath === void 0) throw Error(`CodeGen: name "${$}" has no value`);
        return x0._`${X}${$.scopePath}`;
      });
    }
    scopeCode(X = this._values, Q, $) {
      return this._reduceValues(X, (Y) => {
        if (Y.value === void 0) throw Error(`CodeGen: name "${Y}" has no value`);
        return Y.value.code;
      }, Q, $);
    }
    _reduceValues(X, Q, $ = {}, Y) {
      let W = x0.nil;
      for (let J in X) {
        let G = X[J];
        if (!G) continue;
        let H = $[J] = $[J] || /* @__PURE__ */ new Map();
        G.forEach((B) => {
          if (H.has(B)) return;
          H.set(B, w9.Started);
          let z = Q(B);
          if (z) {
            let K = this.opts.es5 ? HG.varKinds.var : HG.varKinds.const;
            W = x0._`${W}${K} ${B} = ${z};${this.opts._n}`;
          } else if (z = Y === null || Y === void 0 ? void 0 : Y(B)) W = x0._`${W}${z}${this.opts._n}`;
          else throw new JG(B);
          H.set(B, w9.Completed);
        });
      }
      return W;
    }
  }
  HG.ValueScope = GG;
});
var c = P((y0) => {
  Object.defineProperty(y0, "__esModule", { value: true });
  y0.or = y0.and = y0.not = y0.CodeGen = y0.operators = y0.varKinds = y0.ValueScopeName = y0.ValueScope = y0.Scope = y0.Name = y0.regexpCode = y0.stringify = y0.getProperty = y0.nil = y0.strConcat = y0.str = y0._ = void 0;
  var t2 = fX(), e0 = $Y(), u1 = fX();
  Object.defineProperty(y0, "_", { enumerable: true, get: function() {
    return u1._;
  } });
  Object.defineProperty(y0, "str", { enumerable: true, get: function() {
    return u1.str;
  } });
  Object.defineProperty(y0, "strConcat", { enumerable: true, get: function() {
    return u1.strConcat;
  } });
  Object.defineProperty(y0, "nil", { enumerable: true, get: function() {
    return u1.nil;
  } });
  Object.defineProperty(y0, "getProperty", { enumerable: true, get: function() {
    return u1.getProperty;
  } });
  Object.defineProperty(y0, "stringify", { enumerable: true, get: function() {
    return u1.stringify;
  } });
  Object.defineProperty(y0, "regexpCode", { enumerable: true, get: function() {
    return u1.regexpCode;
  } });
  Object.defineProperty(y0, "Name", { enumerable: true, get: function() {
    return u1.Name;
  } });
  var b9 = $Y();
  Object.defineProperty(y0, "Scope", { enumerable: true, get: function() {
    return b9.Scope;
  } });
  Object.defineProperty(y0, "ValueScope", { enumerable: true, get: function() {
    return b9.ValueScope;
  } });
  Object.defineProperty(y0, "ValueScopeName", { enumerable: true, get: function() {
    return b9.ValueScopeName;
  } });
  Object.defineProperty(y0, "varKinds", { enumerable: true, get: function() {
    return b9.varKinds;
  } });
  y0.operators = { GT: new t2._Code(">"), GTE: new t2._Code(">="), LT: new t2._Code("<"), LTE: new t2._Code("<="), EQ: new t2._Code("==="), NEQ: new t2._Code("!=="), NOT: new t2._Code("!"), OR: new t2._Code("||"), AND: new t2._Code("&&"), ADD: new t2._Code("+") };
  class l1 {
    optimizeNodes() {
      return this;
    }
    optimizeNames(X, Q) {
      return this;
    }
  }
  class zG extends l1 {
    constructor(X, Q, $) {
      super();
      this.varKind = X, this.name = Q, this.rhs = $;
    }
    render({ es5: X, _n: Q }) {
      let $ = X ? e0.varKinds.var : this.varKind, Y = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${$} ${this.name}${Y};` + Q;
    }
    optimizeNames(X, Q) {
      if (!X[this.name.str]) return;
      if (this.rhs) this.rhs = u6(this.rhs, X, Q);
      return this;
    }
    get names() {
      return this.rhs instanceof t2._CodeOrName ? this.rhs.names : {};
    }
  }
  class JY extends l1 {
    constructor(X, Q, $) {
      super();
      this.lhs = X, this.rhs = Q, this.sideEffects = $;
    }
    render({ _n: X }) {
      return `${this.lhs} = ${this.rhs};` + X;
    }
    optimizeNames(X, Q) {
      if (this.lhs instanceof t2.Name && !X[this.lhs.str] && !this.sideEffects) return;
      return this.rhs = u6(this.rhs, X, Q), this;
    }
    get names() {
      let X = this.lhs instanceof t2.Name ? {} : { ...this.lhs.names };
      return I9(X, this.rhs);
    }
  }
  class KG extends JY {
    constructor(X, Q, $, Y) {
      super(X, $, Y);
      this.op = Q;
    }
    render({ _n: X }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + X;
    }
  }
  class UG extends l1 {
    constructor(X) {
      super();
      this.label = X, this.names = {};
    }
    render({ _n: X }) {
      return `${this.label}:` + X;
    }
  }
  class VG extends l1 {
    constructor(X) {
      super();
      this.label = X, this.names = {};
    }
    render({ _n: X }) {
      return `break${this.label ? ` ${this.label}` : ""};` + X;
    }
  }
  class LG extends l1 {
    constructor(X) {
      super();
      this.error = X;
    }
    render({ _n: X }) {
      return `throw ${this.error};` + X;
    }
    get names() {
      return this.error.names;
    }
  }
  class qG extends l1 {
    constructor(X) {
      super();
      this.code = X;
    }
    render({ _n: X }) {
      return `${this.code};` + X;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(X, Q) {
      return this.code = u6(this.code, X, Q), this;
    }
    get names() {
      return this.code instanceof t2._CodeOrName ? this.code.names : {};
    }
  }
  class P9 extends l1 {
    constructor(X = []) {
      super();
      this.nodes = X;
    }
    render(X) {
      return this.nodes.reduce((Q, $) => Q + $.render(X), "");
    }
    optimizeNodes() {
      let { nodes: X } = this, Q = X.length;
      while (Q--) {
        let $ = X[Q].optimizeNodes();
        if (Array.isArray($)) X.splice(Q, 1, ...$);
        else if ($) X[Q] = $;
        else X.splice(Q, 1);
      }
      return X.length > 0 ? this : void 0;
    }
    optimizeNames(X, Q) {
      let { nodes: $ } = this, Y = $.length;
      while (Y--) {
        let W = $[Y];
        if (W.optimizeNames(X, Q)) continue;
        vN(X, W.names), $.splice(Y, 1);
      }
      return $.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((X, Q) => J6(X, Q.names), {});
    }
  }
  class m1 extends P9 {
    render(X) {
      return "{" + X._n + super.render(X) + "}" + X._n;
    }
  }
  class FG extends P9 {
  }
  class uX extends m1 {
  }
  uX.kind = "else";
  class j1 extends m1 {
    constructor(X, Q) {
      super(Q);
      this.condition = X;
    }
    render(X) {
      let Q = `if(${this.condition})` + super.render(X);
      if (this.else) Q += "else " + this.else.render(X);
      return Q;
    }
    optimizeNodes() {
      super.optimizeNodes();
      let X = this.condition;
      if (X === true) return this.nodes;
      let Q = this.else;
      if (Q) {
        let $ = Q.optimizeNodes();
        Q = this.else = Array.isArray($) ? new uX($) : $;
      }
      if (Q) {
        if (X === false) return Q instanceof j1 ? Q : Q.nodes;
        if (this.nodes.length) return this;
        return new j1(wG(X), Q instanceof j1 ? [Q] : Q.nodes);
      }
      if (X === false || !this.nodes.length) return;
      return this;
    }
    optimizeNames(X, Q) {
      var $;
      if (this.else = ($ = this.else) === null || $ === void 0 ? void 0 : $.optimizeNames(X, Q), !(super.optimizeNames(X, Q) || this.else)) return;
      return this.condition = u6(this.condition, X, Q), this;
    }
    get names() {
      let X = super.names;
      if (I9(X, this.condition), this.else) J6(X, this.else.names);
      return X;
    }
  }
  j1.kind = "if";
  class f6 extends m1 {
  }
  f6.kind = "for";
  class NG extends f6 {
    constructor(X) {
      super();
      this.iteration = X;
    }
    render(X) {
      return `for(${this.iteration})` + super.render(X);
    }
    optimizeNames(X, Q) {
      if (!super.optimizeNames(X, Q)) return;
      return this.iteration = u6(this.iteration, X, Q), this;
    }
    get names() {
      return J6(super.names, this.iteration.names);
    }
  }
  class OG extends f6 {
    constructor(X, Q, $, Y) {
      super();
      this.varKind = X, this.name = Q, this.from = $, this.to = Y;
    }
    render(X) {
      let Q = X.es5 ? e0.varKinds.var : this.varKind, { name: $, from: Y, to: W } = this;
      return `for(${Q} ${$}=${Y}; ${$}<${W}; ${$}++)` + super.render(X);
    }
    get names() {
      let X = I9(super.names, this.from);
      return I9(X, this.to);
    }
  }
  class YY extends f6 {
    constructor(X, Q, $, Y) {
      super();
      this.loop = X, this.varKind = Q, this.name = $, this.iterable = Y;
    }
    render(X) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(X);
    }
    optimizeNames(X, Q) {
      if (!super.optimizeNames(X, Q)) return;
      return this.iterable = u6(this.iterable, X, Q), this;
    }
    get names() {
      return J6(super.names, this.iterable.names);
    }
  }
  class M9 extends m1 {
    constructor(X, Q, $) {
      super();
      this.name = X, this.args = Q, this.async = $;
    }
    render(X) {
      return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(X);
    }
  }
  M9.kind = "func";
  class j9 extends P9 {
    render(X) {
      return "return " + super.render(X);
    }
  }
  j9.kind = "return";
  class DG extends m1 {
    render(X) {
      let Q = "try" + super.render(X);
      if (this.catch) Q += this.catch.render(X);
      if (this.finally) Q += this.finally.render(X);
      return Q;
    }
    optimizeNodes() {
      var X, Q;
      return super.optimizeNodes(), (X = this.catch) === null || X === void 0 || X.optimizeNodes(), (Q = this.finally) === null || Q === void 0 || Q.optimizeNodes(), this;
    }
    optimizeNames(X, Q) {
      var $, Y;
      return super.optimizeNames(X, Q), ($ = this.catch) === null || $ === void 0 || $.optimizeNames(X, Q), (Y = this.finally) === null || Y === void 0 || Y.optimizeNames(X, Q), this;
    }
    get names() {
      let X = super.names;
      if (this.catch) J6(X, this.catch.names);
      if (this.finally) J6(X, this.finally.names);
      return X;
    }
  }
  class R9 extends m1 {
    constructor(X) {
      super();
      this.error = X;
    }
    render(X) {
      return `catch(${this.error})` + super.render(X);
    }
  }
  R9.kind = "catch";
  class E9 extends m1 {
    render(X) {
      return "finally" + super.render(X);
    }
  }
  E9.kind = "finally";
  class AG {
    constructor(X, Q = {}) {
      this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...Q, _n: Q.lines ? `
` : "" }, this._extScope = X, this._scope = new e0.Scope({ parent: X }), this._nodes = [new FG()];
    }
    toString() {
      return this._root.render(this.opts);
    }
    name(X) {
      return this._scope.name(X);
    }
    scopeName(X) {
      return this._extScope.name(X);
    }
    scopeValue(X, Q) {
      let $ = this._extScope.value(X, Q);
      return (this._values[$.prefix] || (this._values[$.prefix] = /* @__PURE__ */ new Set())).add($), $;
    }
    getScopeValue(X, Q) {
      return this._extScope.getValue(X, Q);
    }
    scopeRefs(X) {
      return this._extScope.scopeRefs(X, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(X, Q, $, Y) {
      let W = this._scope.toName(Q);
      if ($ !== void 0 && Y) this._constants[W.str] = $;
      return this._leafNode(new zG(X, W, $)), W;
    }
    const(X, Q, $) {
      return this._def(e0.varKinds.const, X, Q, $);
    }
    let(X, Q, $) {
      return this._def(e0.varKinds.let, X, Q, $);
    }
    var(X, Q, $) {
      return this._def(e0.varKinds.var, X, Q, $);
    }
    assign(X, Q, $) {
      return this._leafNode(new JY(X, Q, $));
    }
    add(X, Q) {
      return this._leafNode(new KG(X, y0.operators.ADD, Q));
    }
    code(X) {
      if (typeof X == "function") X();
      else if (X !== t2.nil) this._leafNode(new qG(X));
      return this;
    }
    object(...X) {
      let Q = ["{"];
      for (let [$, Y] of X) {
        if (Q.length > 1) Q.push(",");
        if (Q.push($), $ !== Y || this.opts.es5) Q.push(":"), (0, t2.addCodeArg)(Q, Y);
      }
      return Q.push("}"), new t2._Code(Q);
    }
    if(X, Q, $) {
      if (this._blockNode(new j1(X)), Q && $) this.code(Q).else().code($).endIf();
      else if (Q) this.code(Q).endIf();
      else if ($) throw Error('CodeGen: "else" body without "then" body');
      return this;
    }
    elseIf(X) {
      return this._elseNode(new j1(X));
    }
    else() {
      return this._elseNode(new uX());
    }
    endIf() {
      return this._endBlockNode(j1, uX);
    }
    _for(X, Q) {
      if (this._blockNode(X), Q) this.code(Q).endFor();
      return this;
    }
    for(X, Q) {
      return this._for(new NG(X), Q);
    }
    forRange(X, Q, $, Y, W = this.opts.es5 ? e0.varKinds.var : e0.varKinds.let) {
      let J = this._scope.toName(X);
      return this._for(new OG(W, J, Q, $), () => Y(J));
    }
    forOf(X, Q, $, Y = e0.varKinds.const) {
      let W = this._scope.toName(X);
      if (this.opts.es5) {
        let J = Q instanceof t2.Name ? Q : this.var("_arr", Q);
        return this.forRange("_i", 0, t2._`${J}.length`, (G) => {
          this.var(W, t2._`${J}[${G}]`), $(W);
        });
      }
      return this._for(new YY("of", Y, W, Q), () => $(W));
    }
    forIn(X, Q, $, Y = this.opts.es5 ? e0.varKinds.var : e0.varKinds.const) {
      if (this.opts.ownProperties) return this.forOf(X, t2._`Object.keys(${Q})`, $);
      let W = this._scope.toName(X);
      return this._for(new YY("in", Y, W, Q), () => $(W));
    }
    endFor() {
      return this._endBlockNode(f6);
    }
    label(X) {
      return this._leafNode(new UG(X));
    }
    break(X) {
      return this._leafNode(new VG(X));
    }
    return(X) {
      let Q = new j9();
      if (this._blockNode(Q), this.code(X), Q.nodes.length !== 1) throw Error('CodeGen: "return" should have one node');
      return this._endBlockNode(j9);
    }
    try(X, Q, $) {
      if (!Q && !$) throw Error('CodeGen: "try" without "catch" and "finally"');
      let Y = new DG();
      if (this._blockNode(Y), this.code(X), Q) {
        let W = this.name("e");
        this._currNode = Y.catch = new R9(W), Q(W);
      }
      if ($) this._currNode = Y.finally = new E9(), this.code($);
      return this._endBlockNode(R9, E9);
    }
    throw(X) {
      return this._leafNode(new LG(X));
    }
    block(X, Q) {
      if (this._blockStarts.push(this._nodes.length), X) this.code(X).endBlock(Q);
      return this;
    }
    endBlock(X) {
      let Q = this._blockStarts.pop();
      if (Q === void 0) throw Error("CodeGen: not in self-balancing block");
      let $ = this._nodes.length - Q;
      if ($ < 0 || X !== void 0 && $ !== X) throw Error(`CodeGen: wrong number of nodes: ${$} vs ${X} expected`);
      return this._nodes.length = Q, this;
    }
    func(X, Q = t2.nil, $, Y) {
      if (this._blockNode(new M9(X, Q, $)), Y) this.code(Y).endFunc();
      return this;
    }
    endFunc() {
      return this._endBlockNode(M9);
    }
    optimize(X = 1) {
      while (X-- > 0) this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
    }
    _leafNode(X) {
      return this._currNode.nodes.push(X), this;
    }
    _blockNode(X) {
      this._currNode.nodes.push(X), this._nodes.push(X);
    }
    _endBlockNode(X, Q) {
      let $ = this._currNode;
      if ($ instanceof X || Q && $ instanceof Q) return this._nodes.pop(), this;
      throw Error(`CodeGen: not in block "${Q ? `${X.kind}/${Q.kind}` : X.kind}"`);
    }
    _elseNode(X) {
      let Q = this._currNode;
      if (!(Q instanceof j1)) throw Error('CodeGen: "else" without "if"');
      return this._currNode = Q.else = X, this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      let X = this._nodes;
      return X[X.length - 1];
    }
    set _currNode(X) {
      let Q = this._nodes;
      Q[Q.length - 1] = X;
    }
  }
  y0.CodeGen = AG;
  function J6(X, Q) {
    for (let $ in Q) X[$] = (X[$] || 0) + (Q[$] || 0);
    return X;
  }
  function I9(X, Q) {
    return Q instanceof t2._CodeOrName ? J6(X, Q.names) : X;
  }
  function u6(X, Q, $) {
    if (X instanceof t2.Name) return Y(X);
    if (!W(X)) return X;
    return new t2._Code(X._items.reduce((J, G) => {
      if (G instanceof t2.Name) G = Y(G);
      if (G instanceof t2._Code) J.push(...G._items);
      else J.push(G);
      return J;
    }, []));
    function Y(J) {
      let G = $[J.str];
      if (G === void 0 || Q[J.str] !== 1) return J;
      return delete Q[J.str], G;
    }
    function W(J) {
      return J instanceof t2._Code && J._items.some((G) => G instanceof t2.Name && Q[G.str] === 1 && $[G.str] !== void 0);
    }
  }
  function vN(X, Q) {
    for (let $ in Q) X[$] = (X[$] || 0) - (Q[$] || 0);
  }
  function wG(X) {
    return typeof X == "boolean" || typeof X == "number" || X === null ? !X : t2._`!${WY(X)}`;
  }
  y0.not = wG;
  var TN = MG(y0.operators.AND);
  function _N(...X) {
    return X.reduce(TN);
  }
  y0.and = _N;
  var xN = MG(y0.operators.OR);
  function yN(...X) {
    return X.reduce(xN);
  }
  y0.or = yN;
  function MG(X) {
    return (Q, $) => Q === t2.nil ? $ : $ === t2.nil ? Q : t2._`${WY(Q)} ${X} ${WY($)}`;
  }
  function WY(X) {
    return X instanceof t2.Name ? X : t2._`(${X})`;
  }
});
var e = P((CG) => {
  Object.defineProperty(CG, "__esModule", { value: true });
  CG.checkStrictMode = CG.getErrorPath = CG.Type = CG.useFunc = CG.setEvaluated = CG.evaluatedPropsToName = CG.mergeEvaluated = CG.eachItem = CG.unescapeJsonPointer = CG.escapeJsonPointer = CG.escapeFragment = CG.unescapeFragment = CG.schemaRefOrVal = CG.schemaHasRulesButRef = CG.schemaHasRules = CG.checkUnknownRules = CG.alwaysValidSchema = CG.toHash = void 0;
  var $0 = c(), uN = fX();
  function lN(X) {
    let Q = {};
    for (let $ of X) Q[$] = true;
    return Q;
  }
  CG.toHash = lN;
  function mN(X, Q) {
    if (typeof Q == "boolean") return Q;
    if (Object.keys(Q).length === 0) return true;
    return IG(X, Q), !bG(Q, X.self.RULES.all);
  }
  CG.alwaysValidSchema = mN;
  function IG(X, Q = X.schema) {
    let { opts: $, self: Y } = X;
    if (!$.strictSchema) return;
    if (typeof Q === "boolean") return;
    let W = Y.RULES.keywords;
    for (let J in Q) if (!W[J]) ZG(X, `unknown keyword: "${J}"`);
  }
  CG.checkUnknownRules = IG;
  function bG(X, Q) {
    if (typeof X == "boolean") return !X;
    for (let $ in X) if (Q[$]) return true;
    return false;
  }
  CG.schemaHasRules = bG;
  function cN(X, Q) {
    if (typeof X == "boolean") return !X;
    for (let $ in X) if ($ !== "$ref" && Q.all[$]) return true;
    return false;
  }
  CG.schemaHasRulesButRef = cN;
  function pN({ topSchemaRef: X, schemaPath: Q }, $, Y, W) {
    if (!W) {
      if (typeof $ == "number" || typeof $ == "boolean") return $;
      if (typeof $ == "string") return $0._`${$}`;
    }
    return $0._`${X}${Q}${(0, $0.getProperty)(Y)}`;
  }
  CG.schemaRefOrVal = pN;
  function dN(X) {
    return PG(decodeURIComponent(X));
  }
  CG.unescapeFragment = dN;
  function iN(X) {
    return encodeURIComponent(HY(X));
  }
  CG.escapeFragment = iN;
  function HY(X) {
    if (typeof X == "number") return `${X}`;
    return X.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  CG.escapeJsonPointer = HY;
  function PG(X) {
    return X.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  CG.unescapeJsonPointer = PG;
  function nN(X, Q) {
    if (Array.isArray(X)) for (let $ of X) Q($);
    else Q(X);
  }
  CG.eachItem = nN;
  function RG({ mergeNames: X, mergeToName: Q, mergeValues: $, resultToName: Y }) {
    return (W, J, G, H) => {
      let B = G === void 0 ? J : G instanceof $0.Name ? (J instanceof $0.Name ? X(W, J, G) : Q(W, J, G), G) : J instanceof $0.Name ? (Q(W, G, J), J) : $(J, G);
      return H === $0.Name && !(B instanceof $0.Name) ? Y(W, B) : B;
    };
  }
  CG.mergeEvaluated = { props: RG({ mergeNames: (X, Q, $) => X.if($0._`${$} !== true && ${Q} !== undefined`, () => {
    X.if($0._`${Q} === true`, () => X.assign($, true), () => X.assign($, $0._`${$} || {}`).code($0._`Object.assign(${$}, ${Q})`));
  }), mergeToName: (X, Q, $) => X.if($0._`${$} !== true`, () => {
    if (Q === true) X.assign($, true);
    else X.assign($, $0._`${$} || {}`), BY(X, $, Q);
  }), mergeValues: (X, Q) => X === true ? true : { ...X, ...Q }, resultToName: SG }), items: RG({ mergeNames: (X, Q, $) => X.if($0._`${$} !== true && ${Q} !== undefined`, () => X.assign($, $0._`${Q} === true ? true : ${$} > ${Q} ? ${$} : ${Q}`)), mergeToName: (X, Q, $) => X.if($0._`${$} !== true`, () => X.assign($, Q === true ? true : $0._`${$} > ${Q} ? ${$} : ${Q}`)), mergeValues: (X, Q) => X === true ? true : Math.max(X, Q), resultToName: (X, Q) => X.var("items", Q) }) };
  function SG(X, Q) {
    if (Q === true) return X.var("props", true);
    let $ = X.var("props", $0._`{}`);
    if (Q !== void 0) BY(X, $, Q);
    return $;
  }
  CG.evaluatedPropsToName = SG;
  function BY(X, Q, $) {
    Object.keys($).forEach((Y) => X.assign($0._`${Q}${(0, $0.getProperty)(Y)}`, true));
  }
  CG.setEvaluated = BY;
  var EG = {};
  function rN(X, Q) {
    return X.scopeValue("func", { ref: Q, code: EG[Q.code] || (EG[Q.code] = new uN._Code(Q.code)) });
  }
  CG.useFunc = rN;
  var GY;
  (function(X) {
    X[X.Num = 0] = "Num", X[X.Str = 1] = "Str";
  })(GY || (CG.Type = GY = {}));
  function oN(X, Q, $) {
    if (X instanceof $0.Name) {
      let Y = Q === GY.Num;
      return $ ? Y ? $0._`"[" + ${X} + "]"` : $0._`"['" + ${X} + "']"` : Y ? $0._`"/" + ${X}` : $0._`"/" + ${X}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return $ ? (0, $0.getProperty)(X).toString() : "/" + HY(X);
  }
  CG.getErrorPath = oN;
  function ZG(X, Q, $ = X.opts.strictSchema) {
    if (!$) return;
    if (Q = `strict mode: ${Q}`, $ === true) throw Error(Q);
    X.self.logger.warn(Q);
  }
  CG.checkStrictMode = ZG;
});
var R1 = P((vG) => {
  Object.defineProperty(vG, "__esModule", { value: true });
  var P0 = c(), LO = { data: new P0.Name("data"), valCxt: new P0.Name("valCxt"), instancePath: new P0.Name("instancePath"), parentData: new P0.Name("parentData"), parentDataProperty: new P0.Name("parentDataProperty"), rootData: new P0.Name("rootData"), dynamicAnchors: new P0.Name("dynamicAnchors"), vErrors: new P0.Name("vErrors"), errors: new P0.Name("errors"), this: new P0.Name("this"), self: new P0.Name("self"), scope: new P0.Name("scope"), json: new P0.Name("json"), jsonPos: new P0.Name("jsonPos"), jsonLen: new P0.Name("jsonLen"), jsonPart: new P0.Name("jsonPart") };
  vG.default = LO;
});
var lX = P((yG) => {
  Object.defineProperty(yG, "__esModule", { value: true });
  yG.extendErrors = yG.resetErrorsCount = yG.reportExtraError = yG.reportError = yG.keyword$DataError = yG.keywordError = void 0;
  var a = c(), Z9 = e(), v0 = R1();
  yG.keywordError = { message: ({ keyword: X }) => a.str`must pass "${X}" keyword validation` };
  yG.keyword$DataError = { message: ({ keyword: X, schemaType: Q }) => Q ? a.str`"${X}" keyword must be ${Q} ($data)` : a.str`"${X}" keyword is invalid ($data)` };
  function FO(X, Q = yG.keywordError, $, Y) {
    let { it: W } = X, { gen: J, compositeRule: G, allErrors: H } = W, B = xG(X, Q, $);
    if (Y !== null && Y !== void 0 ? Y : G || H) TG(J, B);
    else _G(W, a._`[${B}]`);
  }
  yG.reportError = FO;
  function NO(X, Q = yG.keywordError, $) {
    let { it: Y } = X, { gen: W, compositeRule: J, allErrors: G } = Y, H = xG(X, Q, $);
    if (TG(W, H), !(J || G)) _G(Y, v0.default.vErrors);
  }
  yG.reportExtraError = NO;
  function OO(X, Q) {
    X.assign(v0.default.errors, Q), X.if(a._`${v0.default.vErrors} !== null`, () => X.if(Q, () => X.assign(a._`${v0.default.vErrors}.length`, Q), () => X.assign(v0.default.vErrors, null)));
  }
  yG.resetErrorsCount = OO;
  function DO({ gen: X, keyword: Q, schemaValue: $, data: Y, errsCount: W, it: J }) {
    if (W === void 0) throw Error("ajv implementation error");
    let G = X.name("err");
    X.forRange("i", W, v0.default.errors, (H) => {
      if (X.const(G, a._`${v0.default.vErrors}[${H}]`), X.if(a._`${G}.instancePath === undefined`, () => X.assign(a._`${G}.instancePath`, (0, a.strConcat)(v0.default.instancePath, J.errorPath))), X.assign(a._`${G}.schemaPath`, a.str`${J.errSchemaPath}/${Q}`), J.opts.verbose) X.assign(a._`${G}.schema`, $), X.assign(a._`${G}.data`, Y);
    });
  }
  yG.extendErrors = DO;
  function TG(X, Q) {
    let $ = X.const("err", Q);
    X.if(a._`${v0.default.vErrors} === null`, () => X.assign(v0.default.vErrors, a._`[${$}]`), a._`${v0.default.vErrors}.push(${$})`), X.code(a._`${v0.default.errors}++`);
  }
  function _G(X, Q) {
    let { gen: $, validateName: Y, schemaEnv: W } = X;
    if (W.$async) $.throw(a._`new ${X.ValidationError}(${Q})`);
    else $.assign(a._`${Y}.errors`, Q), $.return(false);
  }
  var G6 = { keyword: new a.Name("keyword"), schemaPath: new a.Name("schemaPath"), params: new a.Name("params"), propertyName: new a.Name("propertyName"), message: new a.Name("message"), schema: new a.Name("schema"), parentSchema: new a.Name("parentSchema") };
  function xG(X, Q, $) {
    let { createErrors: Y } = X.it;
    if (Y === false) return a._`{}`;
    return AO(X, Q, $);
  }
  function AO(X, Q, $ = {}) {
    let { gen: Y, it: W } = X, J = [wO(W, $), MO(X, $)];
    return jO(X, Q, J), Y.object(...J);
  }
  function wO({ errorPath: X }, { instancePath: Q }) {
    let $ = Q ? a.str`${X}${(0, Z9.getErrorPath)(Q, Z9.Type.Str)}` : X;
    return [v0.default.instancePath, (0, a.strConcat)(v0.default.instancePath, $)];
  }
  function MO({ keyword: X, it: { errSchemaPath: Q } }, { schemaPath: $, parentSchema: Y }) {
    let W = Y ? Q : a.str`${Q}/${X}`;
    if ($) W = a.str`${W}${(0, Z9.getErrorPath)($, Z9.Type.Str)}`;
    return [G6.schemaPath, W];
  }
  function jO(X, { params: Q, message: $ }, Y) {
    let { keyword: W, data: J, schemaValue: G, it: H } = X, { opts: B, propertyName: z, topSchemaRef: K, schemaPath: V } = H;
    if (Y.push([G6.keyword, W], [G6.params, typeof Q == "function" ? Q(X) : Q || a._`{}`]), B.messages) Y.push([G6.message, typeof $ == "function" ? $(X) : $]);
    if (B.verbose) Y.push([G6.schema, G], [G6.parentSchema, a._`${K}${V}`], [v0.default.data, J]);
    if (z) Y.push([G6.propertyName, z]);
  }
});
var lG = P((fG) => {
  Object.defineProperty(fG, "__esModule", { value: true });
  fG.boolOrEmptySchema = fG.topBoolOrEmptySchema = void 0;
  var PO = lX(), SO = c(), ZO = R1(), CO = { message: "boolean schema is false" };
  function kO(X) {
    let { gen: Q, schema: $, validateName: Y } = X;
    if ($ === false) hG(X, false);
    else if (typeof $ == "object" && $.$async === true) Q.return(ZO.default.data);
    else Q.assign(SO._`${Y}.errors`, null), Q.return(true);
  }
  fG.topBoolOrEmptySchema = kO;
  function vO(X, Q) {
    let { gen: $, schema: Y } = X;
    if (Y === false) $.var(Q, false), hG(X);
    else $.var(Q, true);
  }
  fG.boolOrEmptySchema = vO;
  function hG(X, Q) {
    let { gen: $, data: Y } = X, W = { gen: $, keyword: "false schema", data: Y, schema: false, schemaCode: false, schemaValue: false, params: {}, it: X };
    (0, PO.reportError)(W, CO, void 0, Q);
  }
});
var KY = P((mG) => {
  Object.defineProperty(mG, "__esModule", { value: true });
  mG.getRules = mG.isJSONType = void 0;
  var _O = ["string", "number", "integer", "boolean", "null", "object", "array"], xO = new Set(_O);
  function yO(X) {
    return typeof X == "string" && xO.has(X);
  }
  mG.isJSONType = yO;
  function gO() {
    let X = { number: { type: "number", rules: [] }, string: { type: "string", rules: [] }, array: { type: "array", rules: [] }, object: { type: "object", rules: [] } };
    return { types: { ...X, integer: true, boolean: true, null: true }, rules: [{ rules: [] }, X.number, X.string, X.array, X.object], post: { rules: [] }, all: {}, keywords: {} };
  }
  mG.getRules = gO;
});
var UY = P((iG) => {
  Object.defineProperty(iG, "__esModule", { value: true });
  iG.shouldUseRule = iG.shouldUseGroup = iG.schemaHasRulesForType = void 0;
  function fO({ schema: X, self: Q }, $) {
    let Y = Q.RULES.types[$];
    return Y && Y !== true && pG(X, Y);
  }
  iG.schemaHasRulesForType = fO;
  function pG(X, Q) {
    return Q.rules.some(($) => dG(X, $));
  }
  iG.shouldUseGroup = pG;
  function dG(X, Q) {
    var $;
    return X[Q.keyword] !== void 0 || (($ = Q.definition.implements) === null || $ === void 0 ? void 0 : $.some((Y) => X[Y] !== void 0));
  }
  iG.shouldUseRule = dG;
});
var mX = P((aG) => {
  Object.defineProperty(aG, "__esModule", { value: true });
  aG.reportTypeError = aG.checkDataTypes = aG.checkDataType = aG.coerceAndCheckDataType = aG.getJSONTypes = aG.getSchemaTypes = aG.DataType = void 0;
  var mO = KY(), cO = UY(), pO = lX(), m = c(), rG = e(), l6;
  (function(X) {
    X[X.Correct = 0] = "Correct", X[X.Wrong = 1] = "Wrong";
  })(l6 || (aG.DataType = l6 = {}));
  function dO(X) {
    let Q = oG(X.type);
    if (Q.includes("null")) {
      if (X.nullable === false) throw Error("type: null contradicts nullable: false");
    } else {
      if (!Q.length && X.nullable !== void 0) throw Error('"nullable" cannot be used without "type"');
      if (X.nullable === true) Q.push("null");
    }
    return Q;
  }
  aG.getSchemaTypes = dO;
  function oG(X) {
    let Q = Array.isArray(X) ? X : X ? [X] : [];
    if (Q.every(mO.isJSONType)) return Q;
    throw Error("type must be JSONType or JSONType[]: " + Q.join(","));
  }
  aG.getJSONTypes = oG;
  function iO(X, Q) {
    let { gen: $, data: Y, opts: W } = X, J = nO(Q, W.coerceTypes), G = Q.length > 0 && !(J.length === 0 && Q.length === 1 && (0, cO.schemaHasRulesForType)(X, Q[0]));
    if (G) {
      let H = LY(Q, Y, W.strictNumbers, l6.Wrong);
      $.if(H, () => {
        if (J.length) rO(X, Q, J);
        else qY(X);
      });
    }
    return G;
  }
  aG.coerceAndCheckDataType = iO;
  var tG = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function nO(X, Q) {
    return Q ? X.filter(($) => tG.has($) || Q === "array" && $ === "array") : [];
  }
  function rO(X, Q, $) {
    let { gen: Y, data: W, opts: J } = X, G = Y.let("dataType", m._`typeof ${W}`), H = Y.let("coerced", m._`undefined`);
    if (J.coerceTypes === "array") Y.if(m._`${G} == 'object' && Array.isArray(${W}) && ${W}.length == 1`, () => Y.assign(W, m._`${W}[0]`).assign(G, m._`typeof ${W}`).if(LY(Q, W, J.strictNumbers), () => Y.assign(H, W)));
    Y.if(m._`${H} !== undefined`);
    for (let z of $) if (tG.has(z) || z === "array" && J.coerceTypes === "array") B(z);
    Y.else(), qY(X), Y.endIf(), Y.if(m._`${H} !== undefined`, () => {
      Y.assign(W, H), oO(X, H);
    });
    function B(z) {
      switch (z) {
        case "string":
          Y.elseIf(m._`${G} == "number" || ${G} == "boolean"`).assign(H, m._`"" + ${W}`).elseIf(m._`${W} === null`).assign(H, m._`""`);
          return;
        case "number":
          Y.elseIf(m._`${G} == "boolean" || ${W} === null
              || (${G} == "string" && ${W} && ${W} == +${W})`).assign(H, m._`+${W}`);
          return;
        case "integer":
          Y.elseIf(m._`${G} === "boolean" || ${W} === null
              || (${G} === "string" && ${W} && ${W} == +${W} && !(${W} % 1))`).assign(H, m._`+${W}`);
          return;
        case "boolean":
          Y.elseIf(m._`${W} === "false" || ${W} === 0 || ${W} === null`).assign(H, false).elseIf(m._`${W} === "true" || ${W} === 1`).assign(H, true);
          return;
        case "null":
          Y.elseIf(m._`${W} === "" || ${W} === 0 || ${W} === false`), Y.assign(H, null);
          return;
        case "array":
          Y.elseIf(m._`${G} === "string" || ${G} === "number"
              || ${G} === "boolean" || ${W} === null`).assign(H, m._`[${W}]`);
      }
    }
  }
  function oO({ gen: X, parentData: Q, parentDataProperty: $ }, Y) {
    X.if(m._`${Q} !== undefined`, () => X.assign(m._`${Q}[${$}]`, Y));
  }
  function VY(X, Q, $, Y = l6.Correct) {
    let W = Y === l6.Correct ? m.operators.EQ : m.operators.NEQ, J;
    switch (X) {
      case "null":
        return m._`${Q} ${W} null`;
      case "array":
        J = m._`Array.isArray(${Q})`;
        break;
      case "object":
        J = m._`${Q} && typeof ${Q} == "object" && !Array.isArray(${Q})`;
        break;
      case "integer":
        J = G(m._`!(${Q} % 1) && !isNaN(${Q})`);
        break;
      case "number":
        J = G();
        break;
      default:
        return m._`typeof ${Q} ${W} ${X}`;
    }
    return Y === l6.Correct ? J : (0, m.not)(J);
    function G(H = m.nil) {
      return (0, m.and)(m._`typeof ${Q} == "number"`, H, $ ? m._`isFinite(${Q})` : m.nil);
    }
  }
  aG.checkDataType = VY;
  function LY(X, Q, $, Y) {
    if (X.length === 1) return VY(X[0], Q, $, Y);
    let W, J = (0, rG.toHash)(X);
    if (J.array && J.object) {
      let G = m._`typeof ${Q} != "object"`;
      W = J.null ? G : m._`!${Q} || ${G}`, delete J.null, delete J.array, delete J.object;
    } else W = m.nil;
    if (J.number) delete J.integer;
    for (let G in J) W = (0, m.and)(W, VY(G, Q, $, Y));
    return W;
  }
  aG.checkDataTypes = LY;
  var tO = { message: ({ schema: X }) => `must be ${X}`, params: ({ schema: X, schemaValue: Q }) => typeof X == "string" ? m._`{type: ${X}}` : m._`{type: ${Q}}` };
  function qY(X) {
    let Q = aO(X);
    (0, pO.reportError)(Q, tO);
  }
  aG.reportTypeError = qY;
  function aO(X) {
    let { gen: Q, data: $, schema: Y } = X, W = (0, rG.schemaRefOrVal)(X, Y, "type");
    return { gen: Q, keyword: "type", data: $, schema: Y.type, schemaCode: W, schemaValue: W, parentSchema: Y, params: {}, it: X };
  }
});
var $3 = P((X3) => {
  Object.defineProperty(X3, "__esModule", { value: true });
  X3.assignDefaults = void 0;
  var m6 = c(), WD = e();
  function JD(X, Q) {
    let { properties: $, items: Y } = X.schema;
    if (Q === "object" && $) for (let W in $) eG(X, W, $[W].default);
    else if (Q === "array" && Array.isArray(Y)) Y.forEach((W, J) => eG(X, J, W.default));
  }
  X3.assignDefaults = JD;
  function eG(X, Q, $) {
    let { gen: Y, compositeRule: W, data: J, opts: G } = X;
    if ($ === void 0) return;
    let H = m6._`${J}${(0, m6.getProperty)(Q)}`;
    if (W) {
      (0, WD.checkStrictMode)(X, `default is ignored for: ${H}`);
      return;
    }
    let B = m6._`${H} === undefined`;
    if (G.useDefaults === "empty") B = m6._`${B} || ${H} === null || ${H} === ""`;
    Y.if(B, m6._`${H} = ${(0, m6.stringify)($)}`);
  }
});
var d0 = P((J3) => {
  Object.defineProperty(J3, "__esModule", { value: true });
  J3.validateUnion = J3.validateArray = J3.usePattern = J3.callValidateCode = J3.schemaProperties = J3.allSchemaProperties = J3.noPropertyInData = J3.propertyInData = J3.isOwnProperty = J3.hasPropFunc = J3.reportMissingProp = J3.checkMissingProp = J3.checkReportMissingProp = void 0;
  var G0 = c(), FY = e(), c1 = R1(), GD = e();
  function HD(X, Q) {
    let { gen: $, data: Y, it: W } = X;
    $.if(OY($, Y, Q, W.opts.ownProperties), () => {
      X.setParams({ missingProperty: G0._`${Q}` }, true), X.error();
    });
  }
  J3.checkReportMissingProp = HD;
  function BD({ gen: X, data: Q, it: { opts: $ } }, Y, W) {
    return (0, G0.or)(...Y.map((J) => (0, G0.and)(OY(X, Q, J, $.ownProperties), G0._`${W} = ${J}`)));
  }
  J3.checkMissingProp = BD;
  function zD(X, Q) {
    X.setParams({ missingProperty: Q }, true), X.error();
  }
  J3.reportMissingProp = zD;
  function Y3(X) {
    return X.scopeValue("func", { ref: Object.prototype.hasOwnProperty, code: G0._`Object.prototype.hasOwnProperty` });
  }
  J3.hasPropFunc = Y3;
  function NY(X, Q, $) {
    return G0._`${Y3(X)}.call(${Q}, ${$})`;
  }
  J3.isOwnProperty = NY;
  function KD(X, Q, $, Y) {
    let W = G0._`${Q}${(0, G0.getProperty)($)} !== undefined`;
    return Y ? G0._`${W} && ${NY(X, Q, $)}` : W;
  }
  J3.propertyInData = KD;
  function OY(X, Q, $, Y) {
    let W = G0._`${Q}${(0, G0.getProperty)($)} === undefined`;
    return Y ? (0, G0.or)(W, (0, G0.not)(NY(X, Q, $))) : W;
  }
  J3.noPropertyInData = OY;
  function W3(X) {
    return X ? Object.keys(X).filter((Q) => Q !== "__proto__") : [];
  }
  J3.allSchemaProperties = W3;
  function UD(X, Q) {
    return W3(Q).filter(($) => !(0, FY.alwaysValidSchema)(X, Q[$]));
  }
  J3.schemaProperties = UD;
  function VD({ schemaCode: X, data: Q, it: { gen: $, topSchemaRef: Y, schemaPath: W, errorPath: J }, it: G }, H, B, z) {
    let K = z ? G0._`${X}, ${Q}, ${Y}${W}` : Q, V = [[c1.default.instancePath, (0, G0.strConcat)(c1.default.instancePath, J)], [c1.default.parentData, G.parentData], [c1.default.parentDataProperty, G.parentDataProperty], [c1.default.rootData, c1.default.rootData]];
    if (G.opts.dynamicRef) V.push([c1.default.dynamicAnchors, c1.default.dynamicAnchors]);
    let L = G0._`${K}, ${$.object(...V)}`;
    return B !== G0.nil ? G0._`${H}.call(${B}, ${L})` : G0._`${H}(${L})`;
  }
  J3.callValidateCode = VD;
  var LD = G0._`new RegExp`;
  function qD({ gen: X, it: { opts: Q } }, $) {
    let Y = Q.unicodeRegExp ? "u" : "", { regExp: W } = Q.code, J = W($, Y);
    return X.scopeValue("pattern", { key: J.toString(), ref: J, code: G0._`${W.code === "new RegExp" ? LD : (0, GD.useFunc)(X, W)}(${$}, ${Y})` });
  }
  J3.usePattern = qD;
  function FD(X) {
    let { gen: Q, data: $, keyword: Y, it: W } = X, J = Q.name("valid");
    if (W.allErrors) {
      let H = Q.let("valid", true);
      return G(() => Q.assign(H, false)), H;
    }
    return Q.var(J, true), G(() => Q.break()), J;
    function G(H) {
      let B = Q.const("len", G0._`${$}.length`);
      Q.forRange("i", 0, B, (z) => {
        X.subschema({ keyword: Y, dataProp: z, dataPropType: FY.Type.Num }, J), Q.if((0, G0.not)(J), H);
      });
    }
  }
  J3.validateArray = FD;
  function ND(X) {
    let { gen: Q, schema: $, keyword: Y, it: W } = X;
    if (!Array.isArray($)) throw Error("ajv implementation error");
    if ($.some((B) => (0, FY.alwaysValidSchema)(W, B)) && !W.opts.unevaluated) return;
    let G = Q.let("valid", false), H = Q.name("_valid");
    Q.block(() => $.forEach((B, z) => {
      let K = X.subschema({ keyword: Y, schemaProp: z, compositeRule: true }, H);
      if (Q.assign(G, G0._`${G} || ${H}`), !X.mergeValidEvaluated(K, H)) Q.if((0, G0.not)(G));
    })), X.result(G, () => X.reset(), () => X.error(true));
  }
  J3.validateUnion = ND;
});
var U3 = P((z3) => {
  Object.defineProperty(z3, "__esModule", { value: true });
  z3.validateKeywordUsage = z3.validSchemaType = z3.funcKeywordCode = z3.macroKeywordCode = void 0;
  var T0 = c(), H6 = R1(), ZD = d0(), CD = lX();
  function kD(X, Q) {
    let { gen: $, keyword: Y, schema: W, parentSchema: J, it: G } = X, H = Q.macro.call(G.self, W, J, G), B = B3($, Y, H);
    if (G.opts.validateSchema !== false) G.self.validateSchema(H, true);
    let z = $.name("valid");
    X.subschema({ schema: H, schemaPath: T0.nil, errSchemaPath: `${G.errSchemaPath}/${Y}`, topSchemaRef: B, compositeRule: true }, z), X.pass(z, () => X.error(true));
  }
  z3.macroKeywordCode = kD;
  function vD(X, Q) {
    var $;
    let { gen: Y, keyword: W, schema: J, parentSchema: G, $data: H, it: B } = X;
    _D(B, Q);
    let z = !H && Q.compile ? Q.compile.call(B.self, J, G, B) : Q.validate, K = B3(Y, W, z), V = Y.let("valid");
    X.block$data(V, L), X.ok(($ = Q.valid) !== null && $ !== void 0 ? $ : V);
    function L() {
      if (Q.errors === false) {
        if (q(), Q.modifying) H3(X);
        N(() => X.error());
      } else {
        let A = Q.async ? U() : F();
        if (Q.modifying) H3(X);
        N(() => TD(X, A));
      }
    }
    function U() {
      let A = Y.let("ruleErrs", null);
      return Y.try(() => q(T0._`await `), (M) => Y.assign(V, false).if(T0._`${M} instanceof ${B.ValidationError}`, () => Y.assign(A, T0._`${M}.errors`), () => Y.throw(M))), A;
    }
    function F() {
      let A = T0._`${K}.errors`;
      return Y.assign(A, null), q(T0.nil), A;
    }
    function q(A = Q.async ? T0._`await ` : T0.nil) {
      let M = B.opts.passContext ? H6.default.this : H6.default.self, R = !("compile" in Q && !H || Q.schema === false);
      Y.assign(V, T0._`${A}${(0, ZD.callValidateCode)(X, K, M, R)}`, Q.modifying);
    }
    function N(A) {
      var M;
      Y.if((0, T0.not)((M = Q.valid) !== null && M !== void 0 ? M : V), A);
    }
  }
  z3.funcKeywordCode = vD;
  function H3(X) {
    let { gen: Q, data: $, it: Y } = X;
    Q.if(Y.parentData, () => Q.assign($, T0._`${Y.parentData}[${Y.parentDataProperty}]`));
  }
  function TD(X, Q) {
    let { gen: $ } = X;
    $.if(T0._`Array.isArray(${Q})`, () => {
      $.assign(H6.default.vErrors, T0._`${H6.default.vErrors} === null ? ${Q} : ${H6.default.vErrors}.concat(${Q})`).assign(H6.default.errors, T0._`${H6.default.vErrors}.length`), (0, CD.extendErrors)(X);
    }, () => X.error());
  }
  function _D({ schemaEnv: X }, Q) {
    if (Q.async && !X.$async) throw Error("async keyword in sync schema");
  }
  function B3(X, Q, $) {
    if ($ === void 0) throw Error(`keyword "${Q}" failed to compile`);
    return X.scopeValue("keyword", typeof $ == "function" ? { ref: $ } : { ref: $, code: (0, T0.stringify)($) });
  }
  function xD(X, Q, $ = false) {
    return !Q.length || Q.some((Y) => Y === "array" ? Array.isArray(X) : Y === "object" ? X && typeof X == "object" && !Array.isArray(X) : typeof X == Y || $ && typeof X > "u");
  }
  z3.validSchemaType = xD;
  function yD({ schema: X, opts: Q, self: $, errSchemaPath: Y }, W, J) {
    if (Array.isArray(W.keyword) ? !W.keyword.includes(J) : W.keyword !== J) throw Error("ajv implementation error");
    let G = W.dependencies;
    if (G === null || G === void 0 ? void 0 : G.some((H) => !Object.prototype.hasOwnProperty.call(X, H))) throw Error(`parent schema must have dependencies of ${J}: ${G.join(",")}`);
    if (W.validateSchema) {
      if (!W.validateSchema(X[J])) {
        let B = `keyword "${J}" value is invalid at path "${Y}": ` + $.errorsText(W.validateSchema.errors);
        if (Q.validateSchema === "log") $.logger.error(B);
        else throw Error(B);
      }
    }
  }
  z3.validateKeywordUsage = yD;
});
var F3 = P((L3) => {
  Object.defineProperty(L3, "__esModule", { value: true });
  L3.extendSubschemaMode = L3.extendSubschemaData = L3.getSubschema = void 0;
  var U1 = c(), V3 = e();
  function uD(X, { keyword: Q, schemaProp: $, schema: Y, schemaPath: W, errSchemaPath: J, topSchemaRef: G }) {
    if (Q !== void 0 && Y !== void 0) throw Error('both "keyword" and "schema" passed, only one allowed');
    if (Q !== void 0) {
      let H = X.schema[Q];
      return $ === void 0 ? { schema: H, schemaPath: U1._`${X.schemaPath}${(0, U1.getProperty)(Q)}`, errSchemaPath: `${X.errSchemaPath}/${Q}` } : { schema: H[$], schemaPath: U1._`${X.schemaPath}${(0, U1.getProperty)(Q)}${(0, U1.getProperty)($)}`, errSchemaPath: `${X.errSchemaPath}/${Q}/${(0, V3.escapeFragment)($)}` };
    }
    if (Y !== void 0) {
      if (W === void 0 || J === void 0 || G === void 0) throw Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
      return { schema: Y, schemaPath: W, topSchemaRef: G, errSchemaPath: J };
    }
    throw Error('either "keyword" or "schema" must be passed');
  }
  L3.getSubschema = uD;
  function lD(X, Q, { dataProp: $, dataPropType: Y, data: W, dataTypes: J, propertyName: G }) {
    if (W !== void 0 && $ !== void 0) throw Error('both "data" and "dataProp" passed, only one allowed');
    let { gen: H } = Q;
    if ($ !== void 0) {
      let { errorPath: z, dataPathArr: K, opts: V } = Q, L = H.let("data", U1._`${Q.data}${(0, U1.getProperty)($)}`, true);
      B(L), X.errorPath = U1.str`${z}${(0, V3.getErrorPath)($, Y, V.jsPropertySyntax)}`, X.parentDataProperty = U1._`${$}`, X.dataPathArr = [...K, X.parentDataProperty];
    }
    if (W !== void 0) {
      let z = W instanceof U1.Name ? W : H.let("data", W, true);
      if (B(z), G !== void 0) X.propertyName = G;
    }
    if (J) X.dataTypes = J;
    function B(z) {
      X.data = z, X.dataLevel = Q.dataLevel + 1, X.dataTypes = [], Q.definedProperties = /* @__PURE__ */ new Set(), X.parentData = Q.data, X.dataNames = [...Q.dataNames, z];
    }
  }
  L3.extendSubschemaData = lD;
  function mD(X, { jtdDiscriminator: Q, jtdMetadata: $, compositeRule: Y, createErrors: W, allErrors: J }) {
    if (Y !== void 0) X.compositeRule = Y;
    if (W !== void 0) X.createErrors = W;
    if (J !== void 0) X.allErrors = J;
    X.jtdDiscriminator = Q, X.jtdMetadata = $;
  }
  L3.extendSubschemaMode = mD;
});
var DY = P((pv, N3) => {
  N3.exports = function X(Q, $) {
    if (Q === $) return true;
    if (Q && $ && typeof Q == "object" && typeof $ == "object") {
      if (Q.constructor !== $.constructor) return false;
      var Y, W, J;
      if (Array.isArray(Q)) {
        if (Y = Q.length, Y != $.length) return false;
        for (W = Y; W-- !== 0; ) if (!X(Q[W], $[W])) return false;
        return true;
      }
      if (Q.constructor === RegExp) return Q.source === $.source && Q.flags === $.flags;
      if (Q.valueOf !== Object.prototype.valueOf) return Q.valueOf() === $.valueOf();
      if (Q.toString !== Object.prototype.toString) return Q.toString() === $.toString();
      if (J = Object.keys(Q), Y = J.length, Y !== Object.keys($).length) return false;
      for (W = Y; W-- !== 0; ) if (!Object.prototype.hasOwnProperty.call($, J[W])) return false;
      for (W = Y; W-- !== 0; ) {
        var G = J[W];
        if (!X(Q[G], $[G])) return false;
      }
      return true;
    }
    return Q !== Q && $ !== $;
  };
});
var D3 = P((dv, O3) => {
  var p1 = O3.exports = function(X, Q, $) {
    if (typeof Q == "function") $ = Q, Q = {};
    $ = Q.cb || $;
    var Y = typeof $ == "function" ? $ : $.pre || function() {
    }, W = $.post || function() {
    };
    C9(Q, Y, W, X, "", X);
  };
  p1.keywords = { additionalItems: true, items: true, contains: true, additionalProperties: true, propertyNames: true, not: true, if: true, then: true, else: true };
  p1.arrayKeywords = { items: true, allOf: true, anyOf: true, oneOf: true };
  p1.propsKeywords = { $defs: true, definitions: true, properties: true, patternProperties: true, dependencies: true };
  p1.skipKeywords = { default: true, enum: true, const: true, required: true, maximum: true, minimum: true, exclusiveMaximum: true, exclusiveMinimum: true, multipleOf: true, maxLength: true, minLength: true, pattern: true, format: true, maxItems: true, minItems: true, uniqueItems: true, maxProperties: true, minProperties: true };
  function C9(X, Q, $, Y, W, J, G, H, B, z) {
    if (Y && typeof Y == "object" && !Array.isArray(Y)) {
      Q(Y, W, J, G, H, B, z);
      for (var K in Y) {
        var V = Y[K];
        if (Array.isArray(V)) {
          if (K in p1.arrayKeywords) for (var L = 0; L < V.length; L++) C9(X, Q, $, V[L], W + "/" + K + "/" + L, J, W, K, Y, L);
        } else if (K in p1.propsKeywords) {
          if (V && typeof V == "object") for (var U in V) C9(X, Q, $, V[U], W + "/" + K + "/" + dD(U), J, W, K, Y, U);
        } else if (K in p1.keywords || X.allKeys && !(K in p1.skipKeywords)) C9(X, Q, $, V, W + "/" + K, J, W, K, Y);
      }
      $(Y, W, J, G, H, B, z);
    }
  }
  function dD(X) {
    return X.replace(/~/g, "~0").replace(/\//g, "~1");
  }
});
var cX = P((j3) => {
  Object.defineProperty(j3, "__esModule", { value: true });
  j3.getSchemaRefs = j3.resolveUrl = j3.normalizeId = j3._getFullPath = j3.getFullPath = j3.inlineRef = void 0;
  var iD = e(), nD = DY(), rD = D3(), oD = /* @__PURE__ */ new Set(["type", "format", "pattern", "maxLength", "minLength", "maxProperties", "minProperties", "maxItems", "minItems", "maximum", "minimum", "uniqueItems", "multipleOf", "required", "enum", "const"]);
  function tD(X, Q = true) {
    if (typeof X == "boolean") return true;
    if (Q === true) return !AY(X);
    if (!Q) return false;
    return A3(X) <= Q;
  }
  j3.inlineRef = tD;
  var aD = /* @__PURE__ */ new Set(["$ref", "$recursiveRef", "$recursiveAnchor", "$dynamicRef", "$dynamicAnchor"]);
  function AY(X) {
    for (let Q in X) {
      if (aD.has(Q)) return true;
      let $ = X[Q];
      if (Array.isArray($) && $.some(AY)) return true;
      if (typeof $ == "object" && AY($)) return true;
    }
    return false;
  }
  function A3(X) {
    let Q = 0;
    for (let $ in X) {
      if ($ === "$ref") return 1 / 0;
      if (Q++, oD.has($)) continue;
      if (typeof X[$] == "object") (0, iD.eachItem)(X[$], (Y) => Q += A3(Y));
      if (Q === 1 / 0) return 1 / 0;
    }
    return Q;
  }
  function w3(X, Q = "", $) {
    if ($ !== false) Q = c6(Q);
    let Y = X.parse(Q);
    return M3(X, Y);
  }
  j3.getFullPath = w3;
  function M3(X, Q) {
    return X.serialize(Q).split("#")[0] + "#";
  }
  j3._getFullPath = M3;
  var sD = /#\/?$/;
  function c6(X) {
    return X ? X.replace(sD, "") : "";
  }
  j3.normalizeId = c6;
  function eD(X, Q, $) {
    return $ = c6($), X.resolve(Q, $);
  }
  j3.resolveUrl = eD;
  var XA = /^[a-z_][-a-z0-9._]*$/i;
  function QA(X, Q) {
    if (typeof X == "boolean") return {};
    let { schemaId: $, uriResolver: Y } = this.opts, W = c6(X[$] || Q), J = { "": W }, G = w3(Y, W, false), H = {}, B = /* @__PURE__ */ new Set();
    return rD(X, { allKeys: true }, (V, L, U, F) => {
      if (F === void 0) return;
      let q = G + L, N = J[F];
      if (typeof V[$] == "string") N = A.call(this, V[$]);
      M.call(this, V.$anchor), M.call(this, V.$dynamicAnchor), J[L] = N;
      function A(R) {
        let S = this.opts.uriResolver.resolve;
        if (R = c6(N ? S(N, R) : R), B.has(R)) throw K(R);
        B.add(R);
        let C = this.refs[R];
        if (typeof C == "string") C = this.refs[C];
        if (typeof C == "object") z(V, C.schema, R);
        else if (R !== c6(q)) if (R[0] === "#") z(V, H[R], R), H[R] = V;
        else this.refs[R] = q;
        return R;
      }
      function M(R) {
        if (typeof R == "string") {
          if (!XA.test(R)) throw Error(`invalid anchor "${R}"`);
          A.call(this, `#${R}`);
        }
      }
    }), H;
    function z(V, L, U) {
      if (L !== void 0 && !nD(V, L)) throw K(U);
    }
    function K(V) {
      return Error(`reference "${V}" resolves to more than one schema`);
    }
  }
  j3.getSchemaRefs = QA;
});
var iX = P((h3) => {
  Object.defineProperty(h3, "__esModule", { value: true });
  h3.getData = h3.KeywordCxt = h3.validateFunctionCode = void 0;
  var S3 = lG(), E3 = mX(), MY = UY(), k9 = mX(), HA = $3(), dX = U3(), wY = F3(), _ = c(), u = R1(), BA = cX(), E1 = e(), pX = lX();
  function zA(X) {
    if (k3(X)) {
      if (v3(X), C3(X)) {
        VA(X);
        return;
      }
    }
    Z3(X, () => (0, S3.topBoolOrEmptySchema)(X));
  }
  h3.validateFunctionCode = zA;
  function Z3({ gen: X, validateName: Q, schema: $, schemaEnv: Y, opts: W }, J) {
    if (W.code.es5) X.func(Q, _._`${u.default.data}, ${u.default.valCxt}`, Y.$async, () => {
      X.code(_._`"use strict"; ${I3($, W)}`), UA(X, W), X.code(J);
    });
    else X.func(Q, _._`${u.default.data}, ${KA(W)}`, Y.$async, () => X.code(I3($, W)).code(J));
  }
  function KA(X) {
    return _._`{${u.default.instancePath}="", ${u.default.parentData}, ${u.default.parentDataProperty}, ${u.default.rootData}=${u.default.data}${X.dynamicRef ? _._`, ${u.default.dynamicAnchors}={}` : _.nil}}={}`;
  }
  function UA(X, Q) {
    X.if(u.default.valCxt, () => {
      if (X.var(u.default.instancePath, _._`${u.default.valCxt}.${u.default.instancePath}`), X.var(u.default.parentData, _._`${u.default.valCxt}.${u.default.parentData}`), X.var(u.default.parentDataProperty, _._`${u.default.valCxt}.${u.default.parentDataProperty}`), X.var(u.default.rootData, _._`${u.default.valCxt}.${u.default.rootData}`), Q.dynamicRef) X.var(u.default.dynamicAnchors, _._`${u.default.valCxt}.${u.default.dynamicAnchors}`);
    }, () => {
      if (X.var(u.default.instancePath, _._`""`), X.var(u.default.parentData, _._`undefined`), X.var(u.default.parentDataProperty, _._`undefined`), X.var(u.default.rootData, u.default.data), Q.dynamicRef) X.var(u.default.dynamicAnchors, _._`{}`);
    });
  }
  function VA(X) {
    let { schema: Q, opts: $, gen: Y } = X;
    Z3(X, () => {
      if ($.$comment && Q.$comment) _3(X);
      if (OA(X), Y.let(u.default.vErrors, null), Y.let(u.default.errors, 0), $.unevaluated) LA(X);
      T3(X), wA(X);
    });
    return;
  }
  function LA(X) {
    let { gen: Q, validateName: $ } = X;
    X.evaluated = Q.const("evaluated", _._`${$}.evaluated`), Q.if(_._`${X.evaluated}.dynamicProps`, () => Q.assign(_._`${X.evaluated}.props`, _._`undefined`)), Q.if(_._`${X.evaluated}.dynamicItems`, () => Q.assign(_._`${X.evaluated}.items`, _._`undefined`));
  }
  function I3(X, Q) {
    let $ = typeof X == "object" && X[Q.schemaId];
    return $ && (Q.code.source || Q.code.process) ? _._`/*# sourceURL=${$} */` : _.nil;
  }
  function qA(X, Q) {
    if (k3(X)) {
      if (v3(X), C3(X)) {
        FA(X, Q);
        return;
      }
    }
    (0, S3.boolOrEmptySchema)(X, Q);
  }
  function C3({ schema: X, self: Q }) {
    if (typeof X == "boolean") return !X;
    for (let $ in X) if (Q.RULES.all[$]) return true;
    return false;
  }
  function k3(X) {
    return typeof X.schema != "boolean";
  }
  function FA(X, Q) {
    let { schema: $, gen: Y, opts: W } = X;
    if (W.$comment && $.$comment) _3(X);
    DA(X), AA(X);
    let J = Y.const("_errs", u.default.errors);
    T3(X, J), Y.var(Q, _._`${J} === ${u.default.errors}`);
  }
  function v3(X) {
    (0, E1.checkUnknownRules)(X), NA(X);
  }
  function T3(X, Q) {
    if (X.opts.jtd) return b3(X, [], false, Q);
    let $ = (0, E3.getSchemaTypes)(X.schema), Y = (0, E3.coerceAndCheckDataType)(X, $);
    b3(X, $, !Y, Q);
  }
  function NA(X) {
    let { schema: Q, errSchemaPath: $, opts: Y, self: W } = X;
    if (Q.$ref && Y.ignoreKeywordsWithRef && (0, E1.schemaHasRulesButRef)(Q, W.RULES)) W.logger.warn(`$ref: keywords ignored in schema at path "${$}"`);
  }
  function OA(X) {
    let { schema: Q, opts: $ } = X;
    if (Q.default !== void 0 && $.useDefaults && $.strictSchema) (0, E1.checkStrictMode)(X, "default is ignored in the schema root");
  }
  function DA(X) {
    let Q = X.schema[X.opts.schemaId];
    if (Q) X.baseId = (0, BA.resolveUrl)(X.opts.uriResolver, X.baseId, Q);
  }
  function AA(X) {
    if (X.schema.$async && !X.schemaEnv.$async) throw Error("async schema in sync schema");
  }
  function _3({ gen: X, schemaEnv: Q, schema: $, errSchemaPath: Y, opts: W }) {
    let J = $.$comment;
    if (W.$comment === true) X.code(_._`${u.default.self}.logger.log(${J})`);
    else if (typeof W.$comment == "function") {
      let G = _.str`${Y}/$comment`, H = X.scopeValue("root", { ref: Q.root });
      X.code(_._`${u.default.self}.opts.$comment(${J}, ${G}, ${H}.schema)`);
    }
  }
  function wA(X) {
    let { gen: Q, schemaEnv: $, validateName: Y, ValidationError: W, opts: J } = X;
    if ($.$async) Q.if(_._`${u.default.errors} === 0`, () => Q.return(u.default.data), () => Q.throw(_._`new ${W}(${u.default.vErrors})`));
    else {
      if (Q.assign(_._`${Y}.errors`, u.default.vErrors), J.unevaluated) MA(X);
      Q.return(_._`${u.default.errors} === 0`);
    }
  }
  function MA({ gen: X, evaluated: Q, props: $, items: Y }) {
    if ($ instanceof _.Name) X.assign(_._`${Q}.props`, $);
    if (Y instanceof _.Name) X.assign(_._`${Q}.items`, Y);
  }
  function b3(X, Q, $, Y) {
    let { gen: W, schema: J, data: G, allErrors: H, opts: B, self: z } = X, { RULES: K } = z;
    if (J.$ref && (B.ignoreKeywordsWithRef || !(0, E1.schemaHasRulesButRef)(J, K))) {
      W.block(() => y3(X, "$ref", K.all.$ref.definition));
      return;
    }
    if (!B.jtd) jA(X, Q);
    W.block(() => {
      for (let L of K.rules) V(L);
      V(K.post);
    });
    function V(L) {
      if (!(0, MY.shouldUseGroup)(J, L)) return;
      if (L.type) {
        if (W.if((0, k9.checkDataType)(L.type, G, B.strictNumbers)), P3(X, L), Q.length === 1 && Q[0] === L.type && $) W.else(), (0, k9.reportTypeError)(X);
        W.endIf();
      } else P3(X, L);
      if (!H) W.if(_._`${u.default.errors} === ${Y || 0}`);
    }
  }
  function P3(X, Q) {
    let { gen: $, schema: Y, opts: { useDefaults: W } } = X;
    if (W) (0, HA.assignDefaults)(X, Q.type);
    $.block(() => {
      for (let J of Q.rules) if ((0, MY.shouldUseRule)(Y, J)) y3(X, J.keyword, J.definition, Q.type);
    });
  }
  function jA(X, Q) {
    if (X.schemaEnv.meta || !X.opts.strictTypes) return;
    if (RA(X, Q), !X.opts.allowUnionTypes) EA(X, Q);
    IA(X, X.dataTypes);
  }
  function RA(X, Q) {
    if (!Q.length) return;
    if (!X.dataTypes.length) {
      X.dataTypes = Q;
      return;
    }
    Q.forEach(($) => {
      if (!x3(X.dataTypes, $)) jY(X, `type "${$}" not allowed by context "${X.dataTypes.join(",")}"`);
    }), PA(X, Q);
  }
  function EA(X, Q) {
    if (Q.length > 1 && !(Q.length === 2 && Q.includes("null"))) jY(X, "use allowUnionTypes to allow union type keyword");
  }
  function IA(X, Q) {
    let $ = X.self.RULES.all;
    for (let Y in $) {
      let W = $[Y];
      if (typeof W == "object" && (0, MY.shouldUseRule)(X.schema, W)) {
        let { type: J } = W.definition;
        if (J.length && !J.some((G) => bA(Q, G))) jY(X, `missing type "${J.join(",")}" for keyword "${Y}"`);
      }
    }
  }
  function bA(X, Q) {
    return X.includes(Q) || Q === "number" && X.includes("integer");
  }
  function x3(X, Q) {
    return X.includes(Q) || Q === "integer" && X.includes("number");
  }
  function PA(X, Q) {
    let $ = [];
    for (let Y of X.dataTypes) if (x3(Q, Y)) $.push(Y);
    else if (Q.includes("integer") && Y === "number") $.push("integer");
    X.dataTypes = $;
  }
  function jY(X, Q) {
    let $ = X.schemaEnv.baseId + X.errSchemaPath;
    Q += ` at "${$}" (strictTypes)`, (0, E1.checkStrictMode)(X, Q, X.opts.strictTypes);
  }
  class RY {
    constructor(X, Q, $) {
      if ((0, dX.validateKeywordUsage)(X, Q, $), this.gen = X.gen, this.allErrors = X.allErrors, this.keyword = $, this.data = X.data, this.schema = X.schema[$], this.$data = Q.$data && X.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, E1.schemaRefOrVal)(X, this.schema, $, this.$data), this.schemaType = Q.schemaType, this.parentSchema = X.schema, this.params = {}, this.it = X, this.def = Q, this.$data) this.schemaCode = X.gen.const("vSchema", g3(this.$data, X));
      else if (this.schemaCode = this.schemaValue, !(0, dX.validSchemaType)(this.schema, Q.schemaType, Q.allowUndefined)) throw Error(`${$} value must be ${JSON.stringify(Q.schemaType)}`);
      if ("code" in Q ? Q.trackErrors : Q.errors !== false) this.errsCount = X.gen.const("_errs", u.default.errors);
    }
    result(X, Q, $) {
      this.failResult((0, _.not)(X), Q, $);
    }
    failResult(X, Q, $) {
      if (this.gen.if(X), $) $();
      else this.error();
      if (Q) {
        if (this.gen.else(), Q(), this.allErrors) this.gen.endIf();
      } else if (this.allErrors) this.gen.endIf();
      else this.gen.else();
    }
    pass(X, Q) {
      this.failResult((0, _.not)(X), void 0, Q);
    }
    fail(X) {
      if (X === void 0) {
        if (this.error(), !this.allErrors) this.gen.if(false);
        return;
      }
      if (this.gen.if(X), this.error(), this.allErrors) this.gen.endIf();
      else this.gen.else();
    }
    fail$data(X) {
      if (!this.$data) return this.fail(X);
      let { schemaCode: Q } = this;
      this.fail(_._`${Q} !== undefined && (${(0, _.or)(this.invalid$data(), X)})`);
    }
    error(X, Q, $) {
      if (Q) {
        this.setParams(Q), this._error(X, $), this.setParams({});
        return;
      }
      this._error(X, $);
    }
    _error(X, Q) {
      (X ? pX.reportExtraError : pX.reportError)(this, this.def.error, Q);
    }
    $dataError() {
      (0, pX.reportError)(this, this.def.$dataError || pX.keyword$DataError);
    }
    reset() {
      if (this.errsCount === void 0) throw Error('add "trackErrors" to keyword definition');
      (0, pX.resetErrorsCount)(this.gen, this.errsCount);
    }
    ok(X) {
      if (!this.allErrors) this.gen.if(X);
    }
    setParams(X, Q) {
      if (Q) Object.assign(this.params, X);
      else this.params = X;
    }
    block$data(X, Q, $ = _.nil) {
      this.gen.block(() => {
        this.check$data(X, $), Q();
      });
    }
    check$data(X = _.nil, Q = _.nil) {
      if (!this.$data) return;
      let { gen: $, schemaCode: Y, schemaType: W, def: J } = this;
      if ($.if((0, _.or)(_._`${Y} === undefined`, Q)), X !== _.nil) $.assign(X, true);
      if (W.length || J.validateSchema) {
        if ($.elseIf(this.invalid$data()), this.$dataError(), X !== _.nil) $.assign(X, false);
      }
      $.else();
    }
    invalid$data() {
      let { gen: X, schemaCode: Q, schemaType: $, def: Y, it: W } = this;
      return (0, _.or)(J(), G());
      function J() {
        if ($.length) {
          if (!(Q instanceof _.Name)) throw Error("ajv implementation error");
          let H = Array.isArray($) ? $ : [$];
          return _._`${(0, k9.checkDataTypes)(H, Q, W.opts.strictNumbers, k9.DataType.Wrong)}`;
        }
        return _.nil;
      }
      function G() {
        if (Y.validateSchema) {
          let H = X.scopeValue("validate$data", { ref: Y.validateSchema });
          return _._`!${H}(${Q})`;
        }
        return _.nil;
      }
    }
    subschema(X, Q) {
      let $ = (0, wY.getSubschema)(this.it, X);
      (0, wY.extendSubschemaData)($, this.it, X), (0, wY.extendSubschemaMode)($, X);
      let Y = { ...this.it, ...$, items: void 0, props: void 0 };
      return qA(Y, Q), Y;
    }
    mergeEvaluated(X, Q) {
      let { it: $, gen: Y } = this;
      if (!$.opts.unevaluated) return;
      if ($.props !== true && X.props !== void 0) $.props = E1.mergeEvaluated.props(Y, X.props, $.props, Q);
      if ($.items !== true && X.items !== void 0) $.items = E1.mergeEvaluated.items(Y, X.items, $.items, Q);
    }
    mergeValidEvaluated(X, Q) {
      let { it: $, gen: Y } = this;
      if ($.opts.unevaluated && ($.props !== true || $.items !== true)) return Y.if(Q, () => this.mergeEvaluated(X, _.Name)), true;
    }
  }
  h3.KeywordCxt = RY;
  function y3(X, Q, $, Y) {
    let W = new RY(X, $, Q);
    if ("code" in $) $.code(W, Y);
    else if (W.$data && $.validate) (0, dX.funcKeywordCode)(W, $);
    else if ("macro" in $) (0, dX.macroKeywordCode)(W, $);
    else if ($.compile || $.validate) (0, dX.funcKeywordCode)(W, $);
  }
  var SA = /^\/(?:[^~]|~0|~1)*$/, ZA = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function g3(X, { dataLevel: Q, dataNames: $, dataPathArr: Y }) {
    let W, J;
    if (X === "") return u.default.rootData;
    if (X[0] === "/") {
      if (!SA.test(X)) throw Error(`Invalid JSON-pointer: ${X}`);
      W = X, J = u.default.rootData;
    } else {
      let z = ZA.exec(X);
      if (!z) throw Error(`Invalid JSON-pointer: ${X}`);
      let K = +z[1];
      if (W = z[2], W === "#") {
        if (K >= Q) throw Error(B("property/index", K));
        return Y[Q - K];
      }
      if (K > Q) throw Error(B("data", K));
      if (J = $[Q - K], !W) return J;
    }
    let G = J, H = W.split("/");
    for (let z of H) if (z) J = _._`${J}${(0, _.getProperty)((0, E1.unescapeJsonPointer)(z))}`, G = _._`${G} && ${J}`;
    return G;
    function B(z, K) {
      return `Cannot access ${z} ${K} levels up, current level is ${Q}`;
    }
  }
  h3.getData = g3;
});
var v9 = P((l3) => {
  Object.defineProperty(l3, "__esModule", { value: true });
  class u3 extends Error {
    constructor(X) {
      super("validation failed");
      this.errors = X, this.ajv = this.validation = true;
    }
  }
  l3.default = u3;
});
var nX = P((c3) => {
  Object.defineProperty(c3, "__esModule", { value: true });
  var EY = cX();
  class m3 extends Error {
    constructor(X, Q, $, Y) {
      super(Y || `can't resolve reference ${$} from id ${Q}`);
      this.missingRef = (0, EY.resolveUrl)(X, Q, $), this.missingSchema = (0, EY.normalizeId)((0, EY.getFullPath)(X, this.missingRef));
    }
  }
  c3.default = m3;
});
var _9 = P((i3) => {
  Object.defineProperty(i3, "__esModule", { value: true });
  i3.resolveSchema = i3.getCompilingSchema = i3.resolveRef = i3.compileSchema = i3.SchemaEnv = void 0;
  var X1 = c(), _A = v9(), B6 = R1(), Q1 = cX(), p3 = e(), xA = iX();
  class rX {
    constructor(X) {
      var Q;
      this.refs = {}, this.dynamicAnchors = {};
      let $;
      if (typeof X.schema == "object") $ = X.schema;
      this.schema = X.schema, this.schemaId = X.schemaId, this.root = X.root || this, this.baseId = (Q = X.baseId) !== null && Q !== void 0 ? Q : (0, Q1.normalizeId)($ === null || $ === void 0 ? void 0 : $[X.schemaId || "$id"]), this.schemaPath = X.schemaPath, this.localRefs = X.localRefs, this.meta = X.meta, this.$async = $ === null || $ === void 0 ? void 0 : $.$async, this.refs = {};
    }
  }
  i3.SchemaEnv = rX;
  function bY(X) {
    let Q = d3.call(this, X);
    if (Q) return Q;
    let $ = (0, Q1.getFullPath)(this.opts.uriResolver, X.root.baseId), { es5: Y, lines: W } = this.opts.code, { ownProperties: J } = this.opts, G = new X1.CodeGen(this.scope, { es5: Y, lines: W, ownProperties: J }), H;
    if (X.$async) H = G.scopeValue("Error", { ref: _A.default, code: X1._`require("ajv/dist/runtime/validation_error").default` });
    let B = G.scopeName("validate");
    X.validateName = B;
    let z = { gen: G, allErrors: this.opts.allErrors, data: B6.default.data, parentData: B6.default.parentData, parentDataProperty: B6.default.parentDataProperty, dataNames: [B6.default.data], dataPathArr: [X1.nil], dataLevel: 0, dataTypes: [], definedProperties: /* @__PURE__ */ new Set(), topSchemaRef: G.scopeValue("schema", this.opts.code.source === true ? { ref: X.schema, code: (0, X1.stringify)(X.schema) } : { ref: X.schema }), validateName: B, ValidationError: H, schema: X.schema, schemaEnv: X, rootId: $, baseId: X.baseId || $, schemaPath: X1.nil, errSchemaPath: X.schemaPath || (this.opts.jtd ? "" : "#"), errorPath: X1._`""`, opts: this.opts, self: this }, K;
    try {
      this._compilations.add(X), (0, xA.validateFunctionCode)(z), G.optimize(this.opts.code.optimize);
      let V = G.toString();
      if (K = `${G.scopeRefs(B6.default.scope)}return ${V}`, this.opts.code.process) K = this.opts.code.process(K, X);
      let U = Function(`${B6.default.self}`, `${B6.default.scope}`, K)(this, this.scope.get());
      if (this.scope.value(B, { ref: U }), U.errors = null, U.schema = X.schema, U.schemaEnv = X, X.$async) U.$async = true;
      if (this.opts.code.source === true) U.source = { validateName: B, validateCode: V, scopeValues: G._values };
      if (this.opts.unevaluated) {
        let { props: F, items: q } = z;
        if (U.evaluated = { props: F instanceof X1.Name ? void 0 : F, items: q instanceof X1.Name ? void 0 : q, dynamicProps: F instanceof X1.Name, dynamicItems: q instanceof X1.Name }, U.source) U.source.evaluated = (0, X1.stringify)(U.evaluated);
      }
      return X.validate = U, X;
    } catch (V) {
      if (delete X.validate, delete X.validateName, K) this.logger.error("Error compiling schema, function code:", K);
      throw V;
    } finally {
      this._compilations.delete(X);
    }
  }
  i3.compileSchema = bY;
  function yA(X, Q, $) {
    var Y;
    $ = (0, Q1.resolveUrl)(this.opts.uriResolver, Q, $);
    let W = X.refs[$];
    if (W) return W;
    let J = fA.call(this, X, $);
    if (J === void 0) {
      let G = (Y = X.localRefs) === null || Y === void 0 ? void 0 : Y[$], { schemaId: H } = this.opts;
      if (G) J = new rX({ schema: G, schemaId: H, root: X, baseId: Q });
    }
    if (J === void 0) return;
    return X.refs[$] = gA.call(this, J);
  }
  i3.resolveRef = yA;
  function gA(X) {
    if ((0, Q1.inlineRef)(X.schema, this.opts.inlineRefs)) return X.schema;
    return X.validate ? X : bY.call(this, X);
  }
  function d3(X) {
    for (let Q of this._compilations) if (hA(Q, X)) return Q;
  }
  i3.getCompilingSchema = d3;
  function hA(X, Q) {
    return X.schema === Q.schema && X.root === Q.root && X.baseId === Q.baseId;
  }
  function fA(X, Q) {
    let $;
    while (typeof ($ = this.refs[Q]) == "string") Q = $;
    return $ || this.schemas[Q] || T9.call(this, X, Q);
  }
  function T9(X, Q) {
    let $ = this.opts.uriResolver.parse(Q), Y = (0, Q1._getFullPath)(this.opts.uriResolver, $), W = (0, Q1.getFullPath)(this.opts.uriResolver, X.baseId, void 0);
    if (Object.keys(X.schema).length > 0 && Y === W) return IY.call(this, $, X);
    let J = (0, Q1.normalizeId)(Y), G = this.refs[J] || this.schemas[J];
    if (typeof G == "string") {
      let H = T9.call(this, X, G);
      if (typeof (H === null || H === void 0 ? void 0 : H.schema) !== "object") return;
      return IY.call(this, $, H);
    }
    if (typeof (G === null || G === void 0 ? void 0 : G.schema) !== "object") return;
    if (!G.validate) bY.call(this, G);
    if (J === (0, Q1.normalizeId)(Q)) {
      let { schema: H } = G, { schemaId: B } = this.opts, z = H[B];
      if (z) W = (0, Q1.resolveUrl)(this.opts.uriResolver, W, z);
      return new rX({ schema: H, schemaId: B, root: X, baseId: W });
    }
    return IY.call(this, $, G);
  }
  i3.resolveSchema = T9;
  var uA = /* @__PURE__ */ new Set(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
  function IY(X, { baseId: Q, schema: $, root: Y }) {
    var W;
    if (((W = X.fragment) === null || W === void 0 ? void 0 : W[0]) !== "/") return;
    for (let H of X.fragment.slice(1).split("/")) {
      if (typeof $ === "boolean") return;
      let B = $[(0, p3.unescapeFragment)(H)];
      if (B === void 0) return;
      $ = B;
      let z = typeof $ === "object" && $[this.opts.schemaId];
      if (!uA.has(H) && z) Q = (0, Q1.resolveUrl)(this.opts.uriResolver, Q, z);
    }
    let J;
    if (typeof $ != "boolean" && $.$ref && !(0, p3.schemaHasRulesButRef)($, this.RULES)) {
      let H = (0, Q1.resolveUrl)(this.opts.uriResolver, Q, $.$ref);
      J = T9.call(this, Y, H);
    }
    let { schemaId: G } = this.opts;
    if (J = J || new rX({ schema: $, schemaId: G, root: Y, baseId: Q }), J.schema !== J.root.schema) return J;
    return;
  }
});
var r3 = P((av, dA) => {
  dA.exports = { $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", description: "Meta-schema for $data reference (JSON AnySchema extension proposal)", type: "object", required: ["$data"], properties: { $data: { type: "string", anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }] } }, additionalProperties: false };
});
var t3 = P((sv, o3) => {
  var iA = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, a: 10, A: 10, b: 11, B: 11, c: 12, C: 12, d: 13, D: 13, e: 14, E: 14, f: 15, F: 15 };
  o3.exports = { HEX: iA };
});
var WH = P((ev, YH) => {
  var { HEX: nA } = t3(), rA = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;
  function XH(X) {
    if ($H(X, ".") < 3) return { host: X, isIPV4: false };
    let Q = X.match(rA) || [], [$] = Q;
    if ($) return { host: tA($, "."), isIPV4: true };
    else return { host: X, isIPV4: false };
  }
  function PY(X, Q = false) {
    let $ = "", Y = true;
    for (let W of X) {
      if (nA[W] === void 0) return;
      if (W !== "0" && Y === true) Y = false;
      if (!Y) $ += W;
    }
    if (Q && $.length === 0) $ = "0";
    return $;
  }
  function oA(X) {
    let Q = 0, $ = { error: false, address: "", zone: "" }, Y = [], W = [], J = false, G = false, H = false;
    function B() {
      if (W.length) {
        if (J === false) {
          let z = PY(W);
          if (z !== void 0) Y.push(z);
          else return $.error = true, false;
        }
        W.length = 0;
      }
      return true;
    }
    for (let z = 0; z < X.length; z++) {
      let K = X[z];
      if (K === "[" || K === "]") continue;
      if (K === ":") {
        if (G === true) H = true;
        if (!B()) break;
        if (Q++, Y.push(":"), Q > 7) {
          $.error = true;
          break;
        }
        if (z - 1 >= 0 && X[z - 1] === ":") G = true;
        continue;
      } else if (K === "%") {
        if (!B()) break;
        J = true;
      } else {
        W.push(K);
        continue;
      }
    }
    if (W.length) if (J) $.zone = W.join("");
    else if (H) Y.push(W.join(""));
    else Y.push(PY(W));
    return $.address = Y.join(""), $;
  }
  function QH(X) {
    if ($H(X, ":") < 2) return { host: X, isIPV6: false };
    let Q = oA(X);
    if (!Q.error) {
      let { address: $, address: Y } = Q;
      if (Q.zone) $ += "%" + Q.zone, Y += "%25" + Q.zone;
      return { host: $, escapedHost: Y, isIPV6: true };
    } else return { host: X, isIPV6: false };
  }
  function tA(X, Q) {
    let $ = "", Y = true, W = X.length;
    for (let J = 0; J < W; J++) {
      let G = X[J];
      if (G === "0" && Y) {
        if (J + 1 <= W && X[J + 1] === Q || J + 1 === W) $ += G, Y = false;
      } else {
        if (G === Q) Y = true;
        else Y = false;
        $ += G;
      }
    }
    return $;
  }
  function $H(X, Q) {
    let $ = 0;
    for (let Y = 0; Y < X.length; Y++) if (X[Y] === Q) $++;
    return $;
  }
  var a3 = /^\.\.?\//u, s3 = /^\/\.(?:\/|$)/u, e3 = /^\/\.\.(?:\/|$)/u, aA = /^\/?(?:.|\n)*?(?=\/|$)/u;
  function sA(X) {
    let Q = [];
    while (X.length) if (X.match(a3)) X = X.replace(a3, "");
    else if (X.match(s3)) X = X.replace(s3, "/");
    else if (X.match(e3)) X = X.replace(e3, "/"), Q.pop();
    else if (X === "." || X === "..") X = "";
    else {
      let $ = X.match(aA);
      if ($) {
        let Y = $[0];
        X = X.slice(Y.length), Q.push(Y);
      } else throw Error("Unexpected dot segment condition");
    }
    return Q.join("");
  }
  function eA(X, Q) {
    let $ = Q !== true ? escape : unescape;
    if (X.scheme !== void 0) X.scheme = $(X.scheme);
    if (X.userinfo !== void 0) X.userinfo = $(X.userinfo);
    if (X.host !== void 0) X.host = $(X.host);
    if (X.path !== void 0) X.path = $(X.path);
    if (X.query !== void 0) X.query = $(X.query);
    if (X.fragment !== void 0) X.fragment = $(X.fragment);
    return X;
  }
  function Xw(X) {
    let Q = [];
    if (X.userinfo !== void 0) Q.push(X.userinfo), Q.push("@");
    if (X.host !== void 0) {
      let $ = unescape(X.host), Y = XH($);
      if (Y.isIPV4) $ = Y.host;
      else {
        let W = QH(Y.host);
        if (W.isIPV6 === true) $ = `[${W.escapedHost}]`;
        else $ = X.host;
      }
      Q.push($);
    }
    if (typeof X.port === "number" || typeof X.port === "string") Q.push(":"), Q.push(String(X.port));
    return Q.length ? Q.join("") : void 0;
  }
  YH.exports = { recomposeAuthority: Xw, normalizeComponentEncoding: eA, removeDotSegments: sA, normalizeIPv4: XH, normalizeIPv6: QH, stringArrayToHexStripped: PY };
});
var KH = P((XT, zH) => {
  var Qw = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu, $w = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
  function JH(X) {
    return typeof X.secure === "boolean" ? X.secure : String(X.scheme).toLowerCase() === "wss";
  }
  function GH(X) {
    if (!X.host) X.error = X.error || "HTTP URIs must have a host.";
    return X;
  }
  function HH(X) {
    let Q = String(X.scheme).toLowerCase() === "https";
    if (X.port === (Q ? 443 : 80) || X.port === "") X.port = void 0;
    if (!X.path) X.path = "/";
    return X;
  }
  function Yw(X) {
    return X.secure = JH(X), X.resourceName = (X.path || "/") + (X.query ? "?" + X.query : ""), X.path = void 0, X.query = void 0, X;
  }
  function Ww(X) {
    if (X.port === (JH(X) ? 443 : 80) || X.port === "") X.port = void 0;
    if (typeof X.secure === "boolean") X.scheme = X.secure ? "wss" : "ws", X.secure = void 0;
    if (X.resourceName) {
      let [Q, $] = X.resourceName.split("?");
      X.path = Q && Q !== "/" ? Q : void 0, X.query = $, X.resourceName = void 0;
    }
    return X.fragment = void 0, X;
  }
  function Jw(X, Q) {
    if (!X.path) return X.error = "URN can not be parsed", X;
    let $ = X.path.match($w);
    if ($) {
      let Y = Q.scheme || X.scheme || "urn";
      X.nid = $[1].toLowerCase(), X.nss = $[2];
      let W = `${Y}:${Q.nid || X.nid}`, J = SY[W];
      if (X.path = void 0, J) X = J.parse(X, Q);
    } else X.error = X.error || "URN can not be parsed.";
    return X;
  }
  function Gw(X, Q) {
    let $ = Q.scheme || X.scheme || "urn", Y = X.nid.toLowerCase(), W = `${$}:${Q.nid || Y}`, J = SY[W];
    if (J) X = J.serialize(X, Q);
    let G = X, H = X.nss;
    return G.path = `${Y || Q.nid}:${H}`, Q.skipEscape = true, G;
  }
  function Hw(X, Q) {
    let $ = X;
    if ($.uuid = $.nss, $.nss = void 0, !Q.tolerant && (!$.uuid || !Qw.test($.uuid))) $.error = $.error || "UUID is not valid.";
    return $;
  }
  function Bw(X) {
    let Q = X;
    return Q.nss = (X.uuid || "").toLowerCase(), Q;
  }
  var BH = { scheme: "http", domainHost: true, parse: GH, serialize: HH }, zw = { scheme: "https", domainHost: BH.domainHost, parse: GH, serialize: HH }, x9 = { scheme: "ws", domainHost: true, parse: Yw, serialize: Ww }, Kw = { scheme: "wss", domainHost: x9.domainHost, parse: x9.parse, serialize: x9.serialize }, Uw = { scheme: "urn", parse: Jw, serialize: Gw, skipNormalize: true }, Vw = { scheme: "urn:uuid", parse: Hw, serialize: Bw, skipNormalize: true }, SY = { http: BH, https: zw, ws: x9, wss: Kw, urn: Uw, "urn:uuid": Vw };
  zH.exports = SY;
});
var VH = P((QT, g9) => {
  var { normalizeIPv6: Lw, normalizeIPv4: qw, removeDotSegments: oX, recomposeAuthority: Fw, normalizeComponentEncoding: y9 } = WH(), ZY = KH();
  function Nw(X, Q) {
    if (typeof X === "string") X = V1(I1(X, Q), Q);
    else if (typeof X === "object") X = I1(V1(X, Q), Q);
    return X;
  }
  function Ow(X, Q, $) {
    let Y = Object.assign({ scheme: "null" }, $), W = UH(I1(X, Y), I1(Q, Y), Y, true);
    return V1(W, { ...Y, skipEscape: true });
  }
  function UH(X, Q, $, Y) {
    let W = {};
    if (!Y) X = I1(V1(X, $), $), Q = I1(V1(Q, $), $);
    if ($ = $ || {}, !$.tolerant && Q.scheme) W.scheme = Q.scheme, W.userinfo = Q.userinfo, W.host = Q.host, W.port = Q.port, W.path = oX(Q.path || ""), W.query = Q.query;
    else {
      if (Q.userinfo !== void 0 || Q.host !== void 0 || Q.port !== void 0) W.userinfo = Q.userinfo, W.host = Q.host, W.port = Q.port, W.path = oX(Q.path || ""), W.query = Q.query;
      else {
        if (!Q.path) if (W.path = X.path, Q.query !== void 0) W.query = Q.query;
        else W.query = X.query;
        else {
          if (Q.path.charAt(0) === "/") W.path = oX(Q.path);
          else {
            if ((X.userinfo !== void 0 || X.host !== void 0 || X.port !== void 0) && !X.path) W.path = "/" + Q.path;
            else if (!X.path) W.path = Q.path;
            else W.path = X.path.slice(0, X.path.lastIndexOf("/") + 1) + Q.path;
            W.path = oX(W.path);
          }
          W.query = Q.query;
        }
        W.userinfo = X.userinfo, W.host = X.host, W.port = X.port;
      }
      W.scheme = X.scheme;
    }
    return W.fragment = Q.fragment, W;
  }
  function Dw(X, Q, $) {
    if (typeof X === "string") X = unescape(X), X = V1(y9(I1(X, $), true), { ...$, skipEscape: true });
    else if (typeof X === "object") X = V1(y9(X, true), { ...$, skipEscape: true });
    if (typeof Q === "string") Q = unescape(Q), Q = V1(y9(I1(Q, $), true), { ...$, skipEscape: true });
    else if (typeof Q === "object") Q = V1(y9(Q, true), { ...$, skipEscape: true });
    return X.toLowerCase() === Q.toLowerCase();
  }
  function V1(X, Q) {
    let $ = { host: X.host, scheme: X.scheme, userinfo: X.userinfo, port: X.port, path: X.path, query: X.query, nid: X.nid, nss: X.nss, uuid: X.uuid, fragment: X.fragment, reference: X.reference, resourceName: X.resourceName, secure: X.secure, error: "" }, Y = Object.assign({}, Q), W = [], J = ZY[(Y.scheme || $.scheme || "").toLowerCase()];
    if (J && J.serialize) J.serialize($, Y);
    if ($.path !== void 0) if (!Y.skipEscape) {
      if ($.path = escape($.path), $.scheme !== void 0) $.path = $.path.split("%3A").join(":");
    } else $.path = unescape($.path);
    if (Y.reference !== "suffix" && $.scheme) W.push($.scheme, ":");
    let G = Fw($);
    if (G !== void 0) {
      if (Y.reference !== "suffix") W.push("//");
      if (W.push(G), $.path && $.path.charAt(0) !== "/") W.push("/");
    }
    if ($.path !== void 0) {
      let H = $.path;
      if (!Y.absolutePath && (!J || !J.absolutePath)) H = oX(H);
      if (G === void 0) H = H.replace(/^\/\//u, "/%2F");
      W.push(H);
    }
    if ($.query !== void 0) W.push("?", $.query);
    if ($.fragment !== void 0) W.push("#", $.fragment);
    return W.join("");
  }
  var Aw = Array.from({ length: 127 }, (X, Q) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(Q)));
  function ww(X) {
    let Q = 0;
    for (let $ = 0, Y = X.length; $ < Y; ++$) if (Q = X.charCodeAt($), Q > 126 || Aw[Q]) return true;
    return false;
  }
  var Mw = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
  function I1(X, Q) {
    let $ = Object.assign({}, Q), Y = { scheme: void 0, userinfo: void 0, host: "", port: void 0, path: "", query: void 0, fragment: void 0 }, W = X.indexOf("%") !== -1, J = false;
    if ($.reference === "suffix") X = ($.scheme ? $.scheme + ":" : "") + "//" + X;
    let G = X.match(Mw);
    if (G) {
      if (Y.scheme = G[1], Y.userinfo = G[3], Y.host = G[4], Y.port = parseInt(G[5], 10), Y.path = G[6] || "", Y.query = G[7], Y.fragment = G[8], isNaN(Y.port)) Y.port = G[5];
      if (Y.host) {
        let B = qw(Y.host);
        if (B.isIPV4 === false) {
          let z = Lw(B.host);
          Y.host = z.host.toLowerCase(), J = z.isIPV6;
        } else Y.host = B.host, J = true;
      }
      if (Y.scheme === void 0 && Y.userinfo === void 0 && Y.host === void 0 && Y.port === void 0 && Y.query === void 0 && !Y.path) Y.reference = "same-document";
      else if (Y.scheme === void 0) Y.reference = "relative";
      else if (Y.fragment === void 0) Y.reference = "absolute";
      else Y.reference = "uri";
      if ($.reference && $.reference !== "suffix" && $.reference !== Y.reference) Y.error = Y.error || "URI is not a " + $.reference + " reference.";
      let H = ZY[($.scheme || Y.scheme || "").toLowerCase()];
      if (!$.unicodeSupport && (!H || !H.unicodeSupport)) {
        if (Y.host && ($.domainHost || H && H.domainHost) && J === false && ww(Y.host)) try {
          Y.host = URL.domainToASCII(Y.host.toLowerCase());
        } catch (B) {
          Y.error = Y.error || "Host's domain name can not be converted to ASCII: " + B;
        }
      }
      if (!H || H && !H.skipNormalize) {
        if (W && Y.scheme !== void 0) Y.scheme = unescape(Y.scheme);
        if (W && Y.host !== void 0) Y.host = unescape(Y.host);
        if (Y.path) Y.path = escape(unescape(Y.path));
        if (Y.fragment) Y.fragment = encodeURI(decodeURIComponent(Y.fragment));
      }
      if (H && H.parse) H.parse(Y, $);
    } else Y.error = Y.error || "URI can not be parsed.";
    return Y;
  }
  var CY = { SCHEMES: ZY, normalize: Nw, resolve: Ow, resolveComponents: UH, equal: Dw, serialize: V1, parse: I1 };
  g9.exports = CY;
  g9.exports.default = CY;
  g9.exports.fastUri = CY;
});
var FH = P((qH) => {
  Object.defineProperty(qH, "__esModule", { value: true });
  var LH = VH();
  LH.code = 'require("ajv/dist/runtime/uri").default';
  qH.default = LH;
});
var RH = P((b1) => {
  Object.defineProperty(b1, "__esModule", { value: true });
  b1.CodeGen = b1.Name = b1.nil = b1.stringify = b1.str = b1._ = b1.KeywordCxt = void 0;
  var Rw = iX();
  Object.defineProperty(b1, "KeywordCxt", { enumerable: true, get: function() {
    return Rw.KeywordCxt;
  } });
  var p6 = c();
  Object.defineProperty(b1, "_", { enumerable: true, get: function() {
    return p6._;
  } });
  Object.defineProperty(b1, "str", { enumerable: true, get: function() {
    return p6.str;
  } });
  Object.defineProperty(b1, "stringify", { enumerable: true, get: function() {
    return p6.stringify;
  } });
  Object.defineProperty(b1, "nil", { enumerable: true, get: function() {
    return p6.nil;
  } });
  Object.defineProperty(b1, "Name", { enumerable: true, get: function() {
    return p6.Name;
  } });
  Object.defineProperty(b1, "CodeGen", { enumerable: true, get: function() {
    return p6.CodeGen;
  } });
  var Ew = v9(), wH = nX(), Iw = KY(), tX = _9(), bw = c(), aX = cX(), h9 = mX(), vY = e(), NH = r3(), Pw = FH(), MH = (X, Q) => new RegExp(X, Q);
  MH.code = "new RegExp";
  var Sw = ["removeAdditional", "useDefaults", "coerceTypes"], Zw = /* @__PURE__ */ new Set(["validate", "serialize", "parse", "wrapper", "root", "schema", "keyword", "pattern", "formats", "validate$data", "func", "obj", "Error"]), Cw = { errorDataPath: "", format: "`validateFormats: false` can be used instead.", nullable: '"nullable" keyword is supported by default.', jsonPointers: "Deprecated jsPropertySyntax can be used instead.", extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.", missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.", processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`", sourceCode: "Use option `code: {source: true}`", strictDefaults: "It is default now, see option `strict`.", strictKeywords: "It is default now, see option `strict`.", uniqueItems: '"uniqueItems" keyword is always validated.', unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).", cache: "Map is used as cache, schema object as key.", serialize: "Map is used as cache, schema object as key.", ajvErrors: "It is default now." }, kw = { ignoreKeywordsWithRef: "", jsPropertySyntax: "", unicode: '"minLength"/"maxLength" account for unicode characters by default.' }, OH = 200;
  function vw(X) {
    var Q, $, Y, W, J, G, H, B, z, K, V, L, U, F, q, N, A, M, R, S, C, K0, U0, s, D0;
    let q0 = X.strict, W1 = (Q = X.code) === null || Q === void 0 ? void 0 : Q.optimize, P1 = W1 === true || W1 === void 0 ? 1 : W1 || 0, U6 = (Y = ($ = X.code) === null || $ === void 0 ? void 0 : $.regExp) !== null && Y !== void 0 ? Y : MH, d = (W = X.uriResolver) !== null && W !== void 0 ? W : Pw.default;
    return { strictSchema: (G = (J = X.strictSchema) !== null && J !== void 0 ? J : q0) !== null && G !== void 0 ? G : true, strictNumbers: (B = (H = X.strictNumbers) !== null && H !== void 0 ? H : q0) !== null && B !== void 0 ? B : true, strictTypes: (K = (z = X.strictTypes) !== null && z !== void 0 ? z : q0) !== null && K !== void 0 ? K : "log", strictTuples: (L = (V = X.strictTuples) !== null && V !== void 0 ? V : q0) !== null && L !== void 0 ? L : "log", strictRequired: (F = (U = X.strictRequired) !== null && U !== void 0 ? U : q0) !== null && F !== void 0 ? F : false, code: X.code ? { ...X.code, optimize: P1, regExp: U6 } : { optimize: P1, regExp: U6 }, loopRequired: (q = X.loopRequired) !== null && q !== void 0 ? q : OH, loopEnum: (N = X.loopEnum) !== null && N !== void 0 ? N : OH, meta: (A = X.meta) !== null && A !== void 0 ? A : true, messages: (M = X.messages) !== null && M !== void 0 ? M : true, inlineRefs: (R = X.inlineRefs) !== null && R !== void 0 ? R : true, schemaId: (S = X.schemaId) !== null && S !== void 0 ? S : "$id", addUsedSchema: (C = X.addUsedSchema) !== null && C !== void 0 ? C : true, validateSchema: (K0 = X.validateSchema) !== null && K0 !== void 0 ? K0 : true, validateFormats: (U0 = X.validateFormats) !== null && U0 !== void 0 ? U0 : true, unicodeRegExp: (s = X.unicodeRegExp) !== null && s !== void 0 ? s : true, int32range: (D0 = X.int32range) !== null && D0 !== void 0 ? D0 : true, uriResolver: d };
  }
  class f9 {
    constructor(X = {}) {
      this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), X = this.opts = { ...X, ...vw(X) };
      let { es5: Q, lines: $ } = this.opts.code;
      this.scope = new bw.ValueScope({ scope: {}, prefixes: Zw, es5: Q, lines: $ }), this.logger = hw(X.logger);
      let Y = X.validateFormats;
      if (X.validateFormats = false, this.RULES = (0, Iw.getRules)(), DH.call(this, Cw, X, "NOT SUPPORTED"), DH.call(this, kw, X, "DEPRECATED", "warn"), this._metaOpts = yw.call(this), X.formats) _w.call(this);
      if (this._addVocabularies(), this._addDefaultMetaSchema(), X.keywords) xw.call(this, X.keywords);
      if (typeof X.meta == "object") this.addMetaSchema(X.meta);
      Tw.call(this), X.validateFormats = Y;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      let { $data: X, meta: Q, schemaId: $ } = this.opts, Y = NH;
      if ($ === "id") Y = { ...NH }, Y.id = Y.$id, delete Y.$id;
      if (Q && X) this.addMetaSchema(Y, Y[$], false);
    }
    defaultMeta() {
      let { meta: X, schemaId: Q } = this.opts;
      return this.opts.defaultMeta = typeof X == "object" ? X[Q] || X : void 0;
    }
    validate(X, Q) {
      let $;
      if (typeof X == "string") {
        if ($ = this.getSchema(X), !$) throw Error(`no schema with key or ref "${X}"`);
      } else $ = this.compile(X);
      let Y = $(Q);
      if (!("$async" in $)) this.errors = $.errors;
      return Y;
    }
    compile(X, Q) {
      let $ = this._addSchema(X, Q);
      return $.validate || this._compileSchemaEnv($);
    }
    compileAsync(X, Q) {
      if (typeof this.opts.loadSchema != "function") throw Error("options.loadSchema should be a function");
      let { loadSchema: $ } = this.opts;
      return Y.call(this, X, Q);
      async function Y(z, K) {
        await W.call(this, z.$schema);
        let V = this._addSchema(z, K);
        return V.validate || J.call(this, V);
      }
      async function W(z) {
        if (z && !this.getSchema(z)) await Y.call(this, { $ref: z }, true);
      }
      async function J(z) {
        try {
          return this._compileSchemaEnv(z);
        } catch (K) {
          if (!(K instanceof wH.default)) throw K;
          return G.call(this, K), await H.call(this, K.missingSchema), J.call(this, z);
        }
      }
      function G({ missingSchema: z, missingRef: K }) {
        if (this.refs[z]) throw Error(`AnySchema ${z} is loaded but ${K} cannot be resolved`);
      }
      async function H(z) {
        let K = await B.call(this, z);
        if (!this.refs[z]) await W.call(this, K.$schema);
        if (!this.refs[z]) this.addSchema(K, z, Q);
      }
      async function B(z) {
        let K = this._loading[z];
        if (K) return K;
        try {
          return await (this._loading[z] = $(z));
        } finally {
          delete this._loading[z];
        }
      }
    }
    addSchema(X, Q, $, Y = this.opts.validateSchema) {
      if (Array.isArray(X)) {
        for (let J of X) this.addSchema(J, void 0, $, Y);
        return this;
      }
      let W;
      if (typeof X === "object") {
        let { schemaId: J } = this.opts;
        if (W = X[J], W !== void 0 && typeof W != "string") throw Error(`schema ${J} must be string`);
      }
      return Q = (0, aX.normalizeId)(Q || W), this._checkUnique(Q), this.schemas[Q] = this._addSchema(X, $, Q, Y, true), this;
    }
    addMetaSchema(X, Q, $ = this.opts.validateSchema) {
      return this.addSchema(X, Q, true, $), this;
    }
    validateSchema(X, Q) {
      if (typeof X == "boolean") return true;
      let $;
      if ($ = X.$schema, $ !== void 0 && typeof $ != "string") throw Error("$schema must be a string");
      if ($ = $ || this.opts.defaultMeta || this.defaultMeta(), !$) return this.logger.warn("meta-schema not available"), this.errors = null, true;
      let Y = this.validate($, X);
      if (!Y && Q) {
        let W = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log") this.logger.error(W);
        else throw Error(W);
      }
      return Y;
    }
    getSchema(X) {
      let Q;
      while (typeof (Q = AH.call(this, X)) == "string") X = Q;
      if (Q === void 0) {
        let { schemaId: $ } = this.opts, Y = new tX.SchemaEnv({ schema: {}, schemaId: $ });
        if (Q = tX.resolveSchema.call(this, Y, X), !Q) return;
        this.refs[X] = Q;
      }
      return Q.validate || this._compileSchemaEnv(Q);
    }
    removeSchema(X) {
      if (X instanceof RegExp) return this._removeAllSchemas(this.schemas, X), this._removeAllSchemas(this.refs, X), this;
      switch (typeof X) {
        case "undefined":
          return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
        case "string": {
          let Q = AH.call(this, X);
          if (typeof Q == "object") this._cache.delete(Q.schema);
          return delete this.schemas[X], delete this.refs[X], this;
        }
        case "object": {
          let Q = X;
          this._cache.delete(Q);
          let $ = X[this.opts.schemaId];
          if ($) $ = (0, aX.normalizeId)($), delete this.schemas[$], delete this.refs[$];
          return this;
        }
        default:
          throw Error("ajv.removeSchema: invalid parameter");
      }
    }
    addVocabulary(X) {
      for (let Q of X) this.addKeyword(Q);
      return this;
    }
    addKeyword(X, Q) {
      let $;
      if (typeof X == "string") {
        if ($ = X, typeof Q == "object") this.logger.warn("these parameters are deprecated, see docs for addKeyword"), Q.keyword = $;
      } else if (typeof X == "object" && Q === void 0) {
        if (Q = X, $ = Q.keyword, Array.isArray($) && !$.length) throw Error("addKeywords: keyword must be string or non-empty array");
      } else throw Error("invalid addKeywords parameters");
      if (uw.call(this, $, Q), !Q) return (0, vY.eachItem)($, (W) => kY.call(this, W)), this;
      mw.call(this, Q);
      let Y = { ...Q, type: (0, h9.getJSONTypes)(Q.type), schemaType: (0, h9.getJSONTypes)(Q.schemaType) };
      return (0, vY.eachItem)($, Y.type.length === 0 ? (W) => kY.call(this, W, Y) : (W) => Y.type.forEach((J) => kY.call(this, W, Y, J))), this;
    }
    getKeyword(X) {
      let Q = this.RULES.all[X];
      return typeof Q == "object" ? Q.definition : !!Q;
    }
    removeKeyword(X) {
      let { RULES: Q } = this;
      delete Q.keywords[X], delete Q.all[X];
      for (let $ of Q.rules) {
        let Y = $.rules.findIndex((W) => W.keyword === X);
        if (Y >= 0) $.rules.splice(Y, 1);
      }
      return this;
    }
    addFormat(X, Q) {
      if (typeof Q == "string") Q = new RegExp(Q);
      return this.formats[X] = Q, this;
    }
    errorsText(X = this.errors, { separator: Q = ", ", dataVar: $ = "data" } = {}) {
      if (!X || X.length === 0) return "No errors";
      return X.map((Y) => `${$}${Y.instancePath} ${Y.message}`).reduce((Y, W) => Y + Q + W);
    }
    $dataMetaSchema(X, Q) {
      let $ = this.RULES.all;
      X = JSON.parse(JSON.stringify(X));
      for (let Y of Q) {
        let W = Y.split("/").slice(1), J = X;
        for (let G of W) J = J[G];
        for (let G in $) {
          let H = $[G];
          if (typeof H != "object") continue;
          let { $data: B } = H.definition, z = J[G];
          if (B && z) J[G] = jH(z);
        }
      }
      return X;
    }
    _removeAllSchemas(X, Q) {
      for (let $ in X) {
        let Y = X[$];
        if (!Q || Q.test($)) {
          if (typeof Y == "string") delete X[$];
          else if (Y && !Y.meta) this._cache.delete(Y.schema), delete X[$];
        }
      }
    }
    _addSchema(X, Q, $, Y = this.opts.validateSchema, W = this.opts.addUsedSchema) {
      let J, { schemaId: G } = this.opts;
      if (typeof X == "object") J = X[G];
      else if (this.opts.jtd) throw Error("schema must be object");
      else if (typeof X != "boolean") throw Error("schema must be object or boolean");
      let H = this._cache.get(X);
      if (H !== void 0) return H;
      $ = (0, aX.normalizeId)(J || $);
      let B = aX.getSchemaRefs.call(this, X, $);
      if (H = new tX.SchemaEnv({ schema: X, schemaId: G, meta: Q, baseId: $, localRefs: B }), this._cache.set(H.schema, H), W && !$.startsWith("#")) {
        if ($) this._checkUnique($);
        this.refs[$] = H;
      }
      if (Y) this.validateSchema(X, true);
      return H;
    }
    _checkUnique(X) {
      if (this.schemas[X] || this.refs[X]) throw Error(`schema with key or id "${X}" already exists`);
    }
    _compileSchemaEnv(X) {
      if (X.meta) this._compileMetaSchema(X);
      else tX.compileSchema.call(this, X);
      if (!X.validate) throw Error("ajv implementation error");
      return X.validate;
    }
    _compileMetaSchema(X) {
      let Q = this.opts;
      this.opts = this._metaOpts;
      try {
        tX.compileSchema.call(this, X);
      } finally {
        this.opts = Q;
      }
    }
  }
  f9.ValidationError = Ew.default;
  f9.MissingRefError = wH.default;
  b1.default = f9;
  function DH(X, Q, $, Y = "error") {
    for (let W in X) {
      let J = W;
      if (J in Q) this.logger[Y](`${$}: option ${W}. ${X[J]}`);
    }
  }
  function AH(X) {
    return X = (0, aX.normalizeId)(X), this.schemas[X] || this.refs[X];
  }
  function Tw() {
    let X = this.opts.schemas;
    if (!X) return;
    if (Array.isArray(X)) this.addSchema(X);
    else for (let Q in X) this.addSchema(X[Q], Q);
  }
  function _w() {
    for (let X in this.opts.formats) {
      let Q = this.opts.formats[X];
      if (Q) this.addFormat(X, Q);
    }
  }
  function xw(X) {
    if (Array.isArray(X)) {
      this.addVocabulary(X);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (let Q in X) {
      let $ = X[Q];
      if (!$.keyword) $.keyword = Q;
      this.addKeyword($);
    }
  }
  function yw() {
    let X = { ...this.opts };
    for (let Q of Sw) delete X[Q];
    return X;
  }
  var gw = { log() {
  }, warn() {
  }, error() {
  } };
  function hw(X) {
    if (X === false) return gw;
    if (X === void 0) return console;
    if (X.log && X.warn && X.error) return X;
    throw Error("logger must implement log, warn and error methods");
  }
  var fw = /^[a-z_$][a-z0-9_$:-]*$/i;
  function uw(X, Q) {
    let { RULES: $ } = this;
    if ((0, vY.eachItem)(X, (Y) => {
      if ($.keywords[Y]) throw Error(`Keyword ${Y} is already defined`);
      if (!fw.test(Y)) throw Error(`Keyword ${Y} has invalid name`);
    }), !Q) return;
    if (Q.$data && !("code" in Q || "validate" in Q)) throw Error('$data keyword must have "code" or "validate" function');
  }
  function kY(X, Q, $) {
    var Y;
    let W = Q === null || Q === void 0 ? void 0 : Q.post;
    if ($ && W) throw Error('keyword with "post" flag cannot have "type"');
    let { RULES: J } = this, G = W ? J.post : J.rules.find(({ type: B }) => B === $);
    if (!G) G = { type: $, rules: [] }, J.rules.push(G);
    if (J.keywords[X] = true, !Q) return;
    let H = { keyword: X, definition: { ...Q, type: (0, h9.getJSONTypes)(Q.type), schemaType: (0, h9.getJSONTypes)(Q.schemaType) } };
    if (Q.before) lw.call(this, G, H, Q.before);
    else G.rules.push(H);
    J.all[X] = H, (Y = Q.implements) === null || Y === void 0 || Y.forEach((B) => this.addKeyword(B));
  }
  function lw(X, Q, $) {
    let Y = X.rules.findIndex((W) => W.keyword === $);
    if (Y >= 0) X.rules.splice(Y, 0, Q);
    else X.rules.push(Q), this.logger.warn(`rule ${$} is not defined`);
  }
  function mw(X) {
    let { metaSchema: Q } = X;
    if (Q === void 0) return;
    if (X.$data && this.opts.$data) Q = jH(Q);
    X.validateSchema = this.compile(Q, true);
  }
  var cw = { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" };
  function jH(X) {
    return { anyOf: [X, cw] };
  }
});
var IH = P((EH) => {
  Object.defineProperty(EH, "__esModule", { value: true });
  var iw = { keyword: "id", code() {
    throw Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  } };
  EH.default = iw;
});
var kH = P((ZH) => {
  Object.defineProperty(ZH, "__esModule", { value: true });
  ZH.callRef = ZH.getValidate = void 0;
  var rw = nX(), bH = d0(), g0 = c(), d6 = R1(), PH = _9(), u9 = e(), ow = { keyword: "$ref", schemaType: "string", code(X) {
    let { gen: Q, schema: $, it: Y } = X, { baseId: W, schemaEnv: J, validateName: G, opts: H, self: B } = Y, { root: z } = J;
    if (($ === "#" || $ === "#/") && W === z.baseId) return V();
    let K = PH.resolveRef.call(B, z, W, $);
    if (K === void 0) throw new rw.default(Y.opts.uriResolver, W, $);
    if (K instanceof PH.SchemaEnv) return L(K);
    return U(K);
    function V() {
      if (J === z) return l9(X, G, J, J.$async);
      let F = Q.scopeValue("root", { ref: z });
      return l9(X, g0._`${F}.validate`, z, z.$async);
    }
    function L(F) {
      let q = SH(X, F);
      l9(X, q, F, F.$async);
    }
    function U(F) {
      let q = Q.scopeValue("schema", H.code.source === true ? { ref: F, code: (0, g0.stringify)(F) } : { ref: F }), N = Q.name("valid"), A = X.subschema({ schema: F, dataTypes: [], schemaPath: g0.nil, topSchemaRef: q, errSchemaPath: $ }, N);
      X.mergeEvaluated(A), X.ok(N);
    }
  } };
  function SH(X, Q) {
    let { gen: $ } = X;
    return Q.validate ? $.scopeValue("validate", { ref: Q.validate }) : g0._`${$.scopeValue("wrapper", { ref: Q })}.validate`;
  }
  ZH.getValidate = SH;
  function l9(X, Q, $, Y) {
    let { gen: W, it: J } = X, { allErrors: G, schemaEnv: H, opts: B } = J, z = B.passContext ? d6.default.this : g0.nil;
    if (Y) K();
    else V();
    function K() {
      if (!H.$async) throw Error("async schema referenced by sync schema");
      let F = W.let("valid");
      W.try(() => {
        if (W.code(g0._`await ${(0, bH.callValidateCode)(X, Q, z)}`), U(Q), !G) W.assign(F, true);
      }, (q) => {
        if (W.if(g0._`!(${q} instanceof ${J.ValidationError})`, () => W.throw(q)), L(q), !G) W.assign(F, false);
      }), X.ok(F);
    }
    function V() {
      X.result((0, bH.callValidateCode)(X, Q, z), () => U(Q), () => L(Q));
    }
    function L(F) {
      let q = g0._`${F}.errors`;
      W.assign(d6.default.vErrors, g0._`${d6.default.vErrors} === null ? ${q} : ${d6.default.vErrors}.concat(${q})`), W.assign(d6.default.errors, g0._`${d6.default.vErrors}.length`);
    }
    function U(F) {
      var q;
      if (!J.opts.unevaluated) return;
      let N = (q = $ === null || $ === void 0 ? void 0 : $.validate) === null || q === void 0 ? void 0 : q.evaluated;
      if (J.props !== true) if (N && !N.dynamicProps) {
        if (N.props !== void 0) J.props = u9.mergeEvaluated.props(W, N.props, J.props);
      } else {
        let A = W.var("props", g0._`${F}.evaluated.props`);
        J.props = u9.mergeEvaluated.props(W, A, J.props, g0.Name);
      }
      if (J.items !== true) if (N && !N.dynamicItems) {
        if (N.items !== void 0) J.items = u9.mergeEvaluated.items(W, N.items, J.items);
      } else {
        let A = W.var("items", g0._`${F}.evaluated.items`);
        J.items = u9.mergeEvaluated.items(W, A, J.items, g0.Name);
      }
    }
  }
  ZH.callRef = l9;
  ZH.default = ow;
});
var TH = P((vH) => {
  Object.defineProperty(vH, "__esModule", { value: true });
  var sw = IH(), ew = kH(), XM = ["$schema", "$id", "$defs", "$vocabulary", { keyword: "$comment" }, "definitions", sw.default, ew.default];
  vH.default = XM;
});
var xH = P((_H) => {
  Object.defineProperty(_H, "__esModule", { value: true });
  var m9 = c(), d1 = m9.operators, c9 = { maximum: { okStr: "<=", ok: d1.LTE, fail: d1.GT }, minimum: { okStr: ">=", ok: d1.GTE, fail: d1.LT }, exclusiveMaximum: { okStr: "<", ok: d1.LT, fail: d1.GTE }, exclusiveMinimum: { okStr: ">", ok: d1.GT, fail: d1.LTE } }, $M = { message: ({ keyword: X, schemaCode: Q }) => m9.str`must be ${c9[X].okStr} ${Q}`, params: ({ keyword: X, schemaCode: Q }) => m9._`{comparison: ${c9[X].okStr}, limit: ${Q}}` }, YM = { keyword: Object.keys(c9), type: "number", schemaType: "number", $data: true, error: $M, code(X) {
    let { keyword: Q, data: $, schemaCode: Y } = X;
    X.fail$data(m9._`${$} ${c9[Q].fail} ${Y} || isNaN(${$})`);
  } };
  _H.default = YM;
});
var gH = P((yH) => {
  Object.defineProperty(yH, "__esModule", { value: true });
  var sX = c(), JM = { message: ({ schemaCode: X }) => sX.str`must be multiple of ${X}`, params: ({ schemaCode: X }) => sX._`{multipleOf: ${X}}` }, GM = { keyword: "multipleOf", type: "number", schemaType: "number", $data: true, error: JM, code(X) {
    let { gen: Q, data: $, schemaCode: Y, it: W } = X, J = W.opts.multipleOfPrecision, G = Q.let("res"), H = J ? sX._`Math.abs(Math.round(${G}) - ${G}) > 1e-${J}` : sX._`${G} !== parseInt(${G})`;
    X.fail$data(sX._`(${Y} === 0 || (${G} = ${$}/${Y}, ${H}))`);
  } };
  yH.default = GM;
});
var uH = P((fH) => {
  Object.defineProperty(fH, "__esModule", { value: true });
  function hH(X) {
    let Q = X.length, $ = 0, Y = 0, W;
    while (Y < Q) if ($++, W = X.charCodeAt(Y++), W >= 55296 && W <= 56319 && Y < Q) {
      if (W = X.charCodeAt(Y), (W & 64512) === 56320) Y++;
    }
    return $;
  }
  fH.default = hH;
  hH.code = 'require("ajv/dist/runtime/ucs2length").default';
});
var mH = P((lH) => {
  Object.defineProperty(lH, "__esModule", { value: true });
  var z6 = c(), zM = e(), KM = uH(), UM = { message({ keyword: X, schemaCode: Q }) {
    let $ = X === "maxLength" ? "more" : "fewer";
    return z6.str`must NOT have ${$} than ${Q} characters`;
  }, params: ({ schemaCode: X }) => z6._`{limit: ${X}}` }, VM = { keyword: ["maxLength", "minLength"], type: "string", schemaType: "number", $data: true, error: UM, code(X) {
    let { keyword: Q, data: $, schemaCode: Y, it: W } = X, J = Q === "maxLength" ? z6.operators.GT : z6.operators.LT, G = W.opts.unicode === false ? z6._`${$}.length` : z6._`${(0, zM.useFunc)(X.gen, KM.default)}(${$})`;
    X.fail$data(z6._`${G} ${J} ${Y}`);
  } };
  lH.default = VM;
});
var pH = P((cH) => {
  Object.defineProperty(cH, "__esModule", { value: true });
  var qM = d0(), p9 = c(), FM = { message: ({ schemaCode: X }) => p9.str`must match pattern "${X}"`, params: ({ schemaCode: X }) => p9._`{pattern: ${X}}` }, NM = { keyword: "pattern", type: "string", schemaType: "string", $data: true, error: FM, code(X) {
    let { data: Q, $data: $, schema: Y, schemaCode: W, it: J } = X, G = J.opts.unicodeRegExp ? "u" : "", H = $ ? p9._`(new RegExp(${W}, ${G}))` : (0, qM.usePattern)(X, Y);
    X.fail$data(p9._`!${H}.test(${Q})`);
  } };
  cH.default = NM;
});
var iH = P((dH) => {
  Object.defineProperty(dH, "__esModule", { value: true });
  var eX = c(), DM = { message({ keyword: X, schemaCode: Q }) {
    let $ = X === "maxProperties" ? "more" : "fewer";
    return eX.str`must NOT have ${$} than ${Q} properties`;
  }, params: ({ schemaCode: X }) => eX._`{limit: ${X}}` }, AM = { keyword: ["maxProperties", "minProperties"], type: "object", schemaType: "number", $data: true, error: DM, code(X) {
    let { keyword: Q, data: $, schemaCode: Y } = X, W = Q === "maxProperties" ? eX.operators.GT : eX.operators.LT;
    X.fail$data(eX._`Object.keys(${$}).length ${W} ${Y}`);
  } };
  dH.default = AM;
});
var rH = P((nH) => {
  Object.defineProperty(nH, "__esModule", { value: true });
  var X4 = d0(), Q4 = c(), MM = e(), jM = { message: ({ params: { missingProperty: X } }) => Q4.str`must have required property '${X}'`, params: ({ params: { missingProperty: X } }) => Q4._`{missingProperty: ${X}}` }, RM = { keyword: "required", type: "object", schemaType: "array", $data: true, error: jM, code(X) {
    let { gen: Q, schema: $, schemaCode: Y, data: W, $data: J, it: G } = X, { opts: H } = G;
    if (!J && $.length === 0) return;
    let B = $.length >= H.loopRequired;
    if (G.allErrors) z();
    else K();
    if (H.strictRequired) {
      let U = X.parentSchema.properties, { definedProperties: F } = X.it;
      for (let q of $) if ((U === null || U === void 0 ? void 0 : U[q]) === void 0 && !F.has(q)) {
        let N = G.schemaEnv.baseId + G.errSchemaPath, A = `required property "${q}" is not defined at "${N}" (strictRequired)`;
        (0, MM.checkStrictMode)(G, A, G.opts.strictRequired);
      }
    }
    function z() {
      if (B || J) X.block$data(Q4.nil, V);
      else for (let U of $) (0, X4.checkReportMissingProp)(X, U);
    }
    function K() {
      let U = Q.let("missing");
      if (B || J) {
        let F = Q.let("valid", true);
        X.block$data(F, () => L(U, F)), X.ok(F);
      } else Q.if((0, X4.checkMissingProp)(X, $, U)), (0, X4.reportMissingProp)(X, U), Q.else();
    }
    function V() {
      Q.forOf("prop", Y, (U) => {
        X.setParams({ missingProperty: U }), Q.if((0, X4.noPropertyInData)(Q, W, U, H.ownProperties), () => X.error());
      });
    }
    function L(U, F) {
      X.setParams({ missingProperty: U }), Q.forOf(U, Y, () => {
        Q.assign(F, (0, X4.propertyInData)(Q, W, U, H.ownProperties)), Q.if((0, Q4.not)(F), () => {
          X.error(), Q.break();
        });
      }, Q4.nil);
    }
  } };
  nH.default = RM;
});
var tH = P((oH) => {
  Object.defineProperty(oH, "__esModule", { value: true });
  var $4 = c(), IM = { message({ keyword: X, schemaCode: Q }) {
    let $ = X === "maxItems" ? "more" : "fewer";
    return $4.str`must NOT have ${$} than ${Q} items`;
  }, params: ({ schemaCode: X }) => $4._`{limit: ${X}}` }, bM = { keyword: ["maxItems", "minItems"], type: "array", schemaType: "number", $data: true, error: IM, code(X) {
    let { keyword: Q, data: $, schemaCode: Y } = X, W = Q === "maxItems" ? $4.operators.GT : $4.operators.LT;
    X.fail$data($4._`${$}.length ${W} ${Y}`);
  } };
  oH.default = bM;
});
var d9 = P((sH) => {
  Object.defineProperty(sH, "__esModule", { value: true });
  var aH = DY();
  aH.code = 'require("ajv/dist/runtime/equal").default';
  sH.default = aH;
});
var XB = P((eH) => {
  Object.defineProperty(eH, "__esModule", { value: true });
  var TY = mX(), E0 = c(), ZM = e(), CM = d9(), kM = { message: ({ params: { i: X, j: Q } }) => E0.str`must NOT have duplicate items (items ## ${Q} and ${X} are identical)`, params: ({ params: { i: X, j: Q } }) => E0._`{i: ${X}, j: ${Q}}` }, vM = { keyword: "uniqueItems", type: "array", schemaType: "boolean", $data: true, error: kM, code(X) {
    let { gen: Q, data: $, $data: Y, schema: W, parentSchema: J, schemaCode: G, it: H } = X;
    if (!Y && !W) return;
    let B = Q.let("valid"), z = J.items ? (0, TY.getSchemaTypes)(J.items) : [];
    X.block$data(B, K, E0._`${G} === false`), X.ok(B);
    function K() {
      let F = Q.let("i", E0._`${$}.length`), q = Q.let("j");
      X.setParams({ i: F, j: q }), Q.assign(B, true), Q.if(E0._`${F} > 1`, () => (V() ? L : U)(F, q));
    }
    function V() {
      return z.length > 0 && !z.some((F) => F === "object" || F === "array");
    }
    function L(F, q) {
      let N = Q.name("item"), A = (0, TY.checkDataTypes)(z, N, H.opts.strictNumbers, TY.DataType.Wrong), M = Q.const("indices", E0._`{}`);
      Q.for(E0._`;${F}--;`, () => {
        if (Q.let(N, E0._`${$}[${F}]`), Q.if(A, E0._`continue`), z.length > 1) Q.if(E0._`typeof ${N} == "string"`, E0._`${N} += "_"`);
        Q.if(E0._`typeof ${M}[${N}] == "number"`, () => {
          Q.assign(q, E0._`${M}[${N}]`), X.error(), Q.assign(B, false).break();
        }).code(E0._`${M}[${N}] = ${F}`);
      });
    }
    function U(F, q) {
      let N = (0, ZM.useFunc)(Q, CM.default), A = Q.name("outer");
      Q.label(A).for(E0._`;${F}--;`, () => Q.for(E0._`${q} = ${F}; ${q}--;`, () => Q.if(E0._`${N}(${$}[${F}], ${$}[${q}])`, () => {
        X.error(), Q.assign(B, false).break(A);
      })));
    }
  } };
  eH.default = vM;
});
var $B = P((QB) => {
  Object.defineProperty(QB, "__esModule", { value: true });
  var _Y = c(), _M = e(), xM = d9(), yM = { message: "must be equal to constant", params: ({ schemaCode: X }) => _Y._`{allowedValue: ${X}}` }, gM = { keyword: "const", $data: true, error: yM, code(X) {
    let { gen: Q, data: $, $data: Y, schemaCode: W, schema: J } = X;
    if (Y || J && typeof J == "object") X.fail$data(_Y._`!${(0, _M.useFunc)(Q, xM.default)}(${$}, ${W})`);
    else X.fail(_Y._`${J} !== ${$}`);
  } };
  QB.default = gM;
});
var WB = P((YB) => {
  Object.defineProperty(YB, "__esModule", { value: true });
  var Y4 = c(), fM = e(), uM = d9(), lM = { message: "must be equal to one of the allowed values", params: ({ schemaCode: X }) => Y4._`{allowedValues: ${X}}` }, mM = { keyword: "enum", schemaType: "array", $data: true, error: lM, code(X) {
    let { gen: Q, data: $, $data: Y, schema: W, schemaCode: J, it: G } = X;
    if (!Y && W.length === 0) throw Error("enum must have non-empty array");
    let H = W.length >= G.opts.loopEnum, B, z = () => B !== null && B !== void 0 ? B : B = (0, fM.useFunc)(Q, uM.default), K;
    if (H || Y) K = Q.let("valid"), X.block$data(K, V);
    else {
      if (!Array.isArray(W)) throw Error("ajv implementation error");
      let U = Q.const("vSchema", J);
      K = (0, Y4.or)(...W.map((F, q) => L(U, q)));
    }
    X.pass(K);
    function V() {
      Q.assign(K, false), Q.forOf("v", J, (U) => Q.if(Y4._`${z()}(${$}, ${U})`, () => Q.assign(K, true).break()));
    }
    function L(U, F) {
      let q = W[F];
      return typeof q === "object" && q !== null ? Y4._`${z()}(${$}, ${U}[${F}])` : Y4._`${$} === ${q}`;
    }
  } };
  YB.default = mM;
});
var GB = P((JB) => {
  Object.defineProperty(JB, "__esModule", { value: true });
  var pM = xH(), dM = gH(), iM = mH(), nM = pH(), rM = iH(), oM = rH(), tM = tH(), aM = XB(), sM = $B(), eM = WB(), Xj = [pM.default, dM.default, iM.default, nM.default, rM.default, oM.default, tM.default, aM.default, { keyword: "type", schemaType: ["string", "array"] }, { keyword: "nullable", schemaType: "boolean" }, sM.default, eM.default];
  JB.default = Xj;
});
var yY = P((BB) => {
  Object.defineProperty(BB, "__esModule", { value: true });
  BB.validateAdditionalItems = void 0;
  var K6 = c(), xY = e(), $j = { message: ({ params: { len: X } }) => K6.str`must NOT have more than ${X} items`, params: ({ params: { len: X } }) => K6._`{limit: ${X}}` }, Yj = { keyword: "additionalItems", type: "array", schemaType: ["boolean", "object"], before: "uniqueItems", error: $j, code(X) {
    let { parentSchema: Q, it: $ } = X, { items: Y } = Q;
    if (!Array.isArray(Y)) {
      (0, xY.checkStrictMode)($, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    HB(X, Y);
  } };
  function HB(X, Q) {
    let { gen: $, schema: Y, data: W, keyword: J, it: G } = X;
    G.items = true;
    let H = $.const("len", K6._`${W}.length`);
    if (Y === false) X.setParams({ len: Q.length }), X.pass(K6._`${H} <= ${Q.length}`);
    else if (typeof Y == "object" && !(0, xY.alwaysValidSchema)(G, Y)) {
      let z = $.var("valid", K6._`${H} <= ${Q.length}`);
      $.if((0, K6.not)(z), () => B(z)), X.ok(z);
    }
    function B(z) {
      $.forRange("i", Q.length, H, (K) => {
        if (X.subschema({ keyword: J, dataProp: K, dataPropType: xY.Type.Num }, z), !G.allErrors) $.if((0, K6.not)(z), () => $.break());
      });
    }
  }
  BB.validateAdditionalItems = HB;
  BB.default = Yj;
});
var gY = P((VB) => {
  Object.defineProperty(VB, "__esModule", { value: true });
  VB.validateTuple = void 0;
  var KB = c(), i9 = e(), Jj = d0(), Gj = { keyword: "items", type: "array", schemaType: ["object", "array", "boolean"], before: "uniqueItems", code(X) {
    let { schema: Q, it: $ } = X;
    if (Array.isArray(Q)) return UB(X, "additionalItems", Q);
    if ($.items = true, (0, i9.alwaysValidSchema)($, Q)) return;
    X.ok((0, Jj.validateArray)(X));
  } };
  function UB(X, Q, $ = X.schema) {
    let { gen: Y, parentSchema: W, data: J, keyword: G, it: H } = X;
    if (K(W), H.opts.unevaluated && $.length && H.items !== true) H.items = i9.mergeEvaluated.items(Y, $.length, H.items);
    let B = Y.name("valid"), z = Y.const("len", KB._`${J}.length`);
    $.forEach((V, L) => {
      if ((0, i9.alwaysValidSchema)(H, V)) return;
      Y.if(KB._`${z} > ${L}`, () => X.subschema({ keyword: G, schemaProp: L, dataProp: L }, B)), X.ok(B);
    });
    function K(V) {
      let { opts: L, errSchemaPath: U } = H, F = $.length, q = F === V.minItems && (F === V.maxItems || V[Q] === false);
      if (L.strictTuples && !q) {
        let N = `"${G}" is ${F}-tuple, but minItems or maxItems/${Q} are not specified or different at path "${U}"`;
        (0, i9.checkStrictMode)(H, N, L.strictTuples);
      }
    }
  }
  VB.validateTuple = UB;
  VB.default = Gj;
});
var FB = P((qB) => {
  Object.defineProperty(qB, "__esModule", { value: true });
  var Bj = gY(), zj = { keyword: "prefixItems", type: "array", schemaType: ["array"], before: "uniqueItems", code: (X) => (0, Bj.validateTuple)(X, "items") };
  qB.default = zj;
});
var DB = P((OB) => {
  Object.defineProperty(OB, "__esModule", { value: true });
  var NB = c(), Uj = e(), Vj = d0(), Lj = yY(), qj = { message: ({ params: { len: X } }) => NB.str`must NOT have more than ${X} items`, params: ({ params: { len: X } }) => NB._`{limit: ${X}}` }, Fj = { keyword: "items", type: "array", schemaType: ["object", "boolean"], before: "uniqueItems", error: qj, code(X) {
    let { schema: Q, parentSchema: $, it: Y } = X, { prefixItems: W } = $;
    if (Y.items = true, (0, Uj.alwaysValidSchema)(Y, Q)) return;
    if (W) (0, Lj.validateAdditionalItems)(X, W);
    else X.ok((0, Vj.validateArray)(X));
  } };
  OB.default = Fj;
});
var wB = P((AB) => {
  Object.defineProperty(AB, "__esModule", { value: true });
  var i0 = c(), n9 = e(), Oj = { message: ({ params: { min: X, max: Q } }) => Q === void 0 ? i0.str`must contain at least ${X} valid item(s)` : i0.str`must contain at least ${X} and no more than ${Q} valid item(s)`, params: ({ params: { min: X, max: Q } }) => Q === void 0 ? i0._`{minContains: ${X}}` : i0._`{minContains: ${X}, maxContains: ${Q}}` }, Dj = { keyword: "contains", type: "array", schemaType: ["object", "boolean"], before: "uniqueItems", trackErrors: true, error: Oj, code(X) {
    let { gen: Q, schema: $, parentSchema: Y, data: W, it: J } = X, G, H, { minContains: B, maxContains: z } = Y;
    if (J.opts.next) G = B === void 0 ? 1 : B, H = z;
    else G = 1;
    let K = Q.const("len", i0._`${W}.length`);
    if (X.setParams({ min: G, max: H }), H === void 0 && G === 0) {
      (0, n9.checkStrictMode)(J, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
      return;
    }
    if (H !== void 0 && G > H) {
      (0, n9.checkStrictMode)(J, '"minContains" > "maxContains" is always invalid'), X.fail();
      return;
    }
    if ((0, n9.alwaysValidSchema)(J, $)) {
      let q = i0._`${K} >= ${G}`;
      if (H !== void 0) q = i0._`${q} && ${K} <= ${H}`;
      X.pass(q);
      return;
    }
    J.items = true;
    let V = Q.name("valid");
    if (H === void 0 && G === 1) U(V, () => Q.if(V, () => Q.break()));
    else if (G === 0) {
      if (Q.let(V, true), H !== void 0) Q.if(i0._`${W}.length > 0`, L);
    } else Q.let(V, false), L();
    X.result(V, () => X.reset());
    function L() {
      let q = Q.name("_valid"), N = Q.let("count", 0);
      U(q, () => Q.if(q, () => F(N)));
    }
    function U(q, N) {
      Q.forRange("i", 0, K, (A) => {
        X.subschema({ keyword: "contains", dataProp: A, dataPropType: n9.Type.Num, compositeRule: true }, q), N();
      });
    }
    function F(q) {
      if (Q.code(i0._`${q}++`), H === void 0) Q.if(i0._`${q} >= ${G}`, () => Q.assign(V, true).break());
      else if (Q.if(i0._`${q} > ${H}`, () => Q.assign(V, false).break()), G === 1) Q.assign(V, true);
      else Q.if(i0._`${q} >= ${G}`, () => Q.assign(V, true));
    }
  } };
  AB.default = Dj;
});
var bB = P((RB) => {
  Object.defineProperty(RB, "__esModule", { value: true });
  RB.validateSchemaDeps = RB.validatePropertyDeps = RB.error = void 0;
  var hY = c(), wj = e(), W4 = d0();
  RB.error = { message: ({ params: { property: X, depsCount: Q, deps: $ } }) => {
    let Y = Q === 1 ? "property" : "properties";
    return hY.str`must have ${Y} ${$} when property ${X} is present`;
  }, params: ({ params: { property: X, depsCount: Q, deps: $, missingProperty: Y } }) => hY._`{property: ${X},
    missingProperty: ${Y},
    depsCount: ${Q},
    deps: ${$}}` };
  var Mj = { keyword: "dependencies", type: "object", schemaType: "object", error: RB.error, code(X) {
    let [Q, $] = jj(X);
    MB(X, Q), jB(X, $);
  } };
  function jj({ schema: X }) {
    let Q = {}, $ = {};
    for (let Y in X) {
      if (Y === "__proto__") continue;
      let W = Array.isArray(X[Y]) ? Q : $;
      W[Y] = X[Y];
    }
    return [Q, $];
  }
  function MB(X, Q = X.schema) {
    let { gen: $, data: Y, it: W } = X;
    if (Object.keys(Q).length === 0) return;
    let J = $.let("missing");
    for (let G in Q) {
      let H = Q[G];
      if (H.length === 0) continue;
      let B = (0, W4.propertyInData)($, Y, G, W.opts.ownProperties);
      if (X.setParams({ property: G, depsCount: H.length, deps: H.join(", ") }), W.allErrors) $.if(B, () => {
        for (let z of H) (0, W4.checkReportMissingProp)(X, z);
      });
      else $.if(hY._`${B} && (${(0, W4.checkMissingProp)(X, H, J)})`), (0, W4.reportMissingProp)(X, J), $.else();
    }
  }
  RB.validatePropertyDeps = MB;
  function jB(X, Q = X.schema) {
    let { gen: $, data: Y, keyword: W, it: J } = X, G = $.name("valid");
    for (let H in Q) {
      if ((0, wj.alwaysValidSchema)(J, Q[H])) continue;
      $.if((0, W4.propertyInData)($, Y, H, J.opts.ownProperties), () => {
        let B = X.subschema({ keyword: W, schemaProp: H }, G);
        X.mergeValidEvaluated(B, G);
      }, () => $.var(G, true)), X.ok(G);
    }
  }
  RB.validateSchemaDeps = jB;
  RB.default = Mj;
});
var ZB = P((SB) => {
  Object.defineProperty(SB, "__esModule", { value: true });
  var PB = c(), Ij = e(), bj = { message: "property name must be valid", params: ({ params: X }) => PB._`{propertyName: ${X.propertyName}}` }, Pj = { keyword: "propertyNames", type: "object", schemaType: ["object", "boolean"], error: bj, code(X) {
    let { gen: Q, schema: $, data: Y, it: W } = X;
    if ((0, Ij.alwaysValidSchema)(W, $)) return;
    let J = Q.name("valid");
    Q.forIn("key", Y, (G) => {
      X.setParams({ propertyName: G }), X.subschema({ keyword: "propertyNames", data: G, dataTypes: ["string"], propertyName: G, compositeRule: true }, J), Q.if((0, PB.not)(J), () => {
        if (X.error(true), !W.allErrors) Q.break();
      });
    }), X.ok(J);
  } };
  SB.default = Pj;
});
var fY = P((CB) => {
  Object.defineProperty(CB, "__esModule", { value: true });
  var r9 = d0(), $1 = c(), Zj = R1(), o9 = e(), Cj = { message: "must NOT have additional properties", params: ({ params: X }) => $1._`{additionalProperty: ${X.additionalProperty}}` }, kj = { keyword: "additionalProperties", type: ["object"], schemaType: ["boolean", "object"], allowUndefined: true, trackErrors: true, error: Cj, code(X) {
    let { gen: Q, schema: $, parentSchema: Y, data: W, errsCount: J, it: G } = X;
    if (!J) throw Error("ajv implementation error");
    let { allErrors: H, opts: B } = G;
    if (G.props = true, B.removeAdditional !== "all" && (0, o9.alwaysValidSchema)(G, $)) return;
    let z = (0, r9.allSchemaProperties)(Y.properties), K = (0, r9.allSchemaProperties)(Y.patternProperties);
    V(), X.ok($1._`${J} === ${Zj.default.errors}`);
    function V() {
      Q.forIn("key", W, (N) => {
        if (!z.length && !K.length) F(N);
        else Q.if(L(N), () => F(N));
      });
    }
    function L(N) {
      let A;
      if (z.length > 8) {
        let M = (0, o9.schemaRefOrVal)(G, Y.properties, "properties");
        A = (0, r9.isOwnProperty)(Q, M, N);
      } else if (z.length) A = (0, $1.or)(...z.map((M) => $1._`${N} === ${M}`));
      else A = $1.nil;
      if (K.length) A = (0, $1.or)(A, ...K.map((M) => $1._`${(0, r9.usePattern)(X, M)}.test(${N})`));
      return (0, $1.not)(A);
    }
    function U(N) {
      Q.code($1._`delete ${W}[${N}]`);
    }
    function F(N) {
      if (B.removeAdditional === "all" || B.removeAdditional && $ === false) {
        U(N);
        return;
      }
      if ($ === false) {
        if (X.setParams({ additionalProperty: N }), X.error(), !H) Q.break();
        return;
      }
      if (typeof $ == "object" && !(0, o9.alwaysValidSchema)(G, $)) {
        let A = Q.name("valid");
        if (B.removeAdditional === "failing") q(N, A, false), Q.if((0, $1.not)(A), () => {
          X.reset(), U(N);
        });
        else if (q(N, A), !H) Q.if((0, $1.not)(A), () => Q.break());
      }
    }
    function q(N, A, M) {
      let R = { keyword: "additionalProperties", dataProp: N, dataPropType: o9.Type.Str };
      if (M === false) Object.assign(R, { compositeRule: true, createErrors: false, allErrors: false });
      X.subschema(R, A);
    }
  } };
  CB.default = kj;
});
var _B = P((TB) => {
  Object.defineProperty(TB, "__esModule", { value: true });
  var Tj = iX(), kB = d0(), uY = e(), vB = fY(), _j = { keyword: "properties", type: "object", schemaType: "object", code(X) {
    let { gen: Q, schema: $, parentSchema: Y, data: W, it: J } = X;
    if (J.opts.removeAdditional === "all" && Y.additionalProperties === void 0) vB.default.code(new Tj.KeywordCxt(J, vB.default, "additionalProperties"));
    let G = (0, kB.allSchemaProperties)($);
    for (let V of G) J.definedProperties.add(V);
    if (J.opts.unevaluated && G.length && J.props !== true) J.props = uY.mergeEvaluated.props(Q, (0, uY.toHash)(G), J.props);
    let H = G.filter((V) => !(0, uY.alwaysValidSchema)(J, $[V]));
    if (H.length === 0) return;
    let B = Q.name("valid");
    for (let V of H) {
      if (z(V)) K(V);
      else {
        if (Q.if((0, kB.propertyInData)(Q, W, V, J.opts.ownProperties)), K(V), !J.allErrors) Q.else().var(B, true);
        Q.endIf();
      }
      X.it.definedProperties.add(V), X.ok(B);
    }
    function z(V) {
      return J.opts.useDefaults && !J.compositeRule && $[V].default !== void 0;
    }
    function K(V) {
      X.subschema({ keyword: "properties", schemaProp: V, dataProp: V }, B);
    }
  } };
  TB.default = _j;
});
var fB = P((hB) => {
  Object.defineProperty(hB, "__esModule", { value: true });
  var xB = d0(), t9 = c(), yB = e(), gB = e(), yj = { keyword: "patternProperties", type: "object", schemaType: "object", code(X) {
    let { gen: Q, schema: $, data: Y, parentSchema: W, it: J } = X, { opts: G } = J, H = (0, xB.allSchemaProperties)($), B = H.filter((q) => (0, yB.alwaysValidSchema)(J, $[q]));
    if (H.length === 0 || B.length === H.length && (!J.opts.unevaluated || J.props === true)) return;
    let z = G.strictSchema && !G.allowMatchingProperties && W.properties, K = Q.name("valid");
    if (J.props !== true && !(J.props instanceof t9.Name)) J.props = (0, gB.evaluatedPropsToName)(Q, J.props);
    let { props: V } = J;
    L();
    function L() {
      for (let q of H) {
        if (z) U(q);
        if (J.allErrors) F(q);
        else Q.var(K, true), F(q), Q.if(K);
      }
    }
    function U(q) {
      for (let N in z) if (new RegExp(q).test(N)) (0, yB.checkStrictMode)(J, `property ${N} matches pattern ${q} (use allowMatchingProperties)`);
    }
    function F(q) {
      Q.forIn("key", Y, (N) => {
        Q.if(t9._`${(0, xB.usePattern)(X, q)}.test(${N})`, () => {
          let A = B.includes(q);
          if (!A) X.subschema({ keyword: "patternProperties", schemaProp: q, dataProp: N, dataPropType: gB.Type.Str }, K);
          if (J.opts.unevaluated && V !== true) Q.assign(t9._`${V}[${N}]`, true);
          else if (!A && !J.allErrors) Q.if((0, t9.not)(K), () => Q.break());
        });
      });
    }
  } };
  hB.default = yj;
});
var lB = P((uB) => {
  Object.defineProperty(uB, "__esModule", { value: true });
  var hj = e(), fj = { keyword: "not", schemaType: ["object", "boolean"], trackErrors: true, code(X) {
    let { gen: Q, schema: $, it: Y } = X;
    if ((0, hj.alwaysValidSchema)(Y, $)) {
      X.fail();
      return;
    }
    let W = Q.name("valid");
    X.subschema({ keyword: "not", compositeRule: true, createErrors: false, allErrors: false }, W), X.failResult(W, () => X.reset(), () => X.error());
  }, error: { message: "must NOT be valid" } };
  uB.default = fj;
});
var cB = P((mB) => {
  Object.defineProperty(mB, "__esModule", { value: true });
  var lj = d0(), mj = { keyword: "anyOf", schemaType: "array", trackErrors: true, code: lj.validateUnion, error: { message: "must match a schema in anyOf" } };
  mB.default = mj;
});
var dB = P((pB) => {
  Object.defineProperty(pB, "__esModule", { value: true });
  var a9 = c(), pj = e(), dj = { message: "must match exactly one schema in oneOf", params: ({ params: X }) => a9._`{passingSchemas: ${X.passing}}` }, ij = { keyword: "oneOf", schemaType: "array", trackErrors: true, error: dj, code(X) {
    let { gen: Q, schema: $, parentSchema: Y, it: W } = X;
    if (!Array.isArray($)) throw Error("ajv implementation error");
    if (W.opts.discriminator && Y.discriminator) return;
    let J = $, G = Q.let("valid", false), H = Q.let("passing", null), B = Q.name("_valid");
    X.setParams({ passing: H }), Q.block(z), X.result(G, () => X.reset(), () => X.error(true));
    function z() {
      J.forEach((K, V) => {
        let L;
        if ((0, pj.alwaysValidSchema)(W, K)) Q.var(B, true);
        else L = X.subschema({ keyword: "oneOf", schemaProp: V, compositeRule: true }, B);
        if (V > 0) Q.if(a9._`${B} && ${G}`).assign(G, false).assign(H, a9._`[${H}, ${V}]`).else();
        Q.if(B, () => {
          if (Q.assign(G, true), Q.assign(H, V), L) X.mergeEvaluated(L, a9.Name);
        });
      });
    }
  } };
  pB.default = ij;
});
var nB = P((iB) => {
  Object.defineProperty(iB, "__esModule", { value: true });
  var rj = e(), oj = { keyword: "allOf", schemaType: "array", code(X) {
    let { gen: Q, schema: $, it: Y } = X;
    if (!Array.isArray($)) throw Error("ajv implementation error");
    let W = Q.name("valid");
    $.forEach((J, G) => {
      if ((0, rj.alwaysValidSchema)(Y, J)) return;
      let H = X.subschema({ keyword: "allOf", schemaProp: G }, W);
      X.ok(W), X.mergeEvaluated(H);
    });
  } };
  iB.default = oj;
});
var aB = P((tB) => {
  Object.defineProperty(tB, "__esModule", { value: true });
  var s9 = c(), oB = e(), aj = { message: ({ params: X }) => s9.str`must match "${X.ifClause}" schema`, params: ({ params: X }) => s9._`{failingKeyword: ${X.ifClause}}` }, sj = { keyword: "if", schemaType: ["object", "boolean"], trackErrors: true, error: aj, code(X) {
    let { gen: Q, parentSchema: $, it: Y } = X;
    if ($.then === void 0 && $.else === void 0) (0, oB.checkStrictMode)(Y, '"if" without "then" and "else" is ignored');
    let W = rB(Y, "then"), J = rB(Y, "else");
    if (!W && !J) return;
    let G = Q.let("valid", true), H = Q.name("_valid");
    if (B(), X.reset(), W && J) {
      let K = Q.let("ifClause");
      X.setParams({ ifClause: K }), Q.if(H, z("then", K), z("else", K));
    } else if (W) Q.if(H, z("then"));
    else Q.if((0, s9.not)(H), z("else"));
    X.pass(G, () => X.error(true));
    function B() {
      let K = X.subschema({ keyword: "if", compositeRule: true, createErrors: false, allErrors: false }, H);
      X.mergeEvaluated(K);
    }
    function z(K, V) {
      return () => {
        let L = X.subschema({ keyword: K }, H);
        if (Q.assign(G, H), X.mergeValidEvaluated(L, G), V) Q.assign(V, s9._`${K}`);
        else X.setParams({ ifClause: K });
      };
    }
  } };
  function rB(X, Q) {
    let $ = X.schema[Q];
    return $ !== void 0 && !(0, oB.alwaysValidSchema)(X, $);
  }
  tB.default = sj;
});
var eB = P((sB) => {
  Object.defineProperty(sB, "__esModule", { value: true });
  var XR = e(), QR = { keyword: ["then", "else"], schemaType: ["object", "boolean"], code({ keyword: X, parentSchema: Q, it: $ }) {
    if (Q.if === void 0) (0, XR.checkStrictMode)($, `"${X}" without "if" is ignored`);
  } };
  sB.default = QR;
});
var Qz = P((Xz) => {
  Object.defineProperty(Xz, "__esModule", { value: true });
  var YR = yY(), WR = FB(), JR = gY(), GR = DB(), HR = wB(), BR = bB(), zR = ZB(), KR = fY(), UR = _B(), VR = fB(), LR = lB(), qR = cB(), FR = dB(), NR = nB(), OR = aB(), DR = eB();
  function AR(X = false) {
    let Q = [LR.default, qR.default, FR.default, NR.default, OR.default, DR.default, zR.default, KR.default, BR.default, UR.default, VR.default];
    if (X) Q.push(WR.default, GR.default);
    else Q.push(YR.default, JR.default);
    return Q.push(HR.default), Q;
  }
  Xz.default = AR;
});
var Yz = P(($z) => {
  Object.defineProperty($z, "__esModule", { value: true });
  var L0 = c(), MR = { message: ({ schemaCode: X }) => L0.str`must match format "${X}"`, params: ({ schemaCode: X }) => L0._`{format: ${X}}` }, jR = { keyword: "format", type: ["number", "string"], schemaType: "string", $data: true, error: MR, code(X, Q) {
    let { gen: $, data: Y, $data: W, schema: J, schemaCode: G, it: H } = X, { opts: B, errSchemaPath: z, schemaEnv: K, self: V } = H;
    if (!B.validateFormats) return;
    if (W) L();
    else U();
    function L() {
      let F = $.scopeValue("formats", { ref: V.formats, code: B.code.formats }), q = $.const("fDef", L0._`${F}[${G}]`), N = $.let("fType"), A = $.let("format");
      $.if(L0._`typeof ${q} == "object" && !(${q} instanceof RegExp)`, () => $.assign(N, L0._`${q}.type || "string"`).assign(A, L0._`${q}.validate`), () => $.assign(N, L0._`"string"`).assign(A, q)), X.fail$data((0, L0.or)(M(), R()));
      function M() {
        if (B.strictSchema === false) return L0.nil;
        return L0._`${G} && !${A}`;
      }
      function R() {
        let S = K.$async ? L0._`(${q}.async ? await ${A}(${Y}) : ${A}(${Y}))` : L0._`${A}(${Y})`, C = L0._`(typeof ${A} == "function" ? ${S} : ${A}.test(${Y}))`;
        return L0._`${A} && ${A} !== true && ${N} === ${Q} && !${C}`;
      }
    }
    function U() {
      let F = V.formats[J];
      if (!F) {
        M();
        return;
      }
      if (F === true) return;
      let [q, N, A] = R(F);
      if (q === Q) X.pass(S());
      function M() {
        if (B.strictSchema === false) {
          V.logger.warn(C());
          return;
        }
        throw Error(C());
        function C() {
          return `unknown format "${J}" ignored in schema at path "${z}"`;
        }
      }
      function R(C) {
        let K0 = C instanceof RegExp ? (0, L0.regexpCode)(C) : B.code.formats ? L0._`${B.code.formats}${(0, L0.getProperty)(J)}` : void 0, U0 = $.scopeValue("formats", { key: J, ref: C, code: K0 });
        if (typeof C == "object" && !(C instanceof RegExp)) return [C.type || "string", C.validate, L0._`${U0}.validate`];
        return ["string", C, U0];
      }
      function S() {
        if (typeof F == "object" && !(F instanceof RegExp) && F.async) {
          if (!K.$async) throw Error("async format in sync schema");
          return L0._`await ${A}(${Y})`;
        }
        return typeof N == "function" ? L0._`${A}(${Y})` : L0._`${A}.test(${Y})`;
      }
    }
  } };
  $z.default = jR;
});
var Jz = P((Wz) => {
  Object.defineProperty(Wz, "__esModule", { value: true });
  var ER = Yz(), IR = [ER.default];
  Wz.default = IR;
});
var Bz = P((Gz) => {
  Object.defineProperty(Gz, "__esModule", { value: true });
  Gz.contentVocabulary = Gz.metadataVocabulary = void 0;
  Gz.metadataVocabulary = ["title", "description", "default", "deprecated", "readOnly", "writeOnly", "examples"];
  Gz.contentVocabulary = ["contentMediaType", "contentEncoding", "contentSchema"];
});
var Uz = P((Kz) => {
  Object.defineProperty(Kz, "__esModule", { value: true });
  var SR = TH(), ZR = GB(), CR = Qz(), kR = Jz(), zz = Bz(), vR = [SR.default, ZR.default, (0, CR.default)(), kR.default, zz.metadataVocabulary, zz.contentVocabulary];
  Kz.default = vR;
});
var Fz = P((Lz) => {
  Object.defineProperty(Lz, "__esModule", { value: true });
  Lz.DiscrError = void 0;
  var Vz;
  (function(X) {
    X.Tag = "tag", X.Mapping = "mapping";
  })(Vz || (Lz.DiscrError = Vz = {}));
});
var Dz = P((Oz) => {
  Object.defineProperty(Oz, "__esModule", { value: true });
  var i6 = c(), lY = Fz(), Nz = _9(), _R = nX(), xR = e(), yR = { message: ({ params: { discrError: X, tagName: Q } }) => X === lY.DiscrError.Tag ? `tag "${Q}" must be string` : `value of tag "${Q}" must be in oneOf`, params: ({ params: { discrError: X, tag: Q, tagName: $ } }) => i6._`{error: ${X}, tag: ${$}, tagValue: ${Q}}` }, gR = { keyword: "discriminator", type: "object", schemaType: "object", error: yR, code(X) {
    let { gen: Q, data: $, schema: Y, parentSchema: W, it: J } = X, { oneOf: G } = W;
    if (!J.opts.discriminator) throw Error("discriminator: requires discriminator option");
    let H = Y.propertyName;
    if (typeof H != "string") throw Error("discriminator: requires propertyName");
    if (Y.mapping) throw Error("discriminator: mapping is not supported");
    if (!G) throw Error("discriminator: requires oneOf keyword");
    let B = Q.let("valid", false), z = Q.const("tag", i6._`${$}${(0, i6.getProperty)(H)}`);
    Q.if(i6._`typeof ${z} == "string"`, () => K(), () => X.error(false, { discrError: lY.DiscrError.Tag, tag: z, tagName: H })), X.ok(B);
    function K() {
      let U = L();
      Q.if(false);
      for (let F in U) Q.elseIf(i6._`${z} === ${F}`), Q.assign(B, V(U[F]));
      Q.else(), X.error(false, { discrError: lY.DiscrError.Mapping, tag: z, tagName: H }), Q.endIf();
    }
    function V(U) {
      let F = Q.name("valid"), q = X.subschema({ keyword: "oneOf", schemaProp: U }, F);
      return X.mergeEvaluated(q, i6.Name), F;
    }
    function L() {
      var U;
      let F = {}, q = A(W), N = true;
      for (let S = 0; S < G.length; S++) {
        let C = G[S];
        if ((C === null || C === void 0 ? void 0 : C.$ref) && !(0, xR.schemaHasRulesButRef)(C, J.self.RULES)) {
          let U0 = C.$ref;
          if (C = Nz.resolveRef.call(J.self, J.schemaEnv.root, J.baseId, U0), C instanceof Nz.SchemaEnv) C = C.schema;
          if (C === void 0) throw new _R.default(J.opts.uriResolver, J.baseId, U0);
        }
        let K0 = (U = C === null || C === void 0 ? void 0 : C.properties) === null || U === void 0 ? void 0 : U[H];
        if (typeof K0 != "object") throw Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${H}"`);
        N = N && (q || A(C)), M(K0, S);
      }
      if (!N) throw Error(`discriminator: "${H}" must be required`);
      return F;
      function A({ required: S }) {
        return Array.isArray(S) && S.includes(H);
      }
      function M(S, C) {
        if (S.const) R(S.const, C);
        else if (S.enum) for (let K0 of S.enum) R(K0, C);
        else throw Error(`discriminator: "properties/${H}" must have "const" or "enum"`);
      }
      function R(S, C) {
        if (typeof S != "string" || S in F) throw Error(`discriminator: "${H}" values must be unique strings`);
        F[S] = C;
      }
    }
  } };
  Oz.default = gR;
});
var Az = P((oT, fR) => {
  fR.exports = { $schema: "http://json-schema.org/draft-07/schema#", $id: "http://json-schema.org/draft-07/schema#", title: "Core schema meta-schema", definitions: { schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } }, nonNegativeInteger: { type: "integer", minimum: 0 }, nonNegativeIntegerDefault0: { allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }] }, simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, uniqueItems: true, default: [] } }, type: ["object", "boolean"], properties: { $id: { type: "string", format: "uri-reference" }, $schema: { type: "string", format: "uri" }, $ref: { type: "string", format: "uri-reference" }, $comment: { type: "string" }, title: { type: "string" }, description: { type: "string" }, default: true, readOnly: { type: "boolean", default: false }, examples: { type: "array", items: true }, multipleOf: { type: "number", exclusiveMinimum: 0 }, maximum: { type: "number" }, exclusiveMaximum: { type: "number" }, minimum: { type: "number" }, exclusiveMinimum: { type: "number" }, maxLength: { $ref: "#/definitions/nonNegativeInteger" }, minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, pattern: { type: "string", format: "regex" }, additionalItems: { $ref: "#" }, items: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }], default: true }, maxItems: { $ref: "#/definitions/nonNegativeInteger" }, minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, uniqueItems: { type: "boolean", default: false }, contains: { $ref: "#" }, maxProperties: { $ref: "#/definitions/nonNegativeInteger" }, minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, required: { $ref: "#/definitions/stringArray" }, additionalProperties: { $ref: "#" }, definitions: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, properties: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $ref: "#" }, propertyNames: { format: "regex" }, default: {} }, dependencies: { type: "object", additionalProperties: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }] } }, propertyNames: { $ref: "#" }, const: true, enum: { type: "array", items: true, minItems: 1, uniqueItems: true }, type: { anyOf: [{ $ref: "#/definitions/simpleTypes" }, { type: "array", items: { $ref: "#/definitions/simpleTypes" }, minItems: 1, uniqueItems: true }] }, format: { type: "string" }, contentMediaType: { type: "string" }, contentEncoding: { type: "string" }, if: { $ref: "#" }, then: { $ref: "#" }, else: { $ref: "#" }, allOf: { $ref: "#/definitions/schemaArray" }, anyOf: { $ref: "#/definitions/schemaArray" }, oneOf: { $ref: "#/definitions/schemaArray" }, not: { $ref: "#" } }, default: true };
});
var cY = P((h0, mY) => {
  Object.defineProperty(h0, "__esModule", { value: true });
  h0.MissingRefError = h0.ValidationError = h0.CodeGen = h0.Name = h0.nil = h0.stringify = h0.str = h0._ = h0.KeywordCxt = h0.Ajv = void 0;
  var uR = RH(), lR = Uz(), mR = Dz(), wz = Az(), cR = ["/properties"], e9 = "http://json-schema.org/draft-07/schema";
  class J4 extends uR.default {
    _addVocabularies() {
      if (super._addVocabularies(), lR.default.forEach((X) => this.addVocabulary(X)), this.opts.discriminator) this.addKeyword(mR.default);
    }
    _addDefaultMetaSchema() {
      if (super._addDefaultMetaSchema(), !this.opts.meta) return;
      let X = this.opts.$data ? this.$dataMetaSchema(wz, cR) : wz;
      this.addMetaSchema(X, e9, false), this.refs["http://json-schema.org/schema"] = e9;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(e9) ? e9 : void 0);
    }
  }
  h0.Ajv = J4;
  mY.exports = h0 = J4;
  mY.exports.Ajv = J4;
  Object.defineProperty(h0, "__esModule", { value: true });
  h0.default = J4;
  var pR = iX();
  Object.defineProperty(h0, "KeywordCxt", { enumerable: true, get: function() {
    return pR.KeywordCxt;
  } });
  var n6 = c();
  Object.defineProperty(h0, "_", { enumerable: true, get: function() {
    return n6._;
  } });
  Object.defineProperty(h0, "str", { enumerable: true, get: function() {
    return n6.str;
  } });
  Object.defineProperty(h0, "stringify", { enumerable: true, get: function() {
    return n6.stringify;
  } });
  Object.defineProperty(h0, "nil", { enumerable: true, get: function() {
    return n6.nil;
  } });
  Object.defineProperty(h0, "Name", { enumerable: true, get: function() {
    return n6.Name;
  } });
  Object.defineProperty(h0, "CodeGen", { enumerable: true, get: function() {
    return n6.CodeGen;
  } });
  var dR = v9();
  Object.defineProperty(h0, "ValidationError", { enumerable: true, get: function() {
    return dR.default;
  } });
  var iR = nX();
  Object.defineProperty(h0, "MissingRefError", { enumerable: true, get: function() {
    return iR.default;
  } });
});
var Cz = P((Sz) => {
  Object.defineProperty(Sz, "__esModule", { value: true });
  Sz.formatNames = Sz.fastFormats = Sz.fullFormats = void 0;
  function L1(X, Q) {
    return { validate: X, compare: Q };
  }
  Sz.fullFormats = { date: L1(Ez, nY), time: L1(dY(true), rY), "date-time": L1(Mz(true), bz), "iso-time": L1(dY(), Iz), "iso-date-time": L1(Mz(), Pz), duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/, uri: XE, "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i, url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu, email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i, hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i, ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/, ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i, regex: HE, uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i, "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/, "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i, "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/, byte: QE, int32: { type: "number", validate: WE }, int64: { type: "number", validate: JE }, float: { type: "number", validate: Rz }, double: { type: "number", validate: Rz }, password: true, binary: true };
  Sz.fastFormats = { ...Sz.fullFormats, date: L1(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, nY), time: L1(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, rY), "date-time": L1(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, bz), "iso-time": L1(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, Iz), "iso-date-time": L1(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, Pz), uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i, "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i, email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i };
  Sz.formatNames = Object.keys(Sz.fullFormats);
  function oR(X) {
    return X % 4 === 0 && (X % 100 !== 0 || X % 400 === 0);
  }
  var tR = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, aR = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function Ez(X) {
    let Q = tR.exec(X);
    if (!Q) return false;
    let $ = +Q[1], Y = +Q[2], W = +Q[3];
    return Y >= 1 && Y <= 12 && W >= 1 && W <= (Y === 2 && oR($) ? 29 : aR[Y]);
  }
  function nY(X, Q) {
    if (!(X && Q)) return;
    if (X > Q) return 1;
    if (X < Q) return -1;
    return 0;
  }
  var pY = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
  function dY(X) {
    return function($) {
      let Y = pY.exec($);
      if (!Y) return false;
      let W = +Y[1], J = +Y[2], G = +Y[3], H = Y[4], B = Y[5] === "-" ? -1 : 1, z = +(Y[6] || 0), K = +(Y[7] || 0);
      if (z > 23 || K > 59 || X && !H) return false;
      if (W <= 23 && J <= 59 && G < 60) return true;
      let V = J - K * B, L = W - z * B - (V < 0 ? 1 : 0);
      return (L === 23 || L === -1) && (V === 59 || V === -1) && G < 61;
    };
  }
  function rY(X, Q) {
    if (!(X && Q)) return;
    let $ = (/* @__PURE__ */ new Date("2020-01-01T" + X)).valueOf(), Y = (/* @__PURE__ */ new Date("2020-01-01T" + Q)).valueOf();
    if (!($ && Y)) return;
    return $ - Y;
  }
  function Iz(X, Q) {
    if (!(X && Q)) return;
    let $ = pY.exec(X), Y = pY.exec(Q);
    if (!($ && Y)) return;
    if (X = $[1] + $[2] + $[3], Q = Y[1] + Y[2] + Y[3], X > Q) return 1;
    if (X < Q) return -1;
    return 0;
  }
  var iY = /t|\s/i;
  function Mz(X) {
    let Q = dY(X);
    return function(Y) {
      let W = Y.split(iY);
      return W.length === 2 && Ez(W[0]) && Q(W[1]);
    };
  }
  function bz(X, Q) {
    if (!(X && Q)) return;
    let $ = new Date(X).valueOf(), Y = new Date(Q).valueOf();
    if (!($ && Y)) return;
    return $ - Y;
  }
  function Pz(X, Q) {
    if (!(X && Q)) return;
    let [$, Y] = X.split(iY), [W, J] = Q.split(iY), G = nY($, W);
    if (G === void 0) return;
    return G || rY(Y, J);
  }
  var sR = /\/|:/, eR = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  function XE(X) {
    return sR.test(X) && eR.test(X);
  }
  var jz = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  function QE(X) {
    return jz.lastIndex = 0, jz.test(X);
  }
  var $E = -2147483648, YE = 2147483647;
  function WE(X) {
    return Number.isInteger(X) && X <= YE && X >= $E;
  }
  function JE(X) {
    return Number.isInteger(X);
  }
  function Rz() {
    return true;
  }
  var GE = /[^\\]\\Z/;
  function HE(X) {
    if (GE.test(X)) return false;
    try {
      return new RegExp(X), true;
    } catch (Q) {
      return false;
    }
  }
});
var vz = P((kz) => {
  Object.defineProperty(kz, "__esModule", { value: true });
  kz.formatLimitDefinition = void 0;
  var zE = cY(), Y1 = c(), i1 = Y1.operators, X8 = { formatMaximum: { okStr: "<=", ok: i1.LTE, fail: i1.GT }, formatMinimum: { okStr: ">=", ok: i1.GTE, fail: i1.LT }, formatExclusiveMaximum: { okStr: "<", ok: i1.LT, fail: i1.GTE }, formatExclusiveMinimum: { okStr: ">", ok: i1.GT, fail: i1.LTE } }, KE = { message: ({ keyword: X, schemaCode: Q }) => Y1.str`should be ${X8[X].okStr} ${Q}`, params: ({ keyword: X, schemaCode: Q }) => Y1._`{comparison: ${X8[X].okStr}, limit: ${Q}}` };
  kz.formatLimitDefinition = { keyword: Object.keys(X8), type: "string", schemaType: "string", $data: true, error: KE, code(X) {
    let { gen: Q, data: $, schemaCode: Y, keyword: W, it: J } = X, { opts: G, self: H } = J;
    if (!G.validateFormats) return;
    let B = new zE.KeywordCxt(J, H.RULES.all.format.definition, "format");
    if (B.$data) z();
    else K();
    function z() {
      let L = Q.scopeValue("formats", { ref: H.formats, code: G.code.formats }), U = Q.const("fmt", Y1._`${L}[${B.schemaCode}]`);
      X.fail$data((0, Y1.or)(Y1._`typeof ${U} != "object"`, Y1._`${U} instanceof RegExp`, Y1._`typeof ${U}.compare != "function"`, V(U)));
    }
    function K() {
      let L = B.schema, U = H.formats[L];
      if (!U || U === true) return;
      if (typeof U != "object" || U instanceof RegExp || typeof U.compare != "function") throw Error(`"${W}": format "${L}" does not define "compare" function`);
      let F = Q.scopeValue("formats", { key: L, ref: U, code: G.code.formats ? Y1._`${G.code.formats}${(0, Y1.getProperty)(L)}` : void 0 });
      X.fail$data(V(F));
    }
    function V(L) {
      return Y1._`${L}.compare(${$}, ${Y}) ${X8[W].fail} 0`;
    }
  }, dependencies: ["format"] };
  var UE = (X) => {
    return X.addKeyword(kz.formatLimitDefinition), X;
  };
  kz.default = UE;
});
var yz = P((G4, xz) => {
  Object.defineProperty(G4, "__esModule", { value: true });
  var r6 = Cz(), LE = vz(), aY = c(), Tz = new aY.Name("fullFormats"), qE = new aY.Name("fastFormats"), sY = (X, Q = { keywords: true }) => {
    if (Array.isArray(Q)) return _z(X, Q, r6.fullFormats, Tz), X;
    let [$, Y] = Q.mode === "fast" ? [r6.fastFormats, qE] : [r6.fullFormats, Tz], W = Q.formats || r6.formatNames;
    if (_z(X, W, $, Y), Q.keywords) (0, LE.default)(X);
    return X;
  };
  sY.get = (X, Q = "full") => {
    let Y = (Q === "fast" ? r6.fastFormats : r6.fullFormats)[X];
    if (!Y) throw Error(`Unknown format "${X}"`);
    return Y;
  };
  function _z(X, Q, $, Y) {
    var W, J;
    (W = (J = X.opts.code).formats) !== null && W !== void 0 || (J.formats = aY._`require("ajv-formats/dist/formats").${Y}`);
    for (let G of Q) X.addFormat(G, $[G]);
  }
  xz.exports = G4 = sY;
  Object.defineProperty(G4, "__esModule", { value: true });
  G4.default = sY;
});
var HK = 50;
function N6(X = HK) {
  let Q = new AbortController();
  return (0, import_events.setMaxListeners)(X, Q.signal), Q;
}
var BK = typeof global == "object" && global && global.Object === Object && global;
var q7 = BK;
var zK = typeof self == "object" && self && self.Object === Object && self;
var KK = q7 || zK || Function("return this")();
var O6 = KK;
var UK = O6.Symbol;
var D6 = UK;
var F7 = Object.prototype;
var VK = F7.hasOwnProperty;
var LK = F7.toString;
var e6 = D6 ? D6.toStringTag : void 0;
function qK(X) {
  var Q = VK.call(X, e6), $ = X[e6];
  try {
    X[e6] = void 0;
    var Y = true;
  } catch (J) {
  }
  var W = LK.call(X);
  if (Y) if (Q) X[e6] = $;
  else delete X[e6];
  return W;
}
var N7 = qK;
var FK = Object.prototype;
var NK = FK.toString;
function OK(X) {
  return NK.call(X);
}
var O7 = OK;
var DK = "[object Null]";
var AK = "[object Undefined]";
var D7 = D6 ? D6.toStringTag : void 0;
function wK(X) {
  if (X == null) return X === void 0 ? AK : DK;
  return D7 && D7 in Object(X) ? N7(X) : O7(X);
}
var A7 = wK;
function MK(X) {
  var Q = typeof X;
  return X != null && (Q == "object" || Q == "function");
}
var z4 = MK;
var jK = "[object AsyncFunction]";
var RK = "[object Function]";
var EK = "[object GeneratorFunction]";
var IK = "[object Proxy]";
function bK(X) {
  if (!z4(X)) return false;
  var Q = A7(X);
  return Q == RK || Q == EK || Q == jK || Q == IK;
}
var w7 = bK;
var PK = O6["__core-js_shared__"];
var K4 = PK;
var M7 = (function() {
  var X = /[^.]+$/.exec(K4 && K4.keys && K4.keys.IE_PROTO || "");
  return X ? "Symbol(src)_1." + X : "";
})();
function SK(X) {
  return !!M7 && M7 in X;
}
var j7 = SK;
var ZK = Function.prototype;
var CK = ZK.toString;
function kK(X) {
  if (X != null) {
    try {
      return CK.call(X);
    } catch (Q) {
    }
    try {
      return X + "";
    } catch (Q) {
    }
  }
  return "";
}
var R7 = kK;
var vK = /[\\^$.*+?()[\]{}|]/g;
var TK = /^\[object .+?Constructor\]$/;
var _K = Function.prototype;
var xK = Object.prototype;
var yK = _K.toString;
var gK = xK.hasOwnProperty;
var hK = RegExp("^" + yK.call(gK).replace(vK, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function fK(X) {
  if (!z4(X) || j7(X)) return false;
  var Q = w7(X) ? hK : TK;
  return Q.test(R7(X));
}
var E7 = fK;
function uK(X, Q) {
  return X == null ? void 0 : X[Q];
}
var I7 = uK;
function lK(X, Q) {
  var $ = I7(X, Q);
  return E7($) ? $ : void 0;
}
var U4 = lK;
var mK = U4(Object, "create");
var q1 = mK;
function cK() {
  this.__data__ = q1 ? q1(null) : {}, this.size = 0;
}
var b7 = cK;
function pK(X) {
  var Q = this.has(X) && delete this.__data__[X];
  return this.size -= Q ? 1 : 0, Q;
}
var P7 = pK;
var dK = "__lodash_hash_undefined__";
var iK = Object.prototype;
var nK = iK.hasOwnProperty;
function rK(X) {
  var Q = this.__data__;
  if (q1) {
    var $ = Q[X];
    return $ === dK ? void 0 : $;
  }
  return nK.call(Q, X) ? Q[X] : void 0;
}
var S7 = rK;
var oK = Object.prototype;
var tK = oK.hasOwnProperty;
function aK(X) {
  var Q = this.__data__;
  return q1 ? Q[X] !== void 0 : tK.call(Q, X);
}
var Z7 = aK;
var sK = "__lodash_hash_undefined__";
function eK(X, Q) {
  var $ = this.__data__;
  return this.size += this.has(X) ? 0 : 1, $[X] = q1 && Q === void 0 ? sK : Q, this;
}
var C7 = eK;
function A6(X) {
  var Q = -1, $ = X == null ? 0 : X.length;
  this.clear();
  while (++Q < $) {
    var Y = X[Q];
    this.set(Y[0], Y[1]);
  }
}
A6.prototype.clear = b7;
A6.prototype.delete = P7;
A6.prototype.get = S7;
A6.prototype.has = Z7;
A6.prototype.set = C7;
var W8 = A6;
function XU() {
  this.__data__ = [], this.size = 0;
}
var k7 = XU;
function QU(X, Q) {
  return X === Q || X !== X && Q !== Q;
}
var v7 = QU;
function $U(X, Q) {
  var $ = X.length;
  while ($--) if (v7(X[$][0], Q)) return $;
  return -1;
}
var Z1 = $U;
var YU = Array.prototype;
var WU = YU.splice;
function JU(X) {
  var Q = this.__data__, $ = Z1(Q, X);
  if ($ < 0) return false;
  var Y = Q.length - 1;
  if ($ == Y) Q.pop();
  else WU.call(Q, $, 1);
  return --this.size, true;
}
var T7 = JU;
function GU(X) {
  var Q = this.__data__, $ = Z1(Q, X);
  return $ < 0 ? void 0 : Q[$][1];
}
var _7 = GU;
function HU(X) {
  return Z1(this.__data__, X) > -1;
}
var x7 = HU;
function BU(X, Q) {
  var $ = this.__data__, Y = Z1($, X);
  if (Y < 0) ++this.size, $.push([X, Q]);
  else $[Y][1] = Q;
  return this;
}
var y7 = BU;
function w6(X) {
  var Q = -1, $ = X == null ? 0 : X.length;
  this.clear();
  while (++Q < $) {
    var Y = X[Q];
    this.set(Y[0], Y[1]);
  }
}
w6.prototype.clear = k7;
w6.prototype.delete = T7;
w6.prototype.get = _7;
w6.prototype.has = x7;
w6.prototype.set = y7;
var g7 = w6;
var zU = U4(O6, "Map");
var h7 = zU;
function KU() {
  this.size = 0, this.__data__ = { hash: new W8(), map: new (h7 || g7)(), string: new W8() };
}
var f7 = KU;
function UU(X) {
  var Q = typeof X;
  return Q == "string" || Q == "number" || Q == "symbol" || Q == "boolean" ? X !== "__proto__" : X === null;
}
var u7 = UU;
function VU(X, Q) {
  var $ = X.__data__;
  return u7(Q) ? $[typeof Q == "string" ? "string" : "hash"] : $.map;
}
var C1 = VU;
function LU(X) {
  var Q = C1(this, X).delete(X);
  return this.size -= Q ? 1 : 0, Q;
}
var l7 = LU;
function qU(X) {
  return C1(this, X).get(X);
}
var m7 = qU;
function FU(X) {
  return C1(this, X).has(X);
}
var c7 = FU;
function NU(X, Q) {
  var $ = C1(this, X), Y = $.size;
  return $.set(X, Q), this.size += $.size == Y ? 0 : 1, this;
}
var p7 = NU;
function M6(X) {
  var Q = -1, $ = X == null ? 0 : X.length;
  this.clear();
  while (++Q < $) {
    var Y = X[Q];
    this.set(Y[0], Y[1]);
  }
}
M6.prototype.clear = f7;
M6.prototype.delete = l7;
M6.prototype.get = m7;
M6.prototype.has = c7;
M6.prototype.set = p7;
var J8 = M6;
var OU = "Expected a function";
function G8(X, Q) {
  if (typeof X != "function" || Q != null && typeof Q != "function") throw TypeError(OU);
  var $ = function() {
    var Y = arguments, W = Q ? Q.apply(this, Y) : Y[0], J = $.cache;
    if (J.has(W)) return J.get(W);
    var G = X.apply(this, Y);
    return $.cache = J.set(W, G) || J, G;
  };
  return $.cache = new (G8.Cache || J8)(), $;
}
G8.Cache = J8;
var r1 = G8;
function d7(X) {
  if (process.stderr.destroyed) return;
  for (let Q = 0; Q < X.length; Q += 2e3) process.stderr.write(X.substring(Q, Q + 2e3));
}
var i7 = r1((X) => {
  if (!X || X.trim() === "") return null;
  let Q = X.split(",").map((J) => J.trim()).filter(Boolean);
  if (Q.length === 0) return null;
  let $ = Q.some((J) => J.startsWith("!")), Y = Q.some((J) => !J.startsWith("!"));
  if ($ && Y) return null;
  let W = Q.map((J) => J.replace(/^!/, "").toLowerCase());
  return { include: $ ? [] : W, exclude: $ ? W : [], isExclusive: $ };
});
function DU(X) {
  let Q = [], $ = X.match(/^MCP server ["']([^"']+)["']/);
  if ($ && $[1]) Q.push("mcp"), Q.push($[1].toLowerCase());
  else {
    let J = X.match(/^([^:[]+):/);
    if (J && J[1]) Q.push(J[1].trim().toLowerCase());
  }
  let Y = X.match(/^\[([^\]]+)]/);
  if (Y && Y[1]) Q.push(Y[1].trim().toLowerCase());
  if (X.toLowerCase().includes("statsig event:")) Q.push("statsig");
  let W = X.match(/:\s*([^:]+?)(?:\s+(?:type|mode|status|event))?:/);
  if (W && W[1]) {
    let J = W[1].trim().toLowerCase();
    if (J.length < 30 && !J.includes(" ")) Q.push(J);
  }
  return Array.from(new Set(Q));
}
function AU(X, Q) {
  if (!Q) return true;
  if (X.length === 0) return false;
  if (Q.isExclusive) return !X.some(($) => Q.exclude.includes($));
  else return X.some(($) => Q.include.includes($));
}
function n7(X, Q) {
  if (!Q) return true;
  let $ = DU(X);
  return AU($, Q);
}
function V4() {
  var _a;
  return (_a = process.env.CLAUDE_CONFIG_DIR) != null ? _a : (0, import_path4.join)((0, import_os.homedir)(), ".claude");
}
function H8(X) {
  if (!X) return false;
  if (typeof X === "boolean") return X;
  let Q = X.toLowerCase().trim();
  return ["1", "true", "yes", "on"].includes(Q);
}
function r7(X) {
  return { name: X, default: 3e4, validate: (Q) => {
    if (!Q) return { effective: 3e4, status: "valid" };
    let $ = parseInt(Q, 10);
    if (isNaN($) || $ <= 0) return { effective: 3e4, status: "invalid", message: `Invalid value "${Q}" (using default: 30000)` };
    if ($ > 15e4) return { effective: 15e4, status: "capped", message: `Capped from ${$} to 150000` };
    return { effective: $, status: "valid" };
  } };
}
var o7 = r7("BASH_MAX_OUTPUT_LENGTH");
var Db = r7("TASK_MAX_OUTPUT_LENGTH");
var t7 = { name: "CLAUDE_CODE_MAX_OUTPUT_TOKENS", default: 32e3, validate: (X) => {
  if (!X) return { effective: 32e3, status: "valid" };
  let Y = parseInt(X, 10);
  if (isNaN(Y) || Y <= 0) return { effective: 32e3, status: "invalid", message: `Invalid value "${X}" (using default: 32000)` };
  if (Y > 64e3) return { effective: 64e3, status: "capped", message: `Capped from ${Y} to 64000` };
  return { effective: Y, status: "valid" };
} };
function IU() {
  let X = "";
  if (typeof process < "u" && typeof process.cwd === "function") X = (0, import_fs.realpathSync)((0, import_process.cwd)());
  return { originalCwd: X, projectRoot: X, totalCostUSD: 0, totalAPIDuration: 0, totalAPIDurationWithoutRetries: 0, totalToolDuration: 0, startTime: Date.now(), lastInteractionTime: Date.now(), totalLinesAdded: 0, totalLinesRemoved: 0, hasUnknownModelCost: false, cwd: X, modelUsage: {}, mainLoopModelOverride: void 0, initialMainLoopModel: null, modelStrings: null, isInteractive: false, clientType: "cli", sessionIngressToken: void 0, oauthTokenFromFd: void 0, apiKeyFromFd: void 0, flagSettingsPath: void 0, allowedSettingSources: ["userSettings", "projectSettings", "localSettings", "flagSettings", "policySettings"], meter: null, sessionCounter: null, locCounter: null, prCounter: null, commitCounter: null, costCounter: null, tokenCounter: null, codeEditToolDecisionCounter: null, activeTimeCounter: null, sessionId: (0, import_crypto.randomUUID)(), parentSessionId: void 0, loggerProvider: null, eventLogger: null, meterProvider: null, tracerProvider: null, agentColorMap: /* @__PURE__ */ new Map(), agentColorIndex: 0, envVarValidators: [o7, t7], lastAPIRequest: null, inMemoryErrorLog: [], inlinePlugins: [], useCoworkPlugins: false, sessionBypassPermissionsMode: false, sessionTrustAccepted: false, sessionPersistenceDisabled: false, hasExitedPlanMode: false, needsPlanModeExitAttachment: false, hasExitedDelegateMode: false, needsDelegateModeExitAttachment: false, lspRecommendationShownThisSession: false, initJsonSchema: null, registeredHooks: null, planSlugCache: /* @__PURE__ */ new Map(), teleportedSessionInfo: null, invokedSkills: /* @__PURE__ */ new Map(), slowOperations: [], sdkBetas: void 0, mainThreadAgentType: void 0, isRemoteMode: false };
}
var bU = IU();
function a7() {
  return bU.sessionId;
}
function s7({ writeFn: X, flushIntervalMs: Q = 1e3, maxBufferSize: $ = 100, immediateMode: Y = false }) {
  let W = [], J = null;
  function G() {
    if (J) clearTimeout(J), J = null;
  }
  function H() {
    if (W.length === 0) return;
    X(W.join("")), W = [], G();
  }
  function B() {
    if (!J) J = setTimeout(H, Q);
  }
  return { write(z) {
    if (Y) {
      X(z);
      return;
    }
    if (W.push(z), B(), W.length >= $) H();
  }, flush: H, dispose() {
    H();
  } };
}
var e7 = /* @__PURE__ */ new Set();
function XW(X) {
  return e7.add(X), () => e7.delete(X);
}
var B8 = 1 / 0;
function PU(X) {
  if (X === null) return "null";
  if (X === void 0) return "undefined";
  if (Array.isArray(X)) return `Array[${X.length}]`;
  if (typeof X === "object") return `Object{${Object.keys(X).length} keys}`;
  if (typeof X === "string") return `string(${X.length} chars)`;
  return typeof X;
}
function QW(X, Q) {
  let $ = performance.now();
  try {
    return Q();
  } finally {
    performance.now() - $ > B8;
  }
}
function Z0(X, Q, $) {
  let Y = PU(X);
  return QW(`JSON.stringify(${Y})`, () => JSON.stringify(X, Q, $));
}
var L4 = (X, Q) => {
  let $ = typeof X === "string" ? X.length : 0;
  return QW(`JSON.parse(${$} chars)`, () => JSON.parse(X, Q));
};
var SU = r1(() => {
  return H8(process.env.DEBUG) || H8(process.env.DEBUG_SDK) || process.argv.includes("--debug") || process.argv.includes("-d") || YW() || process.argv.some((X) => X.startsWith("--debug="));
});
var ZU = r1(() => {
  let X = process.argv.find(($) => $.startsWith("--debug="));
  if (!X) return null;
  let Q = X.substring(8);
  return i7(Q);
});
var YW = r1(() => {
  return process.argv.includes("--debug-to-stderr") || process.argv.includes("-d2e");
});
function CU(X) {
  if (typeof process > "u" || typeof process.versions > "u" || typeof process.versions.node > "u") return false;
  let Q = ZU();
  return n7(X, Q);
}
var kU = false;
var q4 = null;
function vU() {
  if (!q4) q4 = s7({ writeFn: (X) => {
    let Q = WW();
    if (!n0().existsSync((0, import_path5.dirname)(Q))) n0().mkdirSync((0, import_path5.dirname)(Q));
    n0().appendFileSync(Q, X), TU();
  }, flushIntervalMs: 1e3, maxBufferSize: 100, immediateMode: SU() }), XW(async () => q4 == null ? void 0 : q4.dispose());
  return q4;
}
function k1(X, { level: Q } = { level: "debug" }) {
  if (!CU(X)) return;
  if (kU && X.includes(`
`)) X = Z0(X);
  let Y = `${(/* @__PURE__ */ new Date()).toISOString()} [${Q.toUpperCase()}] ${X.trim()}
`;
  if (YW()) {
    d7(Y);
    return;
  }
  vU().write(Y);
}
function WW() {
  var _a;
  return (_a = process.env.CLAUDE_CODE_DEBUG_LOGS_DIR) != null ? _a : (0, import_path5.join)(V4(), "debug", `${a7()}.txt`);
}
var TU = r1(() => {
  if (process.argv[2] === "--ripgrep") return;
  try {
    let X = WW(), Q = (0, import_path5.dirname)(X), $ = (0, import_path5.join)(Q, "latest");
    if (!n0().existsSync(Q)) n0().mkdirSync(Q);
    if (n0().existsSync($)) try {
      n0().unlinkSync($);
    } catch (e2) {
    }
    n0().symlinkSync(X, $);
  } catch (e2) {
  }
});
function F0(X, Q) {
  let $ = performance.now();
  try {
    return Q();
  } finally {
    performance.now() - $ > B8;
  }
}
var yU = { cwd() {
  return process.cwd();
}, existsSync(X) {
  return F0(`existsSync(${X})`, () => f.existsSync(X));
}, async stat(X) {
  return (0, import_promises.stat)(X);
}, statSync(X) {
  return F0(`statSync(${X})`, () => f.statSync(X));
}, lstatSync(X) {
  return F0(`lstatSync(${X})`, () => f.lstatSync(X));
}, readFileSync(X, Q) {
  return F0(`readFileSync(${X})`, () => f.readFileSync(X, { encoding: Q.encoding }));
}, readFileBytesSync(X) {
  return F0(`readFileBytesSync(${X})`, () => f.readFileSync(X));
}, readSync(X, Q) {
  return F0(`readSync(${X}, ${Q.length} bytes)`, () => {
    let $ = void 0;
    try {
      $ = f.openSync(X, "r");
      let Y = Buffer.alloc(Q.length), W = f.readSync($, Y, 0, Q.length, 0);
      return { buffer: Y, bytesRead: W };
    } finally {
      if ($) f.closeSync($);
    }
  });
}, appendFileSync(X, Q, $) {
  return F0(`appendFileSync(${X}, ${Q.length} chars)`, () => {
    if (!f.existsSync(X) && ($ == null ? void 0 : $.mode) !== void 0) {
      let Y = f.openSync(X, "a", $.mode);
      try {
        f.appendFileSync(Y, Q);
      } finally {
        f.closeSync(Y);
      }
    } else f.appendFileSync(X, Q);
  });
}, copyFileSync(X, Q) {
  return F0(`copyFileSync(${X} \u2192 ${Q})`, () => f.copyFileSync(X, Q));
}, unlinkSync(X) {
  return F0(`unlinkSync(${X})`, () => f.unlinkSync(X));
}, renameSync(X, Q) {
  return F0(`renameSync(${X} \u2192 ${Q})`, () => f.renameSync(X, Q));
}, linkSync(X, Q) {
  return F0(`linkSync(${X} \u2192 ${Q})`, () => f.linkSync(X, Q));
}, symlinkSync(X, Q) {
  return F0(`symlinkSync(${X} \u2192 ${Q})`, () => f.symlinkSync(X, Q));
}, readlinkSync(X) {
  return F0(`readlinkSync(${X})`, () => f.readlinkSync(X));
}, realpathSync(X) {
  return F0(`realpathSync(${X})`, () => f.realpathSync(X));
}, mkdirSync(X, Q) {
  return F0(`mkdirSync(${X})`, () => {
    if (!f.existsSync(X)) {
      let $ = { recursive: true };
      if ((Q == null ? void 0 : Q.mode) !== void 0) $.mode = Q.mode;
      f.mkdirSync(X, $);
    }
  });
}, readdirSync(X) {
  return F0(`readdirSync(${X})`, () => f.readdirSync(X, { withFileTypes: true }));
}, readdirStringSync(X) {
  return F0(`readdirStringSync(${X})`, () => f.readdirSync(X));
}, isDirEmptySync(X) {
  return F0(`isDirEmptySync(${X})`, () => {
    return this.readdirSync(X).length === 0;
  });
}, rmdirSync(X) {
  return F0(`rmdirSync(${X})`, () => f.rmdirSync(X));
}, rmSync(X, Q) {
  return F0(`rmSync(${X})`, () => f.rmSync(X, Q));
}, createWriteStream(X) {
  return f.createWriteStream(X);
} };
var gU = yU;
function n0() {
  return gU;
}
var F1 = class extends Error {
};
function j6() {
  return process.versions.bun !== void 0;
}
var F4 = null;
var GW = false;
function pU() {
  if (GW) return F4;
  if (GW = true, !process.env.DEBUG_CLAUDE_AGENT_SDK) return null;
  let X = (0, import_path6.join)(V4(), "debug");
  if (F4 = (0, import_path6.join)(X, `sdk-${(0, import_crypto2.randomUUID)()}.txt`), !(0, import_fs2.existsSync)(X)) (0, import_fs2.mkdirSync)(X, { recursive: true });
  return process.stderr.write(`SDK debug logs: ${F4}
`), F4;
}
function N1(X) {
  let Q = pU();
  if (!Q) return;
  let Y = `${(/* @__PURE__ */ new Date()).toISOString()} ${X}
`;
  (0, import_fs2.appendFileSync)(Q, Y);
}
function HW(X, Q) {
  let $ = { ...X };
  if (Q) {
    let Y = { sandbox: Q };
    if ($.settings) try {
      Y = { ...L4($.settings), sandbox: Q };
    } catch (e2) {
    }
    $.settings = Z0(Y);
  }
  return $;
}
var XX = class {
  constructor(X) {
    __publicField(this, "options");
    __publicField(this, "process");
    __publicField(this, "processStdin");
    __publicField(this, "processStdout");
    __publicField(this, "ready", false);
    __publicField(this, "abortController");
    __publicField(this, "exitError");
    __publicField(this, "exitListeners", []);
    __publicField(this, "processExitHandler");
    __publicField(this, "abortHandler");
    this.options = X;
    this.abortController = X.abortController || N6(), this.initialize();
  }
  getDefaultExecutable() {
    return j6() ? "bun" : "node";
  }
  spawnLocalProcess(X) {
    let { command: Q, args: $, cwd: Y, env: W, signal: J } = X, G = W.DEBUG_CLAUDE_AGENT_SDK || this.options.stderr ? "pipe" : "ignore", H = (0, import_child_process2.spawn)(Q, $, { cwd: Y, stdio: ["pipe", "pipe", G], signal: J, env: W, windowsHide: true });
    if (W.DEBUG_CLAUDE_AGENT_SDK || this.options.stderr) H.stderr.on("data", (z) => {
      let K = z.toString();
      if (N1(K), this.options.stderr) this.options.stderr(K);
    });
    return { stdin: H.stdin, stdout: H.stdout, get killed() {
      return H.killed;
    }, get exitCode() {
      return H.exitCode;
    }, kill: H.kill.bind(H), on: H.on.bind(H), once: H.once.bind(H), off: H.off.bind(H) };
  }
  initialize() {
    try {
      let { additionalDirectories: X = [], agent: Q, betas: $, cwd: Y, executable: W = this.getDefaultExecutable(), executableArgs: J = [], extraArgs: G = {}, pathToClaudeCodeExecutable: H, env: B = { ...process.env }, maxThinkingTokens: z, maxTurns: K, maxBudgetUsd: V, model: L, fallbackModel: U, jsonSchema: F, permissionMode: q, allowDangerouslySkipPermissions: N, permissionPromptToolName: A, continueConversation: M, resume: R, settingSources: S, allowedTools: C = [], disallowedTools: K0 = [], tools: U0, mcpServers: s, strictMcpConfig: D0, canUseTool: q0, includePartialMessages: W1, plugins: P1, sandbox: U6 } = this.options, d = ["--output-format", "stream-json", "--verbose", "--input-format", "stream-json"];
      if (z !== void 0) d.push("--max-thinking-tokens", z.toString());
      if (K) d.push("--max-turns", K.toString());
      if (V !== void 0) d.push("--max-budget-usd", V.toString());
      if (L) d.push("--model", L);
      if (Q) d.push("--agent", Q);
      if ($ && $.length > 0) d.push("--betas", $.join(","));
      if (F) d.push("--json-schema", Z0(F));
      if (B.DEBUG_CLAUDE_AGENT_SDK) d.push("--debug-to-stderr");
      if (q0) {
        if (A) throw Error("canUseTool callback cannot be used with permissionPromptToolName. Please use one or the other.");
        d.push("--permission-prompt-tool", "stdio");
      } else if (A) d.push("--permission-prompt-tool", A);
      if (M) d.push("--continue");
      if (R) d.push("--resume", R);
      if (C.length > 0) d.push("--allowedTools", C.join(","));
      if (K0.length > 0) d.push("--disallowedTools", K0.join(","));
      if (U0 !== void 0) if (Array.isArray(U0)) if (U0.length === 0) d.push("--tools", "");
      else d.push("--tools", U0.join(","));
      else d.push("--tools", "default");
      if (s && Object.keys(s).length > 0) d.push("--mcp-config", Z0({ mcpServers: s }));
      if (S) d.push("--setting-sources", S.join(","));
      if (D0) d.push("--strict-mcp-config");
      if (q) d.push("--permission-mode", q);
      if (N) d.push("--allow-dangerously-skip-permissions");
      if (U) {
        if (L && U === L) throw Error("Fallback model cannot be the same as the main model. Please specify a different model for fallbackModel option.");
        d.push("--fallback-model", U);
      }
      if (W1) d.push("--include-partial-messages");
      for (let S0 of X) d.push("--add-dir", S0);
      if (P1 && P1.length > 0) for (let S0 of P1) if (S0.type === "local") d.push("--plugin-dir", S0.path);
      else throw Error(`Unsupported plugin type: ${S0.type}`);
      if (this.options.forkSession) d.push("--fork-session");
      if (this.options.resumeSessionAt) d.push("--resume-session-at", this.options.resumeSessionAt);
      if (this.options.persistSession === false) d.push("--no-session-persistence");
      let Q8 = HW(G != null ? G : {}, U6);
      for (let [S0, S1] of Object.entries(Q8)) if (S1 === null) d.push(`--${S0}`);
      else d.push(`--${S0}`, S1);
      if (!B.CLAUDE_CODE_ENTRYPOINT) B.CLAUDE_CODE_ENTRYPOINT = "sdk-ts";
      if (delete B.NODE_OPTIONS, B.DEBUG_CLAUDE_AGENT_SDK) B.DEBUG = "1";
      else delete B.DEBUG;
      let o6 = nU(H), V6 = o6 ? H : W, t6 = o6 ? [...J, ...d] : [...J, H, ...d], a6 = { command: V6, args: t6, cwd: Y, env: B, signal: this.abortController.signal };
      if (this.options.spawnClaudeCodeProcess) N1(`Spawning Claude Code (custom): ${V6} ${t6.join(" ")}`), this.process = this.options.spawnClaudeCodeProcess(a6);
      else {
        if (!n0().existsSync(H)) {
          let S1 = o6 ? `Claude Code native binary not found at ${H}. Please ensure Claude Code is installed via native installer or specify a valid path with options.pathToClaudeCodeExecutable.` : `Claude Code executable not found at ${H}. Is options.pathToClaudeCodeExecutable set?`;
          throw ReferenceError(S1);
        }
        N1(`Spawning Claude Code: ${V6} ${t6.join(" ")}`), this.process = this.spawnLocalProcess(a6);
      }
      this.processStdin = this.process.stdin, this.processStdout = this.process.stdout;
      let B4 = () => {
        if (this.process && !this.process.killed) this.process.kill("SIGTERM");
      };
      this.processExitHandler = B4, this.abortHandler = B4, process.on("exit", this.processExitHandler), this.abortController.signal.addEventListener("abort", this.abortHandler), this.process.on("error", (S0) => {
        if (this.ready = false, this.abortController.signal.aborted) this.exitError = new F1("Claude Code process aborted by user");
        else this.exitError = Error(`Failed to spawn Claude Code process: ${S0.message}`), N1(this.exitError.message);
      }), this.process.on("exit", (S0, S1) => {
        if (this.ready = false, this.abortController.signal.aborted) this.exitError = new F1("Claude Code process aborted by user");
        else {
          let s6 = this.getProcessExitError(S0, S1);
          if (s6) this.exitError = s6, N1(s6.message);
        }
      }), this.ready = true;
    } catch (X) {
      throw this.ready = false, X;
    }
  }
  getProcessExitError(X, Q) {
    if (X !== 0 && X !== null) return Error(`Claude Code process exited with code ${X}`);
    else if (Q) return Error(`Claude Code process terminated by signal ${Q}`);
    return;
  }
  write(X) {
    var _a, _b;
    if (this.abortController.signal.aborted) throw new F1("Operation aborted");
    if (!this.ready || !this.processStdin) throw Error("ProcessTransport is not ready for writing");
    if (((_a = this.process) == null ? void 0 : _a.killed) || ((_b = this.process) == null ? void 0 : _b.exitCode) !== null) throw Error("Cannot write to terminated process");
    if (this.exitError) throw Error(`Cannot write to process that exited with error: ${this.exitError.message}`);
    N1(`[ProcessTransport] Writing to stdin: ${X.substring(0, 100)}`);
    try {
      if (!this.processStdin.write(X)) N1("[ProcessTransport] Write buffer full, data queued");
    } catch (Q) {
      throw this.ready = false, Error(`Failed to write to process stdin: ${Q.message}`);
    }
  }
  close() {
    var _a;
    if (this.processStdin) this.processStdin.end(), this.processStdin = void 0;
    if (this.abortHandler) this.abortController.signal.removeEventListener("abort", this.abortHandler), this.abortHandler = void 0;
    for (let { handler: X } of this.exitListeners) (_a = this.process) == null ? void 0 : _a.off("exit", X);
    if (this.exitListeners = [], this.process && !this.process.killed) this.process.kill("SIGTERM"), setTimeout(() => {
      if (this.process && !this.process.killed) this.process.kill("SIGKILL");
    }, 5e3);
    if (this.ready = false, this.processExitHandler) process.off("exit", this.processExitHandler), this.processExitHandler = void 0;
  }
  isReady() {
    return this.ready;
  }
  async *readMessages() {
    if (!this.processStdout) throw Error("ProcessTransport output stream not available");
    let X = (0, import_readline.createInterface)({ input: this.processStdout });
    try {
      for await (let Q of X) if (Q.trim()) try {
        yield L4(Q);
      } catch ($) {
        throw N1(`Non-JSON stdout: ${Q}`), Error(`CLI output was not valid JSON. This may indicate an error during startup. Output: ${Q.slice(0, 200)}${Q.length > 200 ? "..." : ""}`);
      }
      await this.waitForExit();
    } catch (Q) {
      throw Q;
    } finally {
      X.close();
    }
  }
  endInput() {
    if (this.processStdin) this.processStdin.end();
  }
  getInputStream() {
    return this.processStdin;
  }
  onExit(X) {
    if (!this.process) return () => {
    };
    let Q = ($, Y) => {
      let W = this.getProcessExitError($, Y);
      X(W);
    };
    return this.process.on("exit", Q), this.exitListeners.push({ callback: X, handler: Q }), () => {
      if (this.process) this.process.off("exit", Q);
      let $ = this.exitListeners.findIndex((Y) => Y.handler === Q);
      if ($ !== -1) this.exitListeners.splice($, 1);
    };
  }
  async waitForExit() {
    if (!this.process) {
      if (this.exitError) throw this.exitError;
      return;
    }
    if (this.process.exitCode !== null || this.process.killed) {
      if (this.exitError) throw this.exitError;
      return;
    }
    return new Promise((X, Q) => {
      let $ = (W, J) => {
        if (this.abortController.signal.aborted) {
          Q(new F1("Operation aborted"));
          return;
        }
        let G = this.getProcessExitError(W, J);
        if (G) Q(G);
        else X();
      };
      this.process.once("exit", $);
      let Y = (W) => {
        this.process.off("exit", $), Q(W);
      };
      this.process.once("error", Y), this.process.once("exit", () => {
        this.process.off("error", Y);
      });
    });
  }
};
function nU(X) {
  return ![".js", ".mjs", ".tsx", ".ts", ".jsx"].some(($) => X.endsWith($));
}
var QX = class {
  constructor(X) {
    __publicField(this, "returned");
    __publicField(this, "queue", []);
    __publicField(this, "readResolve");
    __publicField(this, "readReject");
    __publicField(this, "isDone", false);
    __publicField(this, "hasError");
    __publicField(this, "started", false);
    this.returned = X;
  }
  [Symbol.asyncIterator]() {
    if (this.started) throw Error("Stream can only be iterated once");
    return this.started = true, this;
  }
  next() {
    if (this.queue.length > 0) return Promise.resolve({ done: false, value: this.queue.shift() });
    if (this.isDone) return Promise.resolve({ done: true, value: void 0 });
    if (this.hasError) return Promise.reject(this.hasError);
    return new Promise((X, Q) => {
      this.readResolve = X, this.readReject = Q;
    });
  }
  enqueue(X) {
    if (this.readResolve) {
      let Q = this.readResolve;
      this.readResolve = void 0, this.readReject = void 0, Q({ done: false, value: X });
    } else this.queue.push(X);
  }
  done() {
    if (this.isDone = true, this.readResolve) {
      let X = this.readResolve;
      this.readResolve = void 0, this.readReject = void 0, X({ done: true, value: void 0 });
    }
  }
  error(X) {
    if (this.hasError = X, this.readReject) {
      let Q = this.readReject;
      this.readResolve = void 0, this.readReject = void 0, Q(X);
    }
  }
  return() {
    if (this.isDone = true, this.returned) this.returned();
    return Promise.resolve({ done: true, value: void 0 });
  }
};
var K8 = class {
  constructor(X) {
    __publicField(this, "sendMcpMessage");
    __publicField(this, "isClosed", false);
    __publicField(this, "onclose");
    __publicField(this, "onerror");
    __publicField(this, "onmessage");
    this.sendMcpMessage = X;
  }
  async start() {
  }
  async send(X) {
    if (this.isClosed) throw Error("Transport is closed");
    this.sendMcpMessage(X);
  }
  async close() {
    var _a;
    if (this.isClosed) return;
    this.isClosed = true, (_a = this.onclose) == null ? void 0 : _a.call(this);
  }
};
var $X = class {
  constructor(X, Q, $, Y, W, J = /* @__PURE__ */ new Map(), G, H) {
    __publicField(this, "transport");
    __publicField(this, "isSingleUserTurn");
    __publicField(this, "canUseTool");
    __publicField(this, "hooks");
    __publicField(this, "abortController");
    __publicField(this, "jsonSchema");
    __publicField(this, "initConfig");
    __publicField(this, "pendingControlResponses", /* @__PURE__ */ new Map());
    __publicField(this, "cleanupPerformed", false);
    __publicField(this, "sdkMessages");
    __publicField(this, "inputStream", new QX());
    __publicField(this, "initialization");
    __publicField(this, "cancelControllers", /* @__PURE__ */ new Map());
    __publicField(this, "hookCallbacks", /* @__PURE__ */ new Map());
    __publicField(this, "nextCallbackId", 0);
    __publicField(this, "sdkMcpTransports", /* @__PURE__ */ new Map());
    __publicField(this, "sdkMcpServerInstances", /* @__PURE__ */ new Map());
    __publicField(this, "pendingMcpResponses", /* @__PURE__ */ new Map());
    __publicField(this, "firstResultReceivedResolve");
    __publicField(this, "firstResultReceived", false);
    this.transport = X;
    this.isSingleUserTurn = Q;
    this.canUseTool = $;
    this.hooks = Y;
    this.abortController = W;
    this.jsonSchema = G;
    this.initConfig = H;
    for (let [B, z] of J) this.connectSdkMcpServer(B, z);
    this.sdkMessages = this.readSdkMessages(), this.readMessages(), this.initialization = this.initialize(), this.initialization.catch(() => {
    });
  }
  hasBidirectionalNeeds() {
    return this.sdkMcpTransports.size > 0 || this.hooks !== void 0 && Object.keys(this.hooks).length > 0 || this.canUseTool !== void 0;
  }
  setError(X) {
    this.inputStream.error(X);
  }
  close() {
    this.cleanup();
  }
  cleanup(X) {
    if (this.cleanupPerformed) return;
    this.cleanupPerformed = true;
    try {
      this.transport.close(), this.pendingControlResponses.clear(), this.pendingMcpResponses.clear(), this.cancelControllers.clear(), this.hookCallbacks.clear();
      for (let Q of this.sdkMcpTransports.values()) try {
        Q.close();
      } catch (e2) {
      }
      if (this.sdkMcpTransports.clear(), X) this.inputStream.error(X);
      else this.inputStream.done();
    } catch (Q) {
    }
  }
  next(...[X]) {
    return this.sdkMessages.next(...[X]);
  }
  return(X) {
    return this.sdkMessages.return(X);
  }
  throw(X) {
    return this.sdkMessages.throw(X);
  }
  [Symbol.asyncIterator]() {
    return this.sdkMessages;
  }
  [Symbol.asyncDispose]() {
    return this.sdkMessages[Symbol.asyncDispose]();
  }
  async readMessages() {
    try {
      for await (let X of this.transport.readMessages()) {
        if (X.type === "control_response") {
          let Q = this.pendingControlResponses.get(X.response.request_id);
          if (Q) Q(X.response);
          continue;
        } else if (X.type === "control_request") {
          this.handleControlRequest(X);
          continue;
        } else if (X.type === "control_cancel_request") {
          this.handleControlCancelRequest(X);
          continue;
        } else if (X.type === "keep_alive") continue;
        if (X.type === "result") {
          if (this.firstResultReceived = true, this.firstResultReceivedResolve) this.firstResultReceivedResolve();
          if (this.isSingleUserTurn) k1("[Query.readMessages] First result received for single-turn query, closing stdin"), this.transport.endInput();
        }
        this.inputStream.enqueue(X);
      }
      if (this.firstResultReceivedResolve) this.firstResultReceivedResolve();
      this.inputStream.done(), this.cleanup();
    } catch (X) {
      if (this.firstResultReceivedResolve) this.firstResultReceivedResolve();
      this.inputStream.error(X), this.cleanup(X);
    }
  }
  async handleControlRequest(X) {
    let Q = new AbortController();
    this.cancelControllers.set(X.request_id, Q);
    try {
      let $ = await this.processControlRequest(X, Q.signal), Y = { type: "control_response", response: { subtype: "success", request_id: X.request_id, response: $ } };
      await Promise.resolve(this.transport.write(Z0(Y) + `
`));
    } catch ($) {
      let Y = { type: "control_response", response: { subtype: "error", request_id: X.request_id, error: $.message || String($) } };
      await Promise.resolve(this.transport.write(Z0(Y) + `
`));
    } finally {
      this.cancelControllers.delete(X.request_id);
    }
  }
  handleControlCancelRequest(X) {
    let Q = this.cancelControllers.get(X.request_id);
    if (Q) Q.abort(), this.cancelControllers.delete(X.request_id);
  }
  async processControlRequest(X, Q) {
    if (X.request.subtype === "can_use_tool") {
      if (!this.canUseTool) throw Error("canUseTool callback is not provided.");
      return { ...await this.canUseTool(X.request.tool_name, X.request.input, { signal: Q, suggestions: X.request.permission_suggestions, blockedPath: X.request.blocked_path, decisionReason: X.request.decision_reason, toolUseID: X.request.tool_use_id, agentID: X.request.agent_id }), toolUseID: X.request.tool_use_id };
    } else if (X.request.subtype === "hook_callback") return await this.handleHookCallbacks(X.request.callback_id, X.request.input, X.request.tool_use_id, Q);
    else if (X.request.subtype === "mcp_message") {
      let $ = X.request, Y = this.sdkMcpTransports.get($.server_name);
      if (!Y) throw Error(`SDK MCP server not found: ${$.server_name}`);
      if ("method" in $.message && "id" in $.message && $.message.id !== null) return { mcp_response: await this.handleMcpControlRequest($.server_name, $, Y) };
      else {
        if (Y.onmessage) Y.onmessage($.message);
        return { mcp_response: { jsonrpc: "2.0", result: {}, id: 0 } };
      }
    }
    throw Error("Unsupported control request subtype: " + X.request.subtype);
  }
  async *readSdkMessages() {
    for await (let X of this.inputStream) yield X;
  }
  async initialize() {
    var _a, _b, _c;
    let X;
    if (this.hooks) {
      X = {};
      for (let [W, J] of Object.entries(this.hooks)) if (J.length > 0) X[W] = J.map((G) => {
        let H = [];
        for (let B of G.hooks) {
          let z = `hook_${this.nextCallbackId++}`;
          this.hookCallbacks.set(z, B), H.push(z);
        }
        return { matcher: G.matcher, hookCallbackIds: H, timeout: G.timeout };
      });
    }
    let Q = this.sdkMcpTransports.size > 0 ? Array.from(this.sdkMcpTransports.keys()) : void 0, $ = { subtype: "initialize", hooks: X, sdkMcpServers: Q, jsonSchema: this.jsonSchema, systemPrompt: (_a = this.initConfig) == null ? void 0 : _a.systemPrompt, appendSystemPrompt: (_b = this.initConfig) == null ? void 0 : _b.appendSystemPrompt, agents: (_c = this.initConfig) == null ? void 0 : _c.agents };
    return (await this.request($)).response;
  }
  async interrupt() {
    await this.request({ subtype: "interrupt" });
  }
  async setPermissionMode(X) {
    await this.request({ subtype: "set_permission_mode", mode: X });
  }
  async setModel(X) {
    await this.request({ subtype: "set_model", model: X });
  }
  async setMaxThinkingTokens(X) {
    await this.request({ subtype: "set_max_thinking_tokens", max_thinking_tokens: X });
  }
  async rewindFiles(X, Q) {
    return (await this.request({ subtype: "rewind_files", user_message_id: X, dry_run: Q == null ? void 0 : Q.dryRun })).response;
  }
  async processPendingPermissionRequests(X) {
    for (let Q of X) if (Q.request.subtype === "can_use_tool") this.handleControlRequest(Q).catch(() => {
    });
  }
  request(X) {
    let Q = Math.random().toString(36).substring(2, 15), $ = { request_id: Q, type: "control_request", request: X };
    return new Promise((Y, W) => {
      this.pendingControlResponses.set(Q, (J) => {
        if (J.subtype === "success") Y(J);
        else if (W(Error(J.error)), J.pending_permission_requests) this.processPendingPermissionRequests(J.pending_permission_requests);
      }), Promise.resolve(this.transport.write(Z0($) + `
`));
    });
  }
  async supportedCommands() {
    return (await this.initialization).commands;
  }
  async supportedModels() {
    return (await this.initialization).models;
  }
  async mcpServerStatus() {
    return (await this.request({ subtype: "mcp_status" })).response.mcpServers;
  }
  async setMcpServers(X) {
    let Q = {}, $ = {};
    for (let [H, B] of Object.entries(X)) if (B.type === "sdk" && "instance" in B) Q[H] = B.instance;
    else $[H] = B;
    let Y = new Set(this.sdkMcpServerInstances.keys()), W = new Set(Object.keys(Q));
    for (let H of Y) if (!W.has(H)) await this.disconnectSdkMcpServer(H);
    for (let [H, B] of Object.entries(Q)) if (!Y.has(H)) this.connectSdkMcpServer(H, B);
    let J = {};
    for (let H of Object.keys(Q)) J[H] = { type: "sdk", name: H };
    return (await this.request({ subtype: "mcp_set_servers", servers: { ...$, ...J } })).response;
  }
  async accountInfo() {
    return (await this.initialization).account;
  }
  async streamInput(X) {
    var _a;
    k1("[Query.streamInput] Starting to process input stream");
    try {
      let Q = 0;
      for await (let $ of X) {
        if (Q++, k1(`[Query.streamInput] Processing message ${Q}: ${$.type}`), (_a = this.abortController) == null ? void 0 : _a.signal.aborted) break;
        await Promise.resolve(this.transport.write(Z0($) + `
`));
      }
      if (k1(`[Query.streamInput] Finished processing ${Q} messages from input stream`), Q > 0 && this.hasBidirectionalNeeds()) k1("[Query.streamInput] Has bidirectional needs, waiting for first result"), await this.waitForFirstResult();
      k1("[Query] Calling transport.endInput() to close stdin to CLI process"), this.transport.endInput();
    } catch (Q) {
      if (!(Q instanceof F1)) throw Q;
    }
  }
  waitForFirstResult() {
    if (this.firstResultReceived) return k1("[Query.waitForFirstResult] Result already received, returning immediately"), Promise.resolve();
    return new Promise((X) => {
      var _a, _b;
      if ((_a = this.abortController) == null ? void 0 : _a.signal.aborted) {
        X();
        return;
      }
      (_b = this.abortController) == null ? void 0 : _b.signal.addEventListener("abort", () => X(), { once: true }), this.firstResultReceivedResolve = X;
    });
  }
  handleHookCallbacks(X, Q, $, Y) {
    let W = this.hookCallbacks.get(X);
    if (!W) throw Error(`No hook callback found for ID: ${X}`);
    return W(Q, $, { signal: Y });
  }
  connectSdkMcpServer(X, Q) {
    let $ = new K8((Y) => this.sendMcpServerMessageToCli(X, Y));
    this.sdkMcpTransports.set(X, $), this.sdkMcpServerInstances.set(X, Q), Q.connect($);
  }
  async disconnectSdkMcpServer(X) {
    let Q = this.sdkMcpTransports.get(X);
    if (Q) await Q.close(), this.sdkMcpTransports.delete(X);
    this.sdkMcpServerInstances.delete(X);
  }
  sendMcpServerMessageToCli(X, Q) {
    if ("id" in Q && Q.id !== null && Q.id !== void 0) {
      let Y = `${X}:${Q.id}`, W = this.pendingMcpResponses.get(Y);
      if (W) {
        W.resolve(Q), this.pendingMcpResponses.delete(Y);
        return;
      }
    }
    let $ = { type: "control_request", request_id: (0, import_crypto3.randomUUID)(), request: { subtype: "mcp_message", server_name: X, message: Q } };
    this.transport.write(Z0($) + `
`);
  }
  handleMcpControlRequest(X, Q, $) {
    let Y = "id" in Q.message ? Q.message.id : null, W = `${X}:${Y}`;
    return new Promise((J, G) => {
      let H = () => {
        this.pendingMcpResponses.delete(W);
      }, B = (K) => {
        H(), J(K);
      }, z = (K) => {
        H(), G(K);
      };
      if (this.pendingMcpResponses.set(W, { resolve: B, reject: z }), $.onmessage) $.onmessage(Q.message);
      else {
        H(), G(Error("No message handler registered"));
        return;
      }
    });
  }
};
var n;
(function(X) {
  X.assertEqual = (W) => {
  };
  function Q(W) {
  }
  X.assertIs = Q;
  function $(W) {
    throw Error();
  }
  X.assertNever = $, X.arrayToEnum = (W) => {
    let J = {};
    for (let G of W) J[G] = G;
    return J;
  }, X.getValidEnumValues = (W) => {
    let J = X.objectKeys(W).filter((H) => typeof W[W[H]] !== "number"), G = {};
    for (let H of J) G[H] = W[H];
    return X.objectValues(G);
  }, X.objectValues = (W) => {
    return X.objectKeys(W).map(function(J) {
      return W[J];
    });
  }, X.objectKeys = typeof Object.keys === "function" ? (W) => Object.keys(W) : (W) => {
    let J = [];
    for (let G in W) if (Object.prototype.hasOwnProperty.call(W, G)) J.push(G);
    return J;
  }, X.find = (W, J) => {
    for (let G of W) if (J(G)) return G;
    return;
  }, X.isInteger = typeof Number.isInteger === "function" ? (W) => Number.isInteger(W) : (W) => typeof W === "number" && Number.isFinite(W) && Math.floor(W) === W;
  function Y(W, J = " | ") {
    return W.map((G) => typeof G === "string" ? `'${G}'` : G).join(J);
  }
  X.joinValues = Y, X.jsonStringifyReplacer = (W, J) => {
    if (typeof J === "bigint") return J.toString();
    return J;
  };
})(n || (n = {}));
var KW;
(function(X) {
  X.mergeShapes = (Q, $) => {
    return { ...Q, ...$ };
  };
})(KW || (KW = {}));
var E = n.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]);
var O1 = (X) => {
  switch (typeof X) {
    case "undefined":
      return E.undefined;
    case "string":
      return E.string;
    case "number":
      return Number.isNaN(X) ? E.nan : E.number;
    case "boolean":
      return E.boolean;
    case "function":
      return E.function;
    case "bigint":
      return E.bigint;
    case "symbol":
      return E.symbol;
    case "object":
      if (Array.isArray(X)) return E.array;
      if (X === null) return E.null;
      if (X.then && typeof X.then === "function" && X.catch && typeof X.catch === "function") return E.promise;
      if (typeof Map < "u" && X instanceof Map) return E.map;
      if (typeof Set < "u" && X instanceof Set) return E.set;
      if (typeof Date < "u" && X instanceof Date) return E.date;
      return E.object;
    default:
      return E.unknown;
  }
};
var w = n.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]);
var f0 = class _f0 extends Error {
  get errors() {
    return this.issues;
  }
  constructor(X) {
    super();
    this.issues = [], this.addIssue = ($) => {
      this.issues = [...this.issues, $];
    }, this.addIssues = ($ = []) => {
      this.issues = [...this.issues, ...$];
    };
    let Q = new.target.prototype;
    if (Object.setPrototypeOf) Object.setPrototypeOf(this, Q);
    else this.__proto__ = Q;
    this.name = "ZodError", this.issues = X;
  }
  format(X) {
    let Q = X || function(W) {
      return W.message;
    }, $ = { _errors: [] }, Y = (W) => {
      for (let J of W.issues) if (J.code === "invalid_union") J.unionErrors.map(Y);
      else if (J.code === "invalid_return_type") Y(J.returnTypeError);
      else if (J.code === "invalid_arguments") Y(J.argumentsError);
      else if (J.path.length === 0) $._errors.push(Q(J));
      else {
        let G = $, H = 0;
        while (H < J.path.length) {
          let B = J.path[H];
          if (H !== J.path.length - 1) G[B] = G[B] || { _errors: [] };
          else G[B] = G[B] || { _errors: [] }, G[B]._errors.push(Q(J));
          G = G[B], H++;
        }
      }
    };
    return Y(this), $;
  }
  static assert(X) {
    if (!(X instanceof _f0)) throw Error(`Not a ZodError: ${X}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, n.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(X = (Q) => Q.message) {
    let Q = {}, $ = [];
    for (let Y of this.issues) if (Y.path.length > 0) {
      let W = Y.path[0];
      Q[W] = Q[W] || [], Q[W].push(X(Y));
    } else $.push(X(Y));
    return { formErrors: $, fieldErrors: Q };
  }
  get formErrors() {
    return this.flatten();
  }
};
f0.create = (X) => {
  return new f0(X);
};
var tU = (X, Q) => {
  let $;
  switch (X.code) {
    case w.invalid_type:
      if (X.received === E.undefined) $ = "Required";
      else $ = `Expected ${X.expected}, received ${X.received}`;
      break;
    case w.invalid_literal:
      $ = `Invalid literal value, expected ${JSON.stringify(X.expected, n.jsonStringifyReplacer)}`;
      break;
    case w.unrecognized_keys:
      $ = `Unrecognized key(s) in object: ${n.joinValues(X.keys, ", ")}`;
      break;
    case w.invalid_union:
      $ = "Invalid input";
      break;
    case w.invalid_union_discriminator:
      $ = `Invalid discriminator value. Expected ${n.joinValues(X.options)}`;
      break;
    case w.invalid_enum_value:
      $ = `Invalid enum value. Expected ${n.joinValues(X.options)}, received '${X.received}'`;
      break;
    case w.invalid_arguments:
      $ = "Invalid function arguments";
      break;
    case w.invalid_return_type:
      $ = "Invalid function return type";
      break;
    case w.invalid_date:
      $ = "Invalid date";
      break;
    case w.invalid_string:
      if (typeof X.validation === "object") if ("includes" in X.validation) {
        if ($ = `Invalid input: must include "${X.validation.includes}"`, typeof X.validation.position === "number") $ = `${$} at one or more positions greater than or equal to ${X.validation.position}`;
      } else if ("startsWith" in X.validation) $ = `Invalid input: must start with "${X.validation.startsWith}"`;
      else if ("endsWith" in X.validation) $ = `Invalid input: must end with "${X.validation.endsWith}"`;
      else n.assertNever(X.validation);
      else if (X.validation !== "regex") $ = `Invalid ${X.validation}`;
      else $ = "Invalid";
      break;
    case w.too_small:
      if (X.type === "array") $ = `Array must contain ${X.exact ? "exactly" : X.inclusive ? "at least" : "more than"} ${X.minimum} element(s)`;
      else if (X.type === "string") $ = `String must contain ${X.exact ? "exactly" : X.inclusive ? "at least" : "over"} ${X.minimum} character(s)`;
      else if (X.type === "number") $ = `Number must be ${X.exact ? "exactly equal to " : X.inclusive ? "greater than or equal to " : "greater than "}${X.minimum}`;
      else if (X.type === "bigint") $ = `Number must be ${X.exact ? "exactly equal to " : X.inclusive ? "greater than or equal to " : "greater than "}${X.minimum}`;
      else if (X.type === "date") $ = `Date must be ${X.exact ? "exactly equal to " : X.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(X.minimum))}`;
      else $ = "Invalid input";
      break;
    case w.too_big:
      if (X.type === "array") $ = `Array must contain ${X.exact ? "exactly" : X.inclusive ? "at most" : "less than"} ${X.maximum} element(s)`;
      else if (X.type === "string") $ = `String must contain ${X.exact ? "exactly" : X.inclusive ? "at most" : "under"} ${X.maximum} character(s)`;
      else if (X.type === "number") $ = `Number must be ${X.exact ? "exactly" : X.inclusive ? "less than or equal to" : "less than"} ${X.maximum}`;
      else if (X.type === "bigint") $ = `BigInt must be ${X.exact ? "exactly" : X.inclusive ? "less than or equal to" : "less than"} ${X.maximum}`;
      else if (X.type === "date") $ = `Date must be ${X.exact ? "exactly" : X.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(X.maximum))}`;
      else $ = "Invalid input";
      break;
    case w.custom:
      $ = "Invalid input";
      break;
    case w.invalid_intersection_types:
      $ = "Intersection results could not be merged";
      break;
    case w.not_multiple_of:
      $ = `Number must be a multiple of ${X.multipleOf}`;
      break;
    case w.not_finite:
      $ = "Number must be finite";
      break;
    default:
      $ = Q.defaultError, n.assertNever(X);
  }
  return { message: $ };
};
var v1 = tU;
var aU = v1;
function YX() {
  return aU;
}
var N4 = (X) => {
  let { data: Q, path: $, errorMaps: Y, issueData: W } = X, J = [...$, ...W.path || []], G = { ...W, path: J };
  if (W.message !== void 0) return { ...W, path: J, message: W.message };
  let H = "", B = Y.filter((z) => !!z).slice().reverse();
  for (let z of B) H = z(G, { data: Q, defaultError: H }).message;
  return { ...W, path: J, message: H };
};
function b(X, Q) {
  let $ = YX(), Y = N4({ issueData: Q, data: X.data, path: X.path, errorMaps: [X.common.contextualErrorMap, X.schemaErrorMap, $, $ === v1 ? void 0 : v1].filter((W) => !!W) });
  X.common.issues.push(Y);
}
var I0 = class _I0 {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid") this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted") this.value = "aborted";
  }
  static mergeArray(X, Q) {
    let $ = [];
    for (let Y of Q) {
      if (Y.status === "aborted") return g;
      if (Y.status === "dirty") X.dirty();
      $.push(Y.value);
    }
    return { status: X.value, value: $ };
  }
  static async mergeObjectAsync(X, Q) {
    let $ = [];
    for (let Y of Q) {
      let W = await Y.key, J = await Y.value;
      $.push({ key: W, value: J });
    }
    return _I0.mergeObjectSync(X, $);
  }
  static mergeObjectSync(X, Q) {
    let $ = {};
    for (let Y of Q) {
      let { key: W, value: J } = Y;
      if (W.status === "aborted") return g;
      if (J.status === "aborted") return g;
      if (W.status === "dirty") X.dirty();
      if (J.status === "dirty") X.dirty();
      if (W.value !== "__proto__" && (typeof J.value < "u" || Y.alwaysSet)) $[W.value] = J.value;
    }
    return { status: X.value, value: $ };
  }
};
var g = Object.freeze({ status: "aborted" });
var R6 = (X) => ({ status: "dirty", value: X });
var C0 = (X) => ({ status: "valid", value: X });
var L8 = (X) => X.status === "aborted";
var q8 = (X) => X.status === "dirty";
var o1 = (X) => X.status === "valid";
var WX = (X) => typeof Promise < "u" && X instanceof Promise;
var Z;
(function(X) {
  X.errToObj = (Q) => typeof Q === "string" ? { message: Q } : Q || {}, X.toString = (Q) => typeof Q === "string" ? Q : Q == null ? void 0 : Q.message;
})(Z || (Z = {}));
var r0 = class {
  constructor(X, Q, $, Y) {
    this._cachedPath = [], this.parent = X, this.data = Q, this._path = $, this._key = Y;
  }
  get path() {
    if (!this._cachedPath.length) if (Array.isArray(this._key)) this._cachedPath.push(...this._path, ...this._key);
    else this._cachedPath.push(...this._path, this._key);
    return this._cachedPath;
  }
};
var UW = (X, Q) => {
  if (o1(Q)) return { success: true, data: Q.value };
  else {
    if (!X.common.issues.length) throw Error("Validation failed but no issues detected.");
    return { success: false, get error() {
      if (this._error) return this._error;
      let $ = new f0(X.common.issues);
      return this._error = $, this._error;
    } };
  }
};
function l(X) {
  if (!X) return {};
  let { errorMap: Q, invalid_type_error: $, required_error: Y, description: W } = X;
  if (Q && ($ || Y)) throw Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  if (Q) return { errorMap: Q, description: W };
  return { errorMap: (G, H) => {
    var _a, _b;
    let { message: B } = X;
    if (G.code === "invalid_enum_value") return { message: B != null ? B : H.defaultError };
    if (typeof H.data > "u") return { message: (_a = B != null ? B : Y) != null ? _a : H.defaultError };
    if (G.code !== "invalid_type") return { message: H.defaultError };
    return { message: (_b = B != null ? B : $) != null ? _b : H.defaultError };
  }, description: W };
}
var p = class {
  get description() {
    return this._def.description;
  }
  _getType(X) {
    return O1(X.data);
  }
  _getOrReturnCtx(X, Q) {
    return Q || { common: X.parent.common, data: X.data, parsedType: O1(X.data), schemaErrorMap: this._def.errorMap, path: X.path, parent: X.parent };
  }
  _processInputParams(X) {
    return { status: new I0(), ctx: { common: X.parent.common, data: X.data, parsedType: O1(X.data), schemaErrorMap: this._def.errorMap, path: X.path, parent: X.parent } };
  }
  _parseSync(X) {
    let Q = this._parse(X);
    if (WX(Q)) throw Error("Synchronous parse encountered promise.");
    return Q;
  }
  _parseAsync(X) {
    let Q = this._parse(X);
    return Promise.resolve(Q);
  }
  parse(X, Q) {
    let $ = this.safeParse(X, Q);
    if ($.success) return $.data;
    throw $.error;
  }
  safeParse(X, Q) {
    var _a;
    let $ = { common: { issues: [], async: (_a = Q == null ? void 0 : Q.async) != null ? _a : false, contextualErrorMap: Q == null ? void 0 : Q.errorMap }, path: (Q == null ? void 0 : Q.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: X, parsedType: O1(X) }, Y = this._parseSync({ data: X, path: $.path, parent: $ });
    return UW($, Y);
  }
  "~validate"(X) {
    var _a, _b;
    let Q = { common: { issues: [], async: !!this["~standard"].async }, path: [], schemaErrorMap: this._def.errorMap, parent: null, data: X, parsedType: O1(X) };
    if (!this["~standard"].async) try {
      let $ = this._parseSync({ data: X, path: [], parent: Q });
      return o1($) ? { value: $.value } : { issues: Q.common.issues };
    } catch ($) {
      if ((_b = (_a = $ == null ? void 0 : $.message) == null ? void 0 : _a.toLowerCase()) == null ? void 0 : _b.includes("encountered")) this["~standard"].async = true;
      Q.common = { issues: [], async: true };
    }
    return this._parseAsync({ data: X, path: [], parent: Q }).then(($) => o1($) ? { value: $.value } : { issues: Q.common.issues });
  }
  async parseAsync(X, Q) {
    let $ = await this.safeParseAsync(X, Q);
    if ($.success) return $.data;
    throw $.error;
  }
  async safeParseAsync(X, Q) {
    let $ = { common: { issues: [], contextualErrorMap: Q == null ? void 0 : Q.errorMap, async: true }, path: (Q == null ? void 0 : Q.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: X, parsedType: O1(X) }, Y = this._parse({ data: X, path: $.path, parent: $ }), W = await (WX(Y) ? Y : Promise.resolve(Y));
    return UW($, W);
  }
  refine(X, Q) {
    let $ = (Y) => {
      if (typeof Q === "string" || typeof Q > "u") return { message: Q };
      else if (typeof Q === "function") return Q(Y);
      else return Q;
    };
    return this._refinement((Y, W) => {
      let J = X(Y), G = () => W.addIssue({ code: w.custom, ...$(Y) });
      if (typeof Promise < "u" && J instanceof Promise) return J.then((H) => {
        if (!H) return G(), false;
        else return true;
      });
      if (!J) return G(), false;
      else return true;
    });
  }
  refinement(X, Q) {
    return this._refinement(($, Y) => {
      if (!X($)) return Y.addIssue(typeof Q === "function" ? Q($, Y) : Q), false;
      else return true;
    });
  }
  _refinement(X) {
    return new H1({ schema: this, typeName: j.ZodEffects, effect: { type: "refinement", refinement: X } });
  }
  superRefine(X) {
    return this._refinement(X);
  }
  constructor(X) {
    this.spa = this.safeParseAsync, this._def = X, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = { version: 1, vendor: "zod", validate: (Q) => this["~validate"](Q) };
  }
  optional() {
    return G1.create(this, this._def);
  }
  nullable() {
    return T1.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return J1.create(this);
  }
  promise() {
    return S6.create(this, this._def);
  }
  or(X) {
    return zX.create([this, X], this._def);
  }
  and(X) {
    return KX.create(this, X, this._def);
  }
  transform(X) {
    return new H1({ ...l(this._def), schema: this, typeName: j.ZodEffects, effect: { type: "transform", transform: X } });
  }
  default(X) {
    let Q = typeof X === "function" ? X : () => X;
    return new qX({ ...l(this._def), innerType: this, defaultValue: Q, typeName: j.ZodDefault });
  }
  brand() {
    return new D8({ typeName: j.ZodBranded, type: this, ...l(this._def) });
  }
  catch(X) {
    let Q = typeof X === "function" ? X : () => X;
    return new FX({ ...l(this._def), innerType: this, catchValue: Q, typeName: j.ZodCatch });
  }
  describe(X) {
    return new this.constructor({ ...this._def, description: X });
  }
  pipe(X) {
    return E4.create(this, X);
  }
  readonly() {
    return NX.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var sU = /^c[^\s-]{8,}$/i;
var eU = /^[0-9a-z]+$/;
var XV = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var QV = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var $V = /^[a-z0-9_-]{21}$/i;
var YV = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var WV = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var JV = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var GV = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
var F8;
var HV = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var BV = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var zV = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var KV = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var UV = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var VV = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var VW = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))";
var LV = new RegExp(`^${VW}$`);
function LW(X) {
  let Q = "[0-5]\\d";
  if (X.precision) Q = `${Q}\\.\\d{${X.precision}}`;
  else if (X.precision == null) Q = `${Q}(\\.\\d+)?`;
  let $ = X.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${Q})${$}`;
}
function qV(X) {
  return new RegExp(`^${LW(X)}$`);
}
function FV(X) {
  let Q = `${VW}T${LW(X)}`, $ = [];
  if ($.push(X.local ? "Z?" : "Z"), X.offset) $.push("([+-]\\d{2}:?\\d{2})");
  return Q = `${Q}(${$.join("|")})`, new RegExp(`^${Q}$`);
}
function NV(X, Q) {
  if ((Q === "v4" || !Q) && HV.test(X)) return true;
  if ((Q === "v6" || !Q) && zV.test(X)) return true;
  return false;
}
function OV(X, Q) {
  if (!YV.test(X)) return false;
  try {
    let [$] = X.split(".");
    if (!$) return false;
    let Y = $.replace(/-/g, "+").replace(/_/g, "/").padEnd($.length + (4 - $.length % 4) % 4, "="), W = JSON.parse(atob(Y));
    if (typeof W !== "object" || W === null) return false;
    if ("typ" in W && (W == null ? void 0 : W.typ) !== "JWT") return false;
    if (!W.alg) return false;
    if (Q && W.alg !== Q) return false;
    return true;
  } catch (e2) {
    return false;
  }
}
function DV(X, Q) {
  if ((Q === "v4" || !Q) && BV.test(X)) return true;
  if ((Q === "v6" || !Q) && KV.test(X)) return true;
  return false;
}
var A1 = class _A1 extends p {
  _parse(X) {
    if (this._def.coerce) X.data = String(X.data);
    if (this._getType(X) !== E.string) {
      let W = this._getOrReturnCtx(X);
      return b(W, { code: w.invalid_type, expected: E.string, received: W.parsedType }), g;
    }
    let $ = new I0(), Y = void 0;
    for (let W of this._def.checks) if (W.kind === "min") {
      if (X.data.length < W.value) Y = this._getOrReturnCtx(X, Y), b(Y, { code: w.too_small, minimum: W.value, type: "string", inclusive: true, exact: false, message: W.message }), $.dirty();
    } else if (W.kind === "max") {
      if (X.data.length > W.value) Y = this._getOrReturnCtx(X, Y), b(Y, { code: w.too_big, maximum: W.value, type: "string", inclusive: true, exact: false, message: W.message }), $.dirty();
    } else if (W.kind === "length") {
      let J = X.data.length > W.value, G = X.data.length < W.value;
      if (J || G) {
        if (Y = this._getOrReturnCtx(X, Y), J) b(Y, { code: w.too_big, maximum: W.value, type: "string", inclusive: true, exact: true, message: W.message });
        else if (G) b(Y, { code: w.too_small, minimum: W.value, type: "string", inclusive: true, exact: true, message: W.message });
        $.dirty();
      }
    } else if (W.kind === "email") {
      if (!JV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "email", code: w.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "emoji") {
      if (!F8) F8 = new RegExp(GV, "u");
      if (!F8.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "emoji", code: w.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "uuid") {
      if (!QV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "uuid", code: w.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "nanoid") {
      if (!$V.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "nanoid", code: w.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "cuid") {
      if (!sU.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "cuid", code: w.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "cuid2") {
      if (!eU.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "cuid2", code: w.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "ulid") {
      if (!XV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "ulid", code: w.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "url") try {
      new URL(X.data);
    } catch (e2) {
      Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "url", code: w.invalid_string, message: W.message }), $.dirty();
    }
    else if (W.kind === "regex") {
      if (W.regex.lastIndex = 0, !W.regex.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "regex", code: w.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "trim") X.data = X.data.trim();
    else if (W.kind === "includes") {
      if (!X.data.includes(W.value, W.position)) Y = this._getOrReturnCtx(X, Y), b(Y, { code: w.invalid_string, validation: { includes: W.value, position: W.position }, message: W.message }), $.dirty();
    } else if (W.kind === "toLowerCase") X.data = X.data.toLowerCase();
    else if (W.kind === "toUpperCase") X.data = X.data.toUpperCase();
    else if (W.kind === "startsWith") {
      if (!X.data.startsWith(W.value)) Y = this._getOrReturnCtx(X, Y), b(Y, { code: w.invalid_string, validation: { startsWith: W.value }, message: W.message }), $.dirty();
    } else if (W.kind === "endsWith") {
      if (!X.data.endsWith(W.value)) Y = this._getOrReturnCtx(X, Y), b(Y, { code: w.invalid_string, validation: { endsWith: W.value }, message: W.message }), $.dirty();
    } else if (W.kind === "datetime") {
      if (!FV(W).test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { code: w.invalid_string, validation: "datetime", message: W.message }), $.dirty();
    } else if (W.kind === "date") {
      if (!LV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { code: w.invalid_string, validation: "date", message: W.message }), $.dirty();
    } else if (W.kind === "time") {
      if (!qV(W).test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { code: w.invalid_string, validation: "time", message: W.message }), $.dirty();
    } else if (W.kind === "duration") {
      if (!WV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "duration", code: w.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "ip") {
      if (!NV(X.data, W.version)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "ip", code: w.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "jwt") {
      if (!OV(X.data, W.alg)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "jwt", code: w.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "cidr") {
      if (!DV(X.data, W.version)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "cidr", code: w.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "base64") {
      if (!UV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "base64", code: w.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "base64url") {
      if (!VV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "base64url", code: w.invalid_string, message: W.message }), $.dirty();
    } else n.assertNever(W);
    return { status: $.value, value: X.data };
  }
  _regex(X, Q, $) {
    return this.refinement((Y) => X.test(Y), { validation: Q, code: w.invalid_string, ...Z.errToObj($) });
  }
  _addCheck(X) {
    return new _A1({ ...this._def, checks: [...this._def.checks, X] });
  }
  email(X) {
    return this._addCheck({ kind: "email", ...Z.errToObj(X) });
  }
  url(X) {
    return this._addCheck({ kind: "url", ...Z.errToObj(X) });
  }
  emoji(X) {
    return this._addCheck({ kind: "emoji", ...Z.errToObj(X) });
  }
  uuid(X) {
    return this._addCheck({ kind: "uuid", ...Z.errToObj(X) });
  }
  nanoid(X) {
    return this._addCheck({ kind: "nanoid", ...Z.errToObj(X) });
  }
  cuid(X) {
    return this._addCheck({ kind: "cuid", ...Z.errToObj(X) });
  }
  cuid2(X) {
    return this._addCheck({ kind: "cuid2", ...Z.errToObj(X) });
  }
  ulid(X) {
    return this._addCheck({ kind: "ulid", ...Z.errToObj(X) });
  }
  base64(X) {
    return this._addCheck({ kind: "base64", ...Z.errToObj(X) });
  }
  base64url(X) {
    return this._addCheck({ kind: "base64url", ...Z.errToObj(X) });
  }
  jwt(X) {
    return this._addCheck({ kind: "jwt", ...Z.errToObj(X) });
  }
  ip(X) {
    return this._addCheck({ kind: "ip", ...Z.errToObj(X) });
  }
  cidr(X) {
    return this._addCheck({ kind: "cidr", ...Z.errToObj(X) });
  }
  datetime(X) {
    var _a, _b;
    if (typeof X === "string") return this._addCheck({ kind: "datetime", precision: null, offset: false, local: false, message: X });
    return this._addCheck({ kind: "datetime", precision: typeof (X == null ? void 0 : X.precision) > "u" ? null : X == null ? void 0 : X.precision, offset: (_a = X == null ? void 0 : X.offset) != null ? _a : false, local: (_b = X == null ? void 0 : X.local) != null ? _b : false, ...Z.errToObj(X == null ? void 0 : X.message) });
  }
  date(X) {
    return this._addCheck({ kind: "date", message: X });
  }
  time(X) {
    if (typeof X === "string") return this._addCheck({ kind: "time", precision: null, message: X });
    return this._addCheck({ kind: "time", precision: typeof (X == null ? void 0 : X.precision) > "u" ? null : X == null ? void 0 : X.precision, ...Z.errToObj(X == null ? void 0 : X.message) });
  }
  duration(X) {
    return this._addCheck({ kind: "duration", ...Z.errToObj(X) });
  }
  regex(X, Q) {
    return this._addCheck({ kind: "regex", regex: X, ...Z.errToObj(Q) });
  }
  includes(X, Q) {
    return this._addCheck({ kind: "includes", value: X, position: Q == null ? void 0 : Q.position, ...Z.errToObj(Q == null ? void 0 : Q.message) });
  }
  startsWith(X, Q) {
    return this._addCheck({ kind: "startsWith", value: X, ...Z.errToObj(Q) });
  }
  endsWith(X, Q) {
    return this._addCheck({ kind: "endsWith", value: X, ...Z.errToObj(Q) });
  }
  min(X, Q) {
    return this._addCheck({ kind: "min", value: X, ...Z.errToObj(Q) });
  }
  max(X, Q) {
    return this._addCheck({ kind: "max", value: X, ...Z.errToObj(Q) });
  }
  length(X, Q) {
    return this._addCheck({ kind: "length", value: X, ...Z.errToObj(Q) });
  }
  nonempty(X) {
    return this.min(1, Z.errToObj(X));
  }
  trim() {
    return new _A1({ ...this._def, checks: [...this._def.checks, { kind: "trim" }] });
  }
  toLowerCase() {
    return new _A1({ ...this._def, checks: [...this._def.checks, { kind: "toLowerCase" }] });
  }
  toUpperCase() {
    return new _A1({ ...this._def, checks: [...this._def.checks, { kind: "toUpperCase" }] });
  }
  get isDatetime() {
    return !!this._def.checks.find((X) => X.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((X) => X.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((X) => X.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((X) => X.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((X) => X.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((X) => X.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((X) => X.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((X) => X.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((X) => X.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((X) => X.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((X) => X.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((X) => X.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((X) => X.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((X) => X.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((X) => X.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((X) => X.kind === "base64url");
  }
  get minLength() {
    let X = null;
    for (let Q of this._def.checks) if (Q.kind === "min") {
      if (X === null || Q.value > X) X = Q.value;
    }
    return X;
  }
  get maxLength() {
    let X = null;
    for (let Q of this._def.checks) if (Q.kind === "max") {
      if (X === null || Q.value < X) X = Q.value;
    }
    return X;
  }
};
A1.create = (X) => {
  var _a;
  return new A1({ checks: [], typeName: j.ZodString, coerce: (_a = X == null ? void 0 : X.coerce) != null ? _a : false, ...l(X) });
};
function AV(X, Q) {
  let $ = (X.toString().split(".")[1] || "").length, Y = (Q.toString().split(".")[1] || "").length, W = $ > Y ? $ : Y, J = Number.parseInt(X.toFixed(W).replace(".", "")), G = Number.parseInt(Q.toFixed(W).replace(".", ""));
  return J % G / 10 ** W;
}
var I6 = class _I6 extends p {
  constructor() {
    super(...arguments);
    this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(X) {
    if (this._def.coerce) X.data = Number(X.data);
    if (this._getType(X) !== E.number) {
      let W = this._getOrReturnCtx(X);
      return b(W, { code: w.invalid_type, expected: E.number, received: W.parsedType }), g;
    }
    let $ = void 0, Y = new I0();
    for (let W of this._def.checks) if (W.kind === "int") {
      if (!n.isInteger(X.data)) $ = this._getOrReturnCtx(X, $), b($, { code: w.invalid_type, expected: "integer", received: "float", message: W.message }), Y.dirty();
    } else if (W.kind === "min") {
      if (W.inclusive ? X.data < W.value : X.data <= W.value) $ = this._getOrReturnCtx(X, $), b($, { code: w.too_small, minimum: W.value, type: "number", inclusive: W.inclusive, exact: false, message: W.message }), Y.dirty();
    } else if (W.kind === "max") {
      if (W.inclusive ? X.data > W.value : X.data >= W.value) $ = this._getOrReturnCtx(X, $), b($, { code: w.too_big, maximum: W.value, type: "number", inclusive: W.inclusive, exact: false, message: W.message }), Y.dirty();
    } else if (W.kind === "multipleOf") {
      if (AV(X.data, W.value) !== 0) $ = this._getOrReturnCtx(X, $), b($, { code: w.not_multiple_of, multipleOf: W.value, message: W.message }), Y.dirty();
    } else if (W.kind === "finite") {
      if (!Number.isFinite(X.data)) $ = this._getOrReturnCtx(X, $), b($, { code: w.not_finite, message: W.message }), Y.dirty();
    } else n.assertNever(W);
    return { status: Y.value, value: X.data };
  }
  gte(X, Q) {
    return this.setLimit("min", X, true, Z.toString(Q));
  }
  gt(X, Q) {
    return this.setLimit("min", X, false, Z.toString(Q));
  }
  lte(X, Q) {
    return this.setLimit("max", X, true, Z.toString(Q));
  }
  lt(X, Q) {
    return this.setLimit("max", X, false, Z.toString(Q));
  }
  setLimit(X, Q, $, Y) {
    return new _I6({ ...this._def, checks: [...this._def.checks, { kind: X, value: Q, inclusive: $, message: Z.toString(Y) }] });
  }
  _addCheck(X) {
    return new _I6({ ...this._def, checks: [...this._def.checks, X] });
  }
  int(X) {
    return this._addCheck({ kind: "int", message: Z.toString(X) });
  }
  positive(X) {
    return this._addCheck({ kind: "min", value: 0, inclusive: false, message: Z.toString(X) });
  }
  negative(X) {
    return this._addCheck({ kind: "max", value: 0, inclusive: false, message: Z.toString(X) });
  }
  nonpositive(X) {
    return this._addCheck({ kind: "max", value: 0, inclusive: true, message: Z.toString(X) });
  }
  nonnegative(X) {
    return this._addCheck({ kind: "min", value: 0, inclusive: true, message: Z.toString(X) });
  }
  multipleOf(X, Q) {
    return this._addCheck({ kind: "multipleOf", value: X, message: Z.toString(Q) });
  }
  finite(X) {
    return this._addCheck({ kind: "finite", message: Z.toString(X) });
  }
  safe(X) {
    return this._addCheck({ kind: "min", inclusive: true, value: Number.MIN_SAFE_INTEGER, message: Z.toString(X) })._addCheck({ kind: "max", inclusive: true, value: Number.MAX_SAFE_INTEGER, message: Z.toString(X) });
  }
  get minValue() {
    let X = null;
    for (let Q of this._def.checks) if (Q.kind === "min") {
      if (X === null || Q.value > X) X = Q.value;
    }
    return X;
  }
  get maxValue() {
    let X = null;
    for (let Q of this._def.checks) if (Q.kind === "max") {
      if (X === null || Q.value < X) X = Q.value;
    }
    return X;
  }
  get isInt() {
    return !!this._def.checks.find((X) => X.kind === "int" || X.kind === "multipleOf" && n.isInteger(X.value));
  }
  get isFinite() {
    let X = null, Q = null;
    for (let $ of this._def.checks) if ($.kind === "finite" || $.kind === "int" || $.kind === "multipleOf") return true;
    else if ($.kind === "min") {
      if (Q === null || $.value > Q) Q = $.value;
    } else if ($.kind === "max") {
      if (X === null || $.value < X) X = $.value;
    }
    return Number.isFinite(Q) && Number.isFinite(X);
  }
};
I6.create = (X) => {
  return new I6({ checks: [], typeName: j.ZodNumber, coerce: (X == null ? void 0 : X.coerce) || false, ...l(X) });
};
var b6 = class _b6 extends p {
  constructor() {
    super(...arguments);
    this.min = this.gte, this.max = this.lte;
  }
  _parse(X) {
    if (this._def.coerce) try {
      X.data = BigInt(X.data);
    } catch (e2) {
      return this._getInvalidInput(X);
    }
    if (this._getType(X) !== E.bigint) return this._getInvalidInput(X);
    let $ = void 0, Y = new I0();
    for (let W of this._def.checks) if (W.kind === "min") {
      if (W.inclusive ? X.data < W.value : X.data <= W.value) $ = this._getOrReturnCtx(X, $), b($, { code: w.too_small, type: "bigint", minimum: W.value, inclusive: W.inclusive, message: W.message }), Y.dirty();
    } else if (W.kind === "max") {
      if (W.inclusive ? X.data > W.value : X.data >= W.value) $ = this._getOrReturnCtx(X, $), b($, { code: w.too_big, type: "bigint", maximum: W.value, inclusive: W.inclusive, message: W.message }), Y.dirty();
    } else if (W.kind === "multipleOf") {
      if (X.data % W.value !== BigInt(0)) $ = this._getOrReturnCtx(X, $), b($, { code: w.not_multiple_of, multipleOf: W.value, message: W.message }), Y.dirty();
    } else n.assertNever(W);
    return { status: Y.value, value: X.data };
  }
  _getInvalidInput(X) {
    let Q = this._getOrReturnCtx(X);
    return b(Q, { code: w.invalid_type, expected: E.bigint, received: Q.parsedType }), g;
  }
  gte(X, Q) {
    return this.setLimit("min", X, true, Z.toString(Q));
  }
  gt(X, Q) {
    return this.setLimit("min", X, false, Z.toString(Q));
  }
  lte(X, Q) {
    return this.setLimit("max", X, true, Z.toString(Q));
  }
  lt(X, Q) {
    return this.setLimit("max", X, false, Z.toString(Q));
  }
  setLimit(X, Q, $, Y) {
    return new _b6({ ...this._def, checks: [...this._def.checks, { kind: X, value: Q, inclusive: $, message: Z.toString(Y) }] });
  }
  _addCheck(X) {
    return new _b6({ ...this._def, checks: [...this._def.checks, X] });
  }
  positive(X) {
    return this._addCheck({ kind: "min", value: BigInt(0), inclusive: false, message: Z.toString(X) });
  }
  negative(X) {
    return this._addCheck({ kind: "max", value: BigInt(0), inclusive: false, message: Z.toString(X) });
  }
  nonpositive(X) {
    return this._addCheck({ kind: "max", value: BigInt(0), inclusive: true, message: Z.toString(X) });
  }
  nonnegative(X) {
    return this._addCheck({ kind: "min", value: BigInt(0), inclusive: true, message: Z.toString(X) });
  }
  multipleOf(X, Q) {
    return this._addCheck({ kind: "multipleOf", value: X, message: Z.toString(Q) });
  }
  get minValue() {
    let X = null;
    for (let Q of this._def.checks) if (Q.kind === "min") {
      if (X === null || Q.value > X) X = Q.value;
    }
    return X;
  }
  get maxValue() {
    let X = null;
    for (let Q of this._def.checks) if (Q.kind === "max") {
      if (X === null || Q.value < X) X = Q.value;
    }
    return X;
  }
};
b6.create = (X) => {
  var _a;
  return new b6({ checks: [], typeName: j.ZodBigInt, coerce: (_a = X == null ? void 0 : X.coerce) != null ? _a : false, ...l(X) });
};
var O4 = class extends p {
  _parse(X) {
    if (this._def.coerce) X.data = Boolean(X.data);
    if (this._getType(X) !== E.boolean) {
      let $ = this._getOrReturnCtx(X);
      return b($, { code: w.invalid_type, expected: E.boolean, received: $.parsedType }), g;
    }
    return C0(X.data);
  }
};
O4.create = (X) => {
  return new O4({ typeName: j.ZodBoolean, coerce: (X == null ? void 0 : X.coerce) || false, ...l(X) });
};
var GX = class _GX extends p {
  _parse(X) {
    if (this._def.coerce) X.data = new Date(X.data);
    if (this._getType(X) !== E.date) {
      let W = this._getOrReturnCtx(X);
      return b(W, { code: w.invalid_type, expected: E.date, received: W.parsedType }), g;
    }
    if (Number.isNaN(X.data.getTime())) {
      let W = this._getOrReturnCtx(X);
      return b(W, { code: w.invalid_date }), g;
    }
    let $ = new I0(), Y = void 0;
    for (let W of this._def.checks) if (W.kind === "min") {
      if (X.data.getTime() < W.value) Y = this._getOrReturnCtx(X, Y), b(Y, { code: w.too_small, message: W.message, inclusive: true, exact: false, minimum: W.value, type: "date" }), $.dirty();
    } else if (W.kind === "max") {
      if (X.data.getTime() > W.value) Y = this._getOrReturnCtx(X, Y), b(Y, { code: w.too_big, message: W.message, inclusive: true, exact: false, maximum: W.value, type: "date" }), $.dirty();
    } else n.assertNever(W);
    return { status: $.value, value: new Date(X.data.getTime()) };
  }
  _addCheck(X) {
    return new _GX({ ...this._def, checks: [...this._def.checks, X] });
  }
  min(X, Q) {
    return this._addCheck({ kind: "min", value: X.getTime(), message: Z.toString(Q) });
  }
  max(X, Q) {
    return this._addCheck({ kind: "max", value: X.getTime(), message: Z.toString(Q) });
  }
  get minDate() {
    let X = null;
    for (let Q of this._def.checks) if (Q.kind === "min") {
      if (X === null || Q.value > X) X = Q.value;
    }
    return X != null ? new Date(X) : null;
  }
  get maxDate() {
    let X = null;
    for (let Q of this._def.checks) if (Q.kind === "max") {
      if (X === null || Q.value < X) X = Q.value;
    }
    return X != null ? new Date(X) : null;
  }
};
GX.create = (X) => {
  return new GX({ checks: [], coerce: (X == null ? void 0 : X.coerce) || false, typeName: j.ZodDate, ...l(X) });
};
var D4 = class extends p {
  _parse(X) {
    if (this._getType(X) !== E.symbol) {
      let $ = this._getOrReturnCtx(X);
      return b($, { code: w.invalid_type, expected: E.symbol, received: $.parsedType }), g;
    }
    return C0(X.data);
  }
};
D4.create = (X) => {
  return new D4({ typeName: j.ZodSymbol, ...l(X) });
};
var HX = class extends p {
  _parse(X) {
    if (this._getType(X) !== E.undefined) {
      let $ = this._getOrReturnCtx(X);
      return b($, { code: w.invalid_type, expected: E.undefined, received: $.parsedType }), g;
    }
    return C0(X.data);
  }
};
HX.create = (X) => {
  return new HX({ typeName: j.ZodUndefined, ...l(X) });
};
var BX = class extends p {
  _parse(X) {
    if (this._getType(X) !== E.null) {
      let $ = this._getOrReturnCtx(X);
      return b($, { code: w.invalid_type, expected: E.null, received: $.parsedType }), g;
    }
    return C0(X.data);
  }
};
BX.create = (X) => {
  return new BX({ typeName: j.ZodNull, ...l(X) });
};
var A4 = class extends p {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(X) {
    return C0(X.data);
  }
};
A4.create = (X) => {
  return new A4({ typeName: j.ZodAny, ...l(X) });
};
var t1 = class extends p {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(X) {
    return C0(X.data);
  }
};
t1.create = (X) => {
  return new t1({ typeName: j.ZodUnknown, ...l(X) });
};
var w1 = class extends p {
  _parse(X) {
    let Q = this._getOrReturnCtx(X);
    return b(Q, { code: w.invalid_type, expected: E.never, received: Q.parsedType }), g;
  }
};
w1.create = (X) => {
  return new w1({ typeName: j.ZodNever, ...l(X) });
};
var w4 = class extends p {
  _parse(X) {
    if (this._getType(X) !== E.undefined) {
      let $ = this._getOrReturnCtx(X);
      return b($, { code: w.invalid_type, expected: E.void, received: $.parsedType }), g;
    }
    return C0(X.data);
  }
};
w4.create = (X) => {
  return new w4({ typeName: j.ZodVoid, ...l(X) });
};
var J1 = class _J1 extends p {
  _parse(X) {
    let { ctx: Q, status: $ } = this._processInputParams(X), Y = this._def;
    if (Q.parsedType !== E.array) return b(Q, { code: w.invalid_type, expected: E.array, received: Q.parsedType }), g;
    if (Y.exactLength !== null) {
      let J = Q.data.length > Y.exactLength.value, G = Q.data.length < Y.exactLength.value;
      if (J || G) b(Q, { code: J ? w.too_big : w.too_small, minimum: G ? Y.exactLength.value : void 0, maximum: J ? Y.exactLength.value : void 0, type: "array", inclusive: true, exact: true, message: Y.exactLength.message }), $.dirty();
    }
    if (Y.minLength !== null) {
      if (Q.data.length < Y.minLength.value) b(Q, { code: w.too_small, minimum: Y.minLength.value, type: "array", inclusive: true, exact: false, message: Y.minLength.message }), $.dirty();
    }
    if (Y.maxLength !== null) {
      if (Q.data.length > Y.maxLength.value) b(Q, { code: w.too_big, maximum: Y.maxLength.value, type: "array", inclusive: true, exact: false, message: Y.maxLength.message }), $.dirty();
    }
    if (Q.common.async) return Promise.all([...Q.data].map((J, G) => {
      return Y.type._parseAsync(new r0(Q, J, Q.path, G));
    })).then((J) => {
      return I0.mergeArray($, J);
    });
    let W = [...Q.data].map((J, G) => {
      return Y.type._parseSync(new r0(Q, J, Q.path, G));
    });
    return I0.mergeArray($, W);
  }
  get element() {
    return this._def.type;
  }
  min(X, Q) {
    return new _J1({ ...this._def, minLength: { value: X, message: Z.toString(Q) } });
  }
  max(X, Q) {
    return new _J1({ ...this._def, maxLength: { value: X, message: Z.toString(Q) } });
  }
  length(X, Q) {
    return new _J1({ ...this._def, exactLength: { value: X, message: Z.toString(Q) } });
  }
  nonempty(X) {
    return this.min(1, X);
  }
};
J1.create = (X, Q) => {
  return new J1({ type: X, minLength: null, maxLength: null, exactLength: null, typeName: j.ZodArray, ...l(Q) });
};
function E6(X) {
  if (X instanceof V0) {
    let Q = {};
    for (let $ in X.shape) {
      let Y = X.shape[$];
      Q[$] = G1.create(E6(Y));
    }
    return new V0({ ...X._def, shape: () => Q });
  } else if (X instanceof J1) return new J1({ ...X._def, type: E6(X.element) });
  else if (X instanceof G1) return G1.create(E6(X.unwrap()));
  else if (X instanceof T1) return T1.create(E6(X.unwrap()));
  else if (X instanceof M1) return M1.create(X.items.map((Q) => E6(Q)));
  else return X;
}
var V0 = class _V0 extends p {
  constructor() {
    super(...arguments);
    this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null) return this._cached;
    let X = this._def.shape(), Q = n.objectKeys(X);
    return this._cached = { shape: X, keys: Q }, this._cached;
  }
  _parse(X) {
    if (this._getType(X) !== E.object) {
      let B = this._getOrReturnCtx(X);
      return b(B, { code: w.invalid_type, expected: E.object, received: B.parsedType }), g;
    }
    let { status: $, ctx: Y } = this._processInputParams(X), { shape: W, keys: J } = this._getCached(), G = [];
    if (!(this._def.catchall instanceof w1 && this._def.unknownKeys === "strip")) {
      for (let B in Y.data) if (!J.includes(B)) G.push(B);
    }
    let H = [];
    for (let B of J) {
      let z = W[B], K = Y.data[B];
      H.push({ key: { status: "valid", value: B }, value: z._parse(new r0(Y, K, Y.path, B)), alwaysSet: B in Y.data });
    }
    if (this._def.catchall instanceof w1) {
      let B = this._def.unknownKeys;
      if (B === "passthrough") for (let z of G) H.push({ key: { status: "valid", value: z }, value: { status: "valid", value: Y.data[z] } });
      else if (B === "strict") {
        if (G.length > 0) b(Y, { code: w.unrecognized_keys, keys: G }), $.dirty();
      } else if (B === "strip") ;
      else throw Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      let B = this._def.catchall;
      for (let z of G) {
        let K = Y.data[z];
        H.push({ key: { status: "valid", value: z }, value: B._parse(new r0(Y, K, Y.path, z)), alwaysSet: z in Y.data });
      }
    }
    if (Y.common.async) return Promise.resolve().then(async () => {
      let B = [];
      for (let z of H) {
        let K = await z.key, V = await z.value;
        B.push({ key: K, value: V, alwaysSet: z.alwaysSet });
      }
      return B;
    }).then((B) => {
      return I0.mergeObjectSync($, B);
    });
    else return I0.mergeObjectSync($, H);
  }
  get shape() {
    return this._def.shape();
  }
  strict(X) {
    return Z.errToObj, new _V0({ ...this._def, unknownKeys: "strict", ...X !== void 0 ? { errorMap: (Q, $) => {
      var _a, _b, _c, _d;
      let Y = (_c = (_b = (_a = this._def).errorMap) == null ? void 0 : _b.call(_a, Q, $).message) != null ? _c : $.defaultError;
      if (Q.code === "unrecognized_keys") return { message: (_d = Z.errToObj(X).message) != null ? _d : Y };
      return { message: Y };
    } } : {} });
  }
  strip() {
    return new _V0({ ...this._def, unknownKeys: "strip" });
  }
  passthrough() {
    return new _V0({ ...this._def, unknownKeys: "passthrough" });
  }
  extend(X) {
    return new _V0({ ...this._def, shape: () => ({ ...this._def.shape(), ...X }) });
  }
  merge(X) {
    return new _V0({ unknownKeys: X._def.unknownKeys, catchall: X._def.catchall, shape: () => ({ ...this._def.shape(), ...X._def.shape() }), typeName: j.ZodObject });
  }
  setKey(X, Q) {
    return this.augment({ [X]: Q });
  }
  catchall(X) {
    return new _V0({ ...this._def, catchall: X });
  }
  pick(X) {
    let Q = {};
    for (let $ of n.objectKeys(X)) if (X[$] && this.shape[$]) Q[$] = this.shape[$];
    return new _V0({ ...this._def, shape: () => Q });
  }
  omit(X) {
    let Q = {};
    for (let $ of n.objectKeys(this.shape)) if (!X[$]) Q[$] = this.shape[$];
    return new _V0({ ...this._def, shape: () => Q });
  }
  deepPartial() {
    return E6(this);
  }
  partial(X) {
    let Q = {};
    for (let $ of n.objectKeys(this.shape)) {
      let Y = this.shape[$];
      if (X && !X[$]) Q[$] = Y;
      else Q[$] = Y.optional();
    }
    return new _V0({ ...this._def, shape: () => Q });
  }
  required(X) {
    let Q = {};
    for (let $ of n.objectKeys(this.shape)) if (X && !X[$]) Q[$] = this.shape[$];
    else {
      let W = this.shape[$];
      while (W instanceof G1) W = W._def.innerType;
      Q[$] = W;
    }
    return new _V0({ ...this._def, shape: () => Q });
  }
  keyof() {
    return qW(n.objectKeys(this.shape));
  }
};
V0.create = (X, Q) => {
  return new V0({ shape: () => X, unknownKeys: "strip", catchall: w1.create(), typeName: j.ZodObject, ...l(Q) });
};
V0.strictCreate = (X, Q) => {
  return new V0({ shape: () => X, unknownKeys: "strict", catchall: w1.create(), typeName: j.ZodObject, ...l(Q) });
};
V0.lazycreate = (X, Q) => {
  return new V0({ shape: X, unknownKeys: "strip", catchall: w1.create(), typeName: j.ZodObject, ...l(Q) });
};
var zX = class extends p {
  _parse(X) {
    let { ctx: Q } = this._processInputParams(X), $ = this._def.options;
    function Y(W) {
      for (let G of W) if (G.result.status === "valid") return G.result;
      for (let G of W) if (G.result.status === "dirty") return Q.common.issues.push(...G.ctx.common.issues), G.result;
      let J = W.map((G) => new f0(G.ctx.common.issues));
      return b(Q, { code: w.invalid_union, unionErrors: J }), g;
    }
    if (Q.common.async) return Promise.all($.map(async (W) => {
      let J = { ...Q, common: { ...Q.common, issues: [] }, parent: null };
      return { result: await W._parseAsync({ data: Q.data, path: Q.path, parent: J }), ctx: J };
    })).then(Y);
    else {
      let W = void 0, J = [];
      for (let H of $) {
        let B = { ...Q, common: { ...Q.common, issues: [] }, parent: null }, z = H._parseSync({ data: Q.data, path: Q.path, parent: B });
        if (z.status === "valid") return z;
        else if (z.status === "dirty" && !W) W = { result: z, ctx: B };
        if (B.common.issues.length) J.push(B.common.issues);
      }
      if (W) return Q.common.issues.push(...W.ctx.common.issues), W.result;
      let G = J.map((H) => new f0(H));
      return b(Q, { code: w.invalid_union, unionErrors: G }), g;
    }
  }
  get options() {
    return this._def.options;
  }
};
zX.create = (X, Q) => {
  return new zX({ options: X, typeName: j.ZodUnion, ...l(Q) });
};
var D1 = (X) => {
  if (X instanceof UX) return D1(X.schema);
  else if (X instanceof H1) return D1(X.innerType());
  else if (X instanceof VX) return [X.value];
  else if (X instanceof a1) return X.options;
  else if (X instanceof LX) return n.objectValues(X.enum);
  else if (X instanceof qX) return D1(X._def.innerType);
  else if (X instanceof HX) return [void 0];
  else if (X instanceof BX) return [null];
  else if (X instanceof G1) return [void 0, ...D1(X.unwrap())];
  else if (X instanceof T1) return [null, ...D1(X.unwrap())];
  else if (X instanceof D8) return D1(X.unwrap());
  else if (X instanceof NX) return D1(X.unwrap());
  else if (X instanceof FX) return D1(X._def.innerType);
  else return [];
};
var O8 = class _O8 extends p {
  _parse(X) {
    let { ctx: Q } = this._processInputParams(X);
    if (Q.parsedType !== E.object) return b(Q, { code: w.invalid_type, expected: E.object, received: Q.parsedType }), g;
    let $ = this.discriminator, Y = Q.data[$], W = this.optionsMap.get(Y);
    if (!W) return b(Q, { code: w.invalid_union_discriminator, options: Array.from(this.optionsMap.keys()), path: [$] }), g;
    if (Q.common.async) return W._parseAsync({ data: Q.data, path: Q.path, parent: Q });
    else return W._parseSync({ data: Q.data, path: Q.path, parent: Q });
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(X, Q, $) {
    let Y = /* @__PURE__ */ new Map();
    for (let W of Q) {
      let J = D1(W.shape[X]);
      if (!J.length) throw Error(`A discriminator value for key \`${X}\` could not be extracted from all schema options`);
      for (let G of J) {
        if (Y.has(G)) throw Error(`Discriminator property ${String(X)} has duplicate value ${String(G)}`);
        Y.set(G, W);
      }
    }
    return new _O8({ typeName: j.ZodDiscriminatedUnion, discriminator: X, options: Q, optionsMap: Y, ...l($) });
  }
};
function N8(X, Q) {
  let $ = O1(X), Y = O1(Q);
  if (X === Q) return { valid: true, data: X };
  else if ($ === E.object && Y === E.object) {
    let W = n.objectKeys(Q), J = n.objectKeys(X).filter((H) => W.indexOf(H) !== -1), G = { ...X, ...Q };
    for (let H of J) {
      let B = N8(X[H], Q[H]);
      if (!B.valid) return { valid: false };
      G[H] = B.data;
    }
    return { valid: true, data: G };
  } else if ($ === E.array && Y === E.array) {
    if (X.length !== Q.length) return { valid: false };
    let W = [];
    for (let J = 0; J < X.length; J++) {
      let G = X[J], H = Q[J], B = N8(G, H);
      if (!B.valid) return { valid: false };
      W.push(B.data);
    }
    return { valid: true, data: W };
  } else if ($ === E.date && Y === E.date && +X === +Q) return { valid: true, data: X };
  else return { valid: false };
}
var KX = class extends p {
  _parse(X) {
    let { status: Q, ctx: $ } = this._processInputParams(X), Y = (W, J) => {
      if (L8(W) || L8(J)) return g;
      let G = N8(W.value, J.value);
      if (!G.valid) return b($, { code: w.invalid_intersection_types }), g;
      if (q8(W) || q8(J)) Q.dirty();
      return { status: Q.value, value: G.data };
    };
    if ($.common.async) return Promise.all([this._def.left._parseAsync({ data: $.data, path: $.path, parent: $ }), this._def.right._parseAsync({ data: $.data, path: $.path, parent: $ })]).then(([W, J]) => Y(W, J));
    else return Y(this._def.left._parseSync({ data: $.data, path: $.path, parent: $ }), this._def.right._parseSync({ data: $.data, path: $.path, parent: $ }));
  }
};
KX.create = (X, Q, $) => {
  return new KX({ left: X, right: Q, typeName: j.ZodIntersection, ...l($) });
};
var M1 = class _M1 extends p {
  _parse(X) {
    let { status: Q, ctx: $ } = this._processInputParams(X);
    if ($.parsedType !== E.array) return b($, { code: w.invalid_type, expected: E.array, received: $.parsedType }), g;
    if ($.data.length < this._def.items.length) return b($, { code: w.too_small, minimum: this._def.items.length, inclusive: true, exact: false, type: "array" }), g;
    if (!this._def.rest && $.data.length > this._def.items.length) b($, { code: w.too_big, maximum: this._def.items.length, inclusive: true, exact: false, type: "array" }), Q.dirty();
    let W = [...$.data].map((J, G) => {
      let H = this._def.items[G] || this._def.rest;
      if (!H) return null;
      return H._parse(new r0($, J, $.path, G));
    }).filter((J) => !!J);
    if ($.common.async) return Promise.all(W).then((J) => {
      return I0.mergeArray(Q, J);
    });
    else return I0.mergeArray(Q, W);
  }
  get items() {
    return this._def.items;
  }
  rest(X) {
    return new _M1({ ...this._def, rest: X });
  }
};
M1.create = (X, Q) => {
  if (!Array.isArray(X)) throw Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new M1({ items: X, typeName: j.ZodTuple, rest: null, ...l(Q) });
};
var M4 = class _M4 extends p {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(X) {
    let { status: Q, ctx: $ } = this._processInputParams(X);
    if ($.parsedType !== E.object) return b($, { code: w.invalid_type, expected: E.object, received: $.parsedType }), g;
    let Y = [], W = this._def.keyType, J = this._def.valueType;
    for (let G in $.data) Y.push({ key: W._parse(new r0($, G, $.path, G)), value: J._parse(new r0($, $.data[G], $.path, G)), alwaysSet: G in $.data });
    if ($.common.async) return I0.mergeObjectAsync(Q, Y);
    else return I0.mergeObjectSync(Q, Y);
  }
  get element() {
    return this._def.valueType;
  }
  static create(X, Q, $) {
    if (Q instanceof p) return new _M4({ keyType: X, valueType: Q, typeName: j.ZodRecord, ...l($) });
    return new _M4({ keyType: A1.create(), valueType: X, typeName: j.ZodRecord, ...l(Q) });
  }
};
var j4 = class extends p {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(X) {
    let { status: Q, ctx: $ } = this._processInputParams(X);
    if ($.parsedType !== E.map) return b($, { code: w.invalid_type, expected: E.map, received: $.parsedType }), g;
    let Y = this._def.keyType, W = this._def.valueType, J = [...$.data.entries()].map(([G, H], B) => {
      return { key: Y._parse(new r0($, G, $.path, [B, "key"])), value: W._parse(new r0($, H, $.path, [B, "value"])) };
    });
    if ($.common.async) {
      let G = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (let H of J) {
          let B = await H.key, z = await H.value;
          if (B.status === "aborted" || z.status === "aborted") return g;
          if (B.status === "dirty" || z.status === "dirty") Q.dirty();
          G.set(B.value, z.value);
        }
        return { status: Q.value, value: G };
      });
    } else {
      let G = /* @__PURE__ */ new Map();
      for (let H of J) {
        let { key: B, value: z } = H;
        if (B.status === "aborted" || z.status === "aborted") return g;
        if (B.status === "dirty" || z.status === "dirty") Q.dirty();
        G.set(B.value, z.value);
      }
      return { status: Q.value, value: G };
    }
  }
};
j4.create = (X, Q, $) => {
  return new j4({ valueType: Q, keyType: X, typeName: j.ZodMap, ...l($) });
};
var P6 = class _P6 extends p {
  _parse(X) {
    let { status: Q, ctx: $ } = this._processInputParams(X);
    if ($.parsedType !== E.set) return b($, { code: w.invalid_type, expected: E.set, received: $.parsedType }), g;
    let Y = this._def;
    if (Y.minSize !== null) {
      if ($.data.size < Y.minSize.value) b($, { code: w.too_small, minimum: Y.minSize.value, type: "set", inclusive: true, exact: false, message: Y.minSize.message }), Q.dirty();
    }
    if (Y.maxSize !== null) {
      if ($.data.size > Y.maxSize.value) b($, { code: w.too_big, maximum: Y.maxSize.value, type: "set", inclusive: true, exact: false, message: Y.maxSize.message }), Q.dirty();
    }
    let W = this._def.valueType;
    function J(H) {
      let B = /* @__PURE__ */ new Set();
      for (let z of H) {
        if (z.status === "aborted") return g;
        if (z.status === "dirty") Q.dirty();
        B.add(z.value);
      }
      return { status: Q.value, value: B };
    }
    let G = [...$.data.values()].map((H, B) => W._parse(new r0($, H, $.path, B)));
    if ($.common.async) return Promise.all(G).then((H) => J(H));
    else return J(G);
  }
  min(X, Q) {
    return new _P6({ ...this._def, minSize: { value: X, message: Z.toString(Q) } });
  }
  max(X, Q) {
    return new _P6({ ...this._def, maxSize: { value: X, message: Z.toString(Q) } });
  }
  size(X, Q) {
    return this.min(X, Q).max(X, Q);
  }
  nonempty(X) {
    return this.min(1, X);
  }
};
P6.create = (X, Q) => {
  return new P6({ valueType: X, minSize: null, maxSize: null, typeName: j.ZodSet, ...l(Q) });
};
var JX = class _JX extends p {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(X) {
    let { ctx: Q } = this._processInputParams(X);
    if (Q.parsedType !== E.function) return b(Q, { code: w.invalid_type, expected: E.function, received: Q.parsedType }), g;
    function $(G, H) {
      return N4({ data: G, path: Q.path, errorMaps: [Q.common.contextualErrorMap, Q.schemaErrorMap, YX(), v1].filter((B) => !!B), issueData: { code: w.invalid_arguments, argumentsError: H } });
    }
    function Y(G, H) {
      return N4({ data: G, path: Q.path, errorMaps: [Q.common.contextualErrorMap, Q.schemaErrorMap, YX(), v1].filter((B) => !!B), issueData: { code: w.invalid_return_type, returnTypeError: H } });
    }
    let W = { errorMap: Q.common.contextualErrorMap }, J = Q.data;
    if (this._def.returns instanceof S6) {
      let G = this;
      return C0(async function(...H) {
        let B = new f0([]), z = await G._def.args.parseAsync(H, W).catch((L) => {
          throw B.addIssue($(H, L)), B;
        }), K = await Reflect.apply(J, this, z);
        return await G._def.returns._def.type.parseAsync(K, W).catch((L) => {
          throw B.addIssue(Y(K, L)), B;
        });
      });
    } else {
      let G = this;
      return C0(function(...H) {
        let B = G._def.args.safeParse(H, W);
        if (!B.success) throw new f0([$(H, B.error)]);
        let z = Reflect.apply(J, this, B.data), K = G._def.returns.safeParse(z, W);
        if (!K.success) throw new f0([Y(z, K.error)]);
        return K.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...X) {
    return new _JX({ ...this._def, args: M1.create(X).rest(t1.create()) });
  }
  returns(X) {
    return new _JX({ ...this._def, returns: X });
  }
  implement(X) {
    return this.parse(X);
  }
  strictImplement(X) {
    return this.parse(X);
  }
  static create(X, Q, $) {
    return new _JX({ args: X ? X : M1.create([]).rest(t1.create()), returns: Q || t1.create(), typeName: j.ZodFunction, ...l($) });
  }
};
var UX = class extends p {
  get schema() {
    return this._def.getter();
  }
  _parse(X) {
    let { ctx: Q } = this._processInputParams(X);
    return this._def.getter()._parse({ data: Q.data, path: Q.path, parent: Q });
  }
};
UX.create = (X, Q) => {
  return new UX({ getter: X, typeName: j.ZodLazy, ...l(Q) });
};
var VX = class extends p {
  _parse(X) {
    if (X.data !== this._def.value) {
      let Q = this._getOrReturnCtx(X);
      return b(Q, { received: Q.data, code: w.invalid_literal, expected: this._def.value }), g;
    }
    return { status: "valid", value: X.data };
  }
  get value() {
    return this._def.value;
  }
};
VX.create = (X, Q) => {
  return new VX({ value: X, typeName: j.ZodLiteral, ...l(Q) });
};
function qW(X, Q) {
  return new a1({ values: X, typeName: j.ZodEnum, ...l(Q) });
}
var a1 = class _a1 extends p {
  _parse(X) {
    if (typeof X.data !== "string") {
      let Q = this._getOrReturnCtx(X), $ = this._def.values;
      return b(Q, { expected: n.joinValues($), received: Q.parsedType, code: w.invalid_type }), g;
    }
    if (!this._cache) this._cache = new Set(this._def.values);
    if (!this._cache.has(X.data)) {
      let Q = this._getOrReturnCtx(X), $ = this._def.values;
      return b(Q, { received: Q.data, code: w.invalid_enum_value, options: $ }), g;
    }
    return C0(X.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    let X = {};
    for (let Q of this._def.values) X[Q] = Q;
    return X;
  }
  get Values() {
    let X = {};
    for (let Q of this._def.values) X[Q] = Q;
    return X;
  }
  get Enum() {
    let X = {};
    for (let Q of this._def.values) X[Q] = Q;
    return X;
  }
  extract(X, Q = this._def) {
    return _a1.create(X, { ...this._def, ...Q });
  }
  exclude(X, Q = this._def) {
    return _a1.create(this.options.filter(($) => !X.includes($)), { ...this._def, ...Q });
  }
};
a1.create = qW;
var LX = class extends p {
  _parse(X) {
    let Q = n.getValidEnumValues(this._def.values), $ = this._getOrReturnCtx(X);
    if ($.parsedType !== E.string && $.parsedType !== E.number) {
      let Y = n.objectValues(Q);
      return b($, { expected: n.joinValues(Y), received: $.parsedType, code: w.invalid_type }), g;
    }
    if (!this._cache) this._cache = new Set(n.getValidEnumValues(this._def.values));
    if (!this._cache.has(X.data)) {
      let Y = n.objectValues(Q);
      return b($, { received: $.data, code: w.invalid_enum_value, options: Y }), g;
    }
    return C0(X.data);
  }
  get enum() {
    return this._def.values;
  }
};
LX.create = (X, Q) => {
  return new LX({ values: X, typeName: j.ZodNativeEnum, ...l(Q) });
};
var S6 = class extends p {
  unwrap() {
    return this._def.type;
  }
  _parse(X) {
    let { ctx: Q } = this._processInputParams(X);
    if (Q.parsedType !== E.promise && Q.common.async === false) return b(Q, { code: w.invalid_type, expected: E.promise, received: Q.parsedType }), g;
    let $ = Q.parsedType === E.promise ? Q.data : Promise.resolve(Q.data);
    return C0($.then((Y) => {
      return this._def.type.parseAsync(Y, { path: Q.path, errorMap: Q.common.contextualErrorMap });
    }));
  }
};
S6.create = (X, Q) => {
  return new S6({ type: X, typeName: j.ZodPromise, ...l(Q) });
};
var H1 = class extends p {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === j.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(X) {
    let { status: Q, ctx: $ } = this._processInputParams(X), Y = this._def.effect || null, W = { addIssue: (J) => {
      if (b($, J), J.fatal) Q.abort();
      else Q.dirty();
    }, get path() {
      return $.path;
    } };
    if (W.addIssue = W.addIssue.bind(W), Y.type === "preprocess") {
      let J = Y.transform($.data, W);
      if ($.common.async) return Promise.resolve(J).then(async (G) => {
        if (Q.value === "aborted") return g;
        let H = await this._def.schema._parseAsync({ data: G, path: $.path, parent: $ });
        if (H.status === "aborted") return g;
        if (H.status === "dirty") return R6(H.value);
        if (Q.value === "dirty") return R6(H.value);
        return H;
      });
      else {
        if (Q.value === "aborted") return g;
        let G = this._def.schema._parseSync({ data: J, path: $.path, parent: $ });
        if (G.status === "aborted") return g;
        if (G.status === "dirty") return R6(G.value);
        if (Q.value === "dirty") return R6(G.value);
        return G;
      }
    }
    if (Y.type === "refinement") {
      let J = (G) => {
        let H = Y.refinement(G, W);
        if ($.common.async) return Promise.resolve(H);
        if (H instanceof Promise) throw Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return G;
      };
      if ($.common.async === false) {
        let G = this._def.schema._parseSync({ data: $.data, path: $.path, parent: $ });
        if (G.status === "aborted") return g;
        if (G.status === "dirty") Q.dirty();
        return J(G.value), { status: Q.value, value: G.value };
      } else return this._def.schema._parseAsync({ data: $.data, path: $.path, parent: $ }).then((G) => {
        if (G.status === "aborted") return g;
        if (G.status === "dirty") Q.dirty();
        return J(G.value).then(() => {
          return { status: Q.value, value: G.value };
        });
      });
    }
    if (Y.type === "transform") if ($.common.async === false) {
      let J = this._def.schema._parseSync({ data: $.data, path: $.path, parent: $ });
      if (!o1(J)) return g;
      let G = Y.transform(J.value, W);
      if (G instanceof Promise) throw Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
      return { status: Q.value, value: G };
    } else return this._def.schema._parseAsync({ data: $.data, path: $.path, parent: $ }).then((J) => {
      if (!o1(J)) return g;
      return Promise.resolve(Y.transform(J.value, W)).then((G) => ({ status: Q.value, value: G }));
    });
    n.assertNever(Y);
  }
};
H1.create = (X, Q, $) => {
  return new H1({ schema: X, typeName: j.ZodEffects, effect: Q, ...l($) });
};
H1.createWithPreprocess = (X, Q, $) => {
  return new H1({ schema: Q, effect: { type: "preprocess", transform: X }, typeName: j.ZodEffects, ...l($) });
};
var G1 = class extends p {
  _parse(X) {
    if (this._getType(X) === E.undefined) return C0(void 0);
    return this._def.innerType._parse(X);
  }
  unwrap() {
    return this._def.innerType;
  }
};
G1.create = (X, Q) => {
  return new G1({ innerType: X, typeName: j.ZodOptional, ...l(Q) });
};
var T1 = class extends p {
  _parse(X) {
    if (this._getType(X) === E.null) return C0(null);
    return this._def.innerType._parse(X);
  }
  unwrap() {
    return this._def.innerType;
  }
};
T1.create = (X, Q) => {
  return new T1({ innerType: X, typeName: j.ZodNullable, ...l(Q) });
};
var qX = class extends p {
  _parse(X) {
    let { ctx: Q } = this._processInputParams(X), $ = Q.data;
    if (Q.parsedType === E.undefined) $ = this._def.defaultValue();
    return this._def.innerType._parse({ data: $, path: Q.path, parent: Q });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
qX.create = (X, Q) => {
  return new qX({ innerType: X, typeName: j.ZodDefault, defaultValue: typeof Q.default === "function" ? Q.default : () => Q.default, ...l(Q) });
};
var FX = class extends p {
  _parse(X) {
    let { ctx: Q } = this._processInputParams(X), $ = { ...Q, common: { ...Q.common, issues: [] } }, Y = this._def.innerType._parse({ data: $.data, path: $.path, parent: { ...$ } });
    if (WX(Y)) return Y.then((W) => {
      return { status: "valid", value: W.status === "valid" ? W.value : this._def.catchValue({ get error() {
        return new f0($.common.issues);
      }, input: $.data }) };
    });
    else return { status: "valid", value: Y.status === "valid" ? Y.value : this._def.catchValue({ get error() {
      return new f0($.common.issues);
    }, input: $.data }) };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
FX.create = (X, Q) => {
  return new FX({ innerType: X, typeName: j.ZodCatch, catchValue: typeof Q.catch === "function" ? Q.catch : () => Q.catch, ...l(Q) });
};
var R4 = class extends p {
  _parse(X) {
    if (this._getType(X) !== E.nan) {
      let $ = this._getOrReturnCtx(X);
      return b($, { code: w.invalid_type, expected: E.nan, received: $.parsedType }), g;
    }
    return { status: "valid", value: X.data };
  }
};
R4.create = (X) => {
  return new R4({ typeName: j.ZodNaN, ...l(X) });
};
var D8 = class extends p {
  _parse(X) {
    let { ctx: Q } = this._processInputParams(X), $ = Q.data;
    return this._def.type._parse({ data: $, path: Q.path, parent: Q });
  }
  unwrap() {
    return this._def.type;
  }
};
var E4 = class _E4 extends p {
  _parse(X) {
    let { status: Q, ctx: $ } = this._processInputParams(X);
    if ($.common.async) return (async () => {
      let W = await this._def.in._parseAsync({ data: $.data, path: $.path, parent: $ });
      if (W.status === "aborted") return g;
      if (W.status === "dirty") return Q.dirty(), R6(W.value);
      else return this._def.out._parseAsync({ data: W.value, path: $.path, parent: $ });
    })();
    else {
      let Y = this._def.in._parseSync({ data: $.data, path: $.path, parent: $ });
      if (Y.status === "aborted") return g;
      if (Y.status === "dirty") return Q.dirty(), { status: "dirty", value: Y.value };
      else return this._def.out._parseSync({ data: Y.value, path: $.path, parent: $ });
    }
  }
  static create(X, Q) {
    return new _E4({ in: X, out: Q, typeName: j.ZodPipeline });
  }
};
var NX = class extends p {
  _parse(X) {
    let Q = this._def.innerType._parse(X), $ = (Y) => {
      if (o1(Y)) Y.value = Object.freeze(Y.value);
      return Y;
    };
    return WX(Q) ? Q.then((Y) => $(Y)) : $(Q);
  }
  unwrap() {
    return this._def.innerType;
  }
};
NX.create = (X, Q) => {
  return new NX({ innerType: X, typeName: j.ZodReadonly, ...l(Q) });
};
var K2 = { object: V0.lazycreate };
var j;
(function(X) {
  X.ZodString = "ZodString", X.ZodNumber = "ZodNumber", X.ZodNaN = "ZodNaN", X.ZodBigInt = "ZodBigInt", X.ZodBoolean = "ZodBoolean", X.ZodDate = "ZodDate", X.ZodSymbol = "ZodSymbol", X.ZodUndefined = "ZodUndefined", X.ZodNull = "ZodNull", X.ZodAny = "ZodAny", X.ZodUnknown = "ZodUnknown", X.ZodNever = "ZodNever", X.ZodVoid = "ZodVoid", X.ZodArray = "ZodArray", X.ZodObject = "ZodObject", X.ZodUnion = "ZodUnion", X.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", X.ZodIntersection = "ZodIntersection", X.ZodTuple = "ZodTuple", X.ZodRecord = "ZodRecord", X.ZodMap = "ZodMap", X.ZodSet = "ZodSet", X.ZodFunction = "ZodFunction", X.ZodLazy = "ZodLazy", X.ZodLiteral = "ZodLiteral", X.ZodEnum = "ZodEnum", X.ZodEffects = "ZodEffects", X.ZodNativeEnum = "ZodNativeEnum", X.ZodOptional = "ZodOptional", X.ZodNullable = "ZodNullable", X.ZodDefault = "ZodDefault", X.ZodCatch = "ZodCatch", X.ZodPromise = "ZodPromise", X.ZodBranded = "ZodBranded", X.ZodPipeline = "ZodPipeline", X.ZodReadonly = "ZodReadonly";
})(j || (j = {}));
var U2 = A1.create;
var V2 = I6.create;
var L2 = R4.create;
var q2 = b6.create;
var F2 = O4.create;
var N2 = GX.create;
var O2 = D4.create;
var D2 = HX.create;
var A2 = BX.create;
var w2 = A4.create;
var M2 = t1.create;
var j2 = w1.create;
var R2 = w4.create;
var E2 = J1.create;
var FW = V0.create;
var I2 = V0.strictCreate;
var b2 = zX.create;
var P2 = O8.create;
var S2 = KX.create;
var Z2 = M1.create;
var C2 = M4.create;
var k2 = j4.create;
var v2 = P6.create;
var T2 = JX.create;
var _2 = UX.create;
var x2 = VX.create;
var y2 = a1.create;
var g2 = LX.create;
var h2 = S6.create;
var f2 = H1.create;
var u2 = G1.create;
var l2 = T1.create;
var m2 = H1.createWithPreprocess;
var c2 = E4.create;
var wV = Object.freeze({ status: "aborted" });
function O(X, Q, $) {
  var _a;
  function Y(H, B) {
    var _a2, _b;
    var z;
    Object.defineProperty(H, "_zod", { value: (_a2 = H._zod) != null ? _a2 : {}, enumerable: false }), (_b = (z = H._zod).traits) != null ? _b : z.traits = /* @__PURE__ */ new Set(), H._zod.traits.add(X), Q(H, B);
    for (let K in G.prototype) if (!(K in H)) Object.defineProperty(H, K, { value: G.prototype[K].bind(H) });
    H._zod.constr = G, H._zod.def = B;
  }
  let W = (_a = $ == null ? void 0 : $.Parent) != null ? _a : Object;
  class J extends W {
  }
  Object.defineProperty(J, "name", { value: X });
  function G(H) {
    var _a2;
    var B;
    let z = ($ == null ? void 0 : $.Parent) ? new J() : this;
    Y(z, H), (_a2 = (B = z._zod).deferred) != null ? _a2 : B.deferred = [];
    for (let K of z._zod.deferred) K();
    return z;
  }
  return Object.defineProperty(G, "init", { value: Y }), Object.defineProperty(G, Symbol.hasInstance, { value: (H) => {
    var _a2, _b;
    if (($ == null ? void 0 : $.Parent) && H instanceof $.Parent) return true;
    return (_b = (_a2 = H == null ? void 0 : H._zod) == null ? void 0 : _a2.traits) == null ? void 0 : _b.has(X);
  } }), Object.defineProperty(G, "name", { value: X }), G;
}
var _1 = class extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
};
var I4 = {};
function u0(X) {
  if (X) Object.assign(I4, X);
  return I4;
}
var i = {};
U7(i, { unwrapMessage: () => OX, stringifyPrimitive: () => S4, required: () => hV, randomString: () => ZV, propertyKeyTypes: () => E8, promiseAllObject: () => SV, primitiveTypes: () => NW, prefixIssues: () => B1, pick: () => TV, partial: () => gV, optionalKeys: () => I8, omit: () => _V, numKeys: () => CV, nullish: () => wX, normalizeParams: () => y, merge: () => yV, jsonStringifyReplacer: () => w8, joinValues: () => b4, issue: () => P8, isPlainObject: () => C6, isObject: () => Z6, getSizableOrigin: () => DW, getParsedType: () => kV, getLengthableOrigin: () => jX, getEnumValues: () => DX, getElementAtPath: () => PV, floatSafeRemainder: () => M8, finalizeIssue: () => o0, extend: () => xV, escapeRegex: () => x1, esc: () => s1, defineLazy: () => Y0, createTransparentProxy: () => vV, clone: () => l0, cleanRegex: () => MX, cleanEnum: () => fV, captureStackTrace: () => P4, cached: () => AX, assignProp: () => j8, assertNotEqual: () => RV, assertNever: () => IV, assertIs: () => EV, assertEqual: () => jV, assert: () => bV, allowsEval: () => R8, aborted: () => e1, NUMBER_FORMAT_RANGES: () => b8, Class: () => AW, BIGINT_FORMAT_RANGES: () => OW });
function jV(X) {
  return X;
}
function RV(X) {
  return X;
}
function EV(X) {
}
function IV(X) {
  throw Error();
}
function bV(X) {
}
function DX(X) {
  let Q = Object.values(X).filter((Y) => typeof Y === "number");
  return Object.entries(X).filter(([Y, W]) => Q.indexOf(+Y) === -1).map(([Y, W]) => W);
}
function b4(X, Q = "|") {
  return X.map(($) => S4($)).join(Q);
}
function w8(X, Q) {
  if (typeof Q === "bigint") return Q.toString();
  return Q;
}
function AX(X) {
  return { get value() {
    {
      let $ = X();
      return Object.defineProperty(this, "value", { value: $ }), $;
    }
    throw Error("cached value already set");
  } };
}
function wX(X) {
  return X === null || X === void 0;
}
function MX(X) {
  let Q = X.startsWith("^") ? 1 : 0, $ = X.endsWith("$") ? X.length - 1 : X.length;
  return X.slice(Q, $);
}
function M8(X, Q) {
  let $ = (X.toString().split(".")[1] || "").length, Y = (Q.toString().split(".")[1] || "").length, W = $ > Y ? $ : Y, J = Number.parseInt(X.toFixed(W).replace(".", "")), G = Number.parseInt(Q.toFixed(W).replace(".", ""));
  return J % G / 10 ** W;
}
function Y0(X, Q, $) {
  Object.defineProperty(X, Q, { get() {
    {
      let W = $();
      return X[Q] = W, W;
    }
    throw Error("cached value already set");
  }, set(W) {
    Object.defineProperty(X, Q, { value: W });
  }, configurable: true });
}
function j8(X, Q, $) {
  Object.defineProperty(X, Q, { value: $, writable: true, enumerable: true, configurable: true });
}
function PV(X, Q) {
  if (!Q) return X;
  return Q.reduce(($, Y) => $ == null ? void 0 : $[Y], X);
}
function SV(X) {
  let Q = Object.keys(X), $ = Q.map((Y) => X[Y]);
  return Promise.all($).then((Y) => {
    let W = {};
    for (let J = 0; J < Q.length; J++) W[Q[J]] = Y[J];
    return W;
  });
}
function ZV(X = 10) {
  let $ = "";
  for (let Y = 0; Y < X; Y++) $ += "abcdefghijklmnopqrstuvwxyz"[Math.floor(Math.random() * 26)];
  return $;
}
function s1(X) {
  return JSON.stringify(X);
}
var P4 = Error.captureStackTrace ? Error.captureStackTrace : (...X) => {
};
function Z6(X) {
  return typeof X === "object" && X !== null && !Array.isArray(X);
}
var R8 = AX(() => {
  var _a;
  if (typeof navigator < "u" && ((_a = navigator == null ? void 0 : navigator.userAgent) == null ? void 0 : _a.includes("Cloudflare"))) return false;
  try {
    return new Function(""), true;
  } catch (X) {
    return false;
  }
});
function C6(X) {
  if (Z6(X) === false) return false;
  let Q = X.constructor;
  if (Q === void 0) return true;
  let $ = Q.prototype;
  if (Z6($) === false) return false;
  if (Object.prototype.hasOwnProperty.call($, "isPrototypeOf") === false) return false;
  return true;
}
function CV(X) {
  let Q = 0;
  for (let $ in X) if (Object.prototype.hasOwnProperty.call(X, $)) Q++;
  return Q;
}
var kV = (X) => {
  let Q = typeof X;
  switch (Q) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(X) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(X)) return "array";
      if (X === null) return "null";
      if (X.then && typeof X.then === "function" && X.catch && typeof X.catch === "function") return "promise";
      if (typeof Map < "u" && X instanceof Map) return "map";
      if (typeof Set < "u" && X instanceof Set) return "set";
      if (typeof Date < "u" && X instanceof Date) return "date";
      if (typeof File < "u" && X instanceof File) return "file";
      return "object";
    default:
      throw Error(`Unknown data type: ${Q}`);
  }
};
var E8 = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
var NW = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function x1(X) {
  return X.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function l0(X, Q, $) {
  let Y = new X._zod.constr(Q != null ? Q : X._zod.def);
  if (!Q || ($ == null ? void 0 : $.parent)) Y._zod.parent = X;
  return Y;
}
function y(X) {
  let Q = X;
  if (!Q) return {};
  if (typeof Q === "string") return { error: () => Q };
  if ((Q == null ? void 0 : Q.message) !== void 0) {
    if ((Q == null ? void 0 : Q.error) !== void 0) throw Error("Cannot specify both `message` and `error` params");
    Q.error = Q.message;
  }
  if (delete Q.message, typeof Q.error === "string") return { ...Q, error: () => Q.error };
  return Q;
}
function vV(X) {
  let Q;
  return new Proxy({}, { get($, Y, W) {
    return Q != null ? Q : Q = X(), Reflect.get(Q, Y, W);
  }, set($, Y, W, J) {
    return Q != null ? Q : Q = X(), Reflect.set(Q, Y, W, J);
  }, has($, Y) {
    return Q != null ? Q : Q = X(), Reflect.has(Q, Y);
  }, deleteProperty($, Y) {
    return Q != null ? Q : Q = X(), Reflect.deleteProperty(Q, Y);
  }, ownKeys($) {
    return Q != null ? Q : Q = X(), Reflect.ownKeys(Q);
  }, getOwnPropertyDescriptor($, Y) {
    return Q != null ? Q : Q = X(), Reflect.getOwnPropertyDescriptor(Q, Y);
  }, defineProperty($, Y, W) {
    return Q != null ? Q : Q = X(), Reflect.defineProperty(Q, Y, W);
  } });
}
function S4(X) {
  if (typeof X === "bigint") return X.toString() + "n";
  if (typeof X === "string") return `"${X}"`;
  return `${X}`;
}
function I8(X) {
  return Object.keys(X).filter((Q) => {
    return X[Q]._zod.optin === "optional" && X[Q]._zod.optout === "optional";
  });
}
var b8 = { safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER], int32: [-2147483648, 2147483647], uint32: [0, 4294967295], float32: [-34028234663852886e22, 34028234663852886e22], float64: [-Number.MAX_VALUE, Number.MAX_VALUE] };
var OW = { int64: [BigInt("-9223372036854775808"), BigInt("9223372036854775807")], uint64: [BigInt(0), BigInt("18446744073709551615")] };
function TV(X, Q) {
  let $ = {}, Y = X._zod.def;
  for (let W in Q) {
    if (!(W in Y.shape)) throw Error(`Unrecognized key: "${W}"`);
    if (!Q[W]) continue;
    $[W] = Y.shape[W];
  }
  return l0(X, { ...X._zod.def, shape: $, checks: [] });
}
function _V(X, Q) {
  let $ = { ...X._zod.def.shape }, Y = X._zod.def;
  for (let W in Q) {
    if (!(W in Y.shape)) throw Error(`Unrecognized key: "${W}"`);
    if (!Q[W]) continue;
    delete $[W];
  }
  return l0(X, { ...X._zod.def, shape: $, checks: [] });
}
function xV(X, Q) {
  if (!C6(Q)) throw Error("Invalid input to extend: expected a plain object");
  let $ = { ...X._zod.def, get shape() {
    let Y = { ...X._zod.def.shape, ...Q };
    return j8(this, "shape", Y), Y;
  }, checks: [] };
  return l0(X, $);
}
function yV(X, Q) {
  return l0(X, { ...X._zod.def, get shape() {
    let $ = { ...X._zod.def.shape, ...Q._zod.def.shape };
    return j8(this, "shape", $), $;
  }, catchall: Q._zod.def.catchall, checks: [] });
}
function gV(X, Q, $) {
  let Y = Q._zod.def.shape, W = { ...Y };
  if ($) for (let J in $) {
    if (!(J in Y)) throw Error(`Unrecognized key: "${J}"`);
    if (!$[J]) continue;
    W[J] = X ? new X({ type: "optional", innerType: Y[J] }) : Y[J];
  }
  else for (let J in Y) W[J] = X ? new X({ type: "optional", innerType: Y[J] }) : Y[J];
  return l0(Q, { ...Q._zod.def, shape: W, checks: [] });
}
function hV(X, Q, $) {
  let Y = Q._zod.def.shape, W = { ...Y };
  if ($) for (let J in $) {
    if (!(J in W)) throw Error(`Unrecognized key: "${J}"`);
    if (!$[J]) continue;
    W[J] = new X({ type: "nonoptional", innerType: Y[J] });
  }
  else for (let J in Y) W[J] = new X({ type: "nonoptional", innerType: Y[J] });
  return l0(Q, { ...Q._zod.def, shape: W, checks: [] });
}
function e1(X, Q = 0) {
  var _a;
  for (let $ = Q; $ < X.issues.length; $++) if (((_a = X.issues[$]) == null ? void 0 : _a.continue) !== true) return true;
  return false;
}
function B1(X, Q) {
  return Q.map(($) => {
    var _a;
    var Y;
    return (_a = (Y = $).path) != null ? _a : Y.path = [], $.path.unshift(X), $;
  });
}
function OX(X) {
  return typeof X === "string" ? X : X == null ? void 0 : X.message;
}
function o0(X, Q, $) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
  let Y = { ...X, path: (_a = X.path) != null ? _a : [] };
  if (!X.message) {
    let W = (_k = (_j = (_h = (_f = OX((_d = (_c = (_b = X.inst) == null ? void 0 : _b._zod.def) == null ? void 0 : _c.error) == null ? void 0 : _d.call(_c, X))) != null ? _f : OX((_e = Q == null ? void 0 : Q.error) == null ? void 0 : _e.call(Q, X))) != null ? _h : OX((_g = $.customError) == null ? void 0 : _g.call($, X))) != null ? _j : OX((_i = $.localeError) == null ? void 0 : _i.call($, X))) != null ? _k : "Invalid input";
    Y.message = W;
  }
  if (delete Y.inst, delete Y.continue, !(Q == null ? void 0 : Q.reportInput)) delete Y.input;
  return Y;
}
function DW(X) {
  if (X instanceof Set) return "set";
  if (X instanceof Map) return "map";
  if (X instanceof File) return "file";
  return "unknown";
}
function jX(X) {
  if (Array.isArray(X)) return "array";
  if (typeof X === "string") return "string";
  return "unknown";
}
function P8(...X) {
  let [Q, $, Y] = X;
  if (typeof Q === "string") return { message: Q, code: "custom", input: $, inst: Y };
  return { ...Q };
}
function fV(X) {
  return Object.entries(X).filter(([Q, $]) => {
    return Number.isNaN(Number.parseInt(Q, 10));
  }).map((Q) => Q[1]);
}
var AW = class {
  constructor(...X) {
  }
};
var wW = (X, Q) => {
  X.name = "$ZodError", Object.defineProperty(X, "_zod", { value: X._zod, enumerable: false }), Object.defineProperty(X, "issues", { value: Q, enumerable: false }), Object.defineProperty(X, "message", { get() {
    return JSON.stringify(Q, w8, 2);
  }, enumerable: true });
};
var Z4 = O("$ZodError", wW);
var RX = O("$ZodError", wW, { Parent: Error });
function S8(X, Q = ($) => $.message) {
  let $ = {}, Y = [];
  for (let W of X.issues) if (W.path.length > 0) $[W.path[0]] = $[W.path[0]] || [], $[W.path[0]].push(Q(W));
  else Y.push(Q(W));
  return { formErrors: Y, fieldErrors: $ };
}
function Z8(X, Q) {
  let $ = Q || function(J) {
    return J.message;
  }, Y = { _errors: [] }, W = (J) => {
    for (let G of J.issues) if (G.code === "invalid_union" && G.errors.length) G.errors.map((H) => W({ issues: H }));
    else if (G.code === "invalid_key") W({ issues: G.issues });
    else if (G.code === "invalid_element") W({ issues: G.issues });
    else if (G.path.length === 0) Y._errors.push($(G));
    else {
      let H = Y, B = 0;
      while (B < G.path.length) {
        let z = G.path[B];
        if (B !== G.path.length - 1) H[z] = H[z] || { _errors: [] };
        else H[z] = H[z] || { _errors: [] }, H[z]._errors.push($(G));
        H = H[z], B++;
      }
    }
  };
  return W(X), Y;
}
var C8 = (X) => (Q, $, Y, W) => {
  var _a;
  let J = Y ? Object.assign(Y, { async: false }) : { async: false }, G = Q._zod.run({ value: $, issues: [] }, J);
  if (G instanceof Promise) throw new _1();
  if (G.issues.length) {
    let H = new ((_a = W == null ? void 0 : W.Err) != null ? _a : X)(G.issues.map((B) => o0(B, J, u0())));
    throw P4(H, W == null ? void 0 : W.callee), H;
  }
  return G.value;
};
var k8 = C8(RX);
var v8 = (X) => async (Q, $, Y, W) => {
  var _a;
  let J = Y ? Object.assign(Y, { async: true }) : { async: true }, G = Q._zod.run({ value: $, issues: [] }, J);
  if (G instanceof Promise) G = await G;
  if (G.issues.length) {
    let H = new ((_a = W == null ? void 0 : W.Err) != null ? _a : X)(G.issues.map((B) => o0(B, J, u0())));
    throw P4(H, W == null ? void 0 : W.callee), H;
  }
  return G.value;
};
var T8 = v8(RX);
var _8 = (X) => (Q, $, Y) => {
  let W = Y ? { ...Y, async: false } : { async: false }, J = Q._zod.run({ value: $, issues: [] }, W);
  if (J instanceof Promise) throw new _1();
  return J.issues.length ? { success: false, error: new (X != null ? X : Z4)(J.issues.map((G) => o0(G, W, u0()))) } : { success: true, data: J.value };
};
var X6 = _8(RX);
var x8 = (X) => async (Q, $, Y) => {
  let W = Y ? Object.assign(Y, { async: true }) : { async: true }, J = Q._zod.run({ value: $, issues: [] }, W);
  if (J instanceof Promise) J = await J;
  return J.issues.length ? { success: false, error: new X(J.issues.map((G) => o0(G, W, u0()))) } : { success: true, data: J.value };
};
var Q6 = x8(RX);
var MW = /^[cC][^\s-]{8,}$/;
var jW = /^[0-9a-z]+$/;
var RW = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var EW = /^[0-9a-vA-V]{20}$/;
var IW = /^[A-Za-z0-9]{27}$/;
var bW = /^[a-zA-Z0-9_-]{21}$/;
var PW = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var SW = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var y8 = (X) => {
  if (!X) return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${X}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var ZW = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
function CW() {
  return new RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
}
var kW = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var vW = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;
var TW = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var _W = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var xW = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var g8 = /^[A-Za-z0-9_-]*$/;
var yW = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
var gW = /^\+(?:[0-9]){6,14}[0-9]$/;
var hW = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))";
var fW = new RegExp(`^${hW}$`);
function uW(X) {
  return typeof X.precision === "number" ? X.precision === -1 ? "(?:[01]\\d|2[0-3]):[0-5]\\d" : X.precision === 0 ? "(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d" : `(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d\\.\\d{${X.precision}}` : "(?:[01]\\d|2[0-3]):[0-5]\\d(?::[0-5]\\d(?:\\.\\d+)?)?";
}
function lW(X) {
  return new RegExp(`^${uW(X)}$`);
}
function mW(X) {
  let Q = uW({ precision: X.precision }), $ = ["Z"];
  if (X.local) $.push("");
  if (X.offset) $.push("([+-]\\d{2}:\\d{2})");
  let Y = `${Q}(?:${$.join("|")})`;
  return new RegExp(`^${hW}T(?:${Y})$`);
}
var cW = (X) => {
  var _a, _b;
  let Q = X ? `[\\s\\S]{${(_a = X == null ? void 0 : X.minimum) != null ? _a : 0},${(_b = X == null ? void 0 : X.maximum) != null ? _b : ""}}` : "[\\s\\S]*";
  return new RegExp(`^${Q}$`);
};
var pW = /^\d+$/;
var dW = /^-?\d+(?:\.\d+)?/i;
var iW = /true|false/i;
var nW = /null/i;
var rW = /^[^A-Z]*$/;
var oW = /^[^a-z]*$/;
var w0 = O("$ZodCheck", (X, Q) => {
  var _a, _b;
  var $;
  (_a = X._zod) != null ? _a : X._zod = {}, X._zod.def = Q, (_b = ($ = X._zod).onattach) != null ? _b : $.onattach = [];
});
var tW = { number: "number", bigint: "bigint", object: "date" };
var h8 = O("$ZodCheckLessThan", (X, Q) => {
  w0.init(X, Q);
  let $ = tW[typeof Q.value];
  X._zod.onattach.push((Y) => {
    var _a;
    let W = Y._zod.bag, J = (_a = Q.inclusive ? W.maximum : W.exclusiveMaximum) != null ? _a : Number.POSITIVE_INFINITY;
    if (Q.value < J) if (Q.inclusive) W.maximum = Q.value;
    else W.exclusiveMaximum = Q.value;
  }), X._zod.check = (Y) => {
    if (Q.inclusive ? Y.value <= Q.value : Y.value < Q.value) return;
    Y.issues.push({ origin: $, code: "too_big", maximum: Q.value, input: Y.value, inclusive: Q.inclusive, inst: X, continue: !Q.abort });
  };
});
var f8 = O("$ZodCheckGreaterThan", (X, Q) => {
  w0.init(X, Q);
  let $ = tW[typeof Q.value];
  X._zod.onattach.push((Y) => {
    var _a;
    let W = Y._zod.bag, J = (_a = Q.inclusive ? W.minimum : W.exclusiveMinimum) != null ? _a : Number.NEGATIVE_INFINITY;
    if (Q.value > J) if (Q.inclusive) W.minimum = Q.value;
    else W.exclusiveMinimum = Q.value;
  }), X._zod.check = (Y) => {
    if (Q.inclusive ? Y.value >= Q.value : Y.value > Q.value) return;
    Y.issues.push({ origin: $, code: "too_small", minimum: Q.value, input: Y.value, inclusive: Q.inclusive, inst: X, continue: !Q.abort });
  };
});
var aW = O("$ZodCheckMultipleOf", (X, Q) => {
  w0.init(X, Q), X._zod.onattach.push(($) => {
    var _a;
    var Y;
    (_a = (Y = $._zod.bag).multipleOf) != null ? _a : Y.multipleOf = Q.value;
  }), X._zod.check = ($) => {
    if (typeof $.value !== typeof Q.value) throw Error("Cannot mix number and bigint in multiple_of check.");
    if (typeof $.value === "bigint" ? $.value % Q.value === BigInt(0) : M8($.value, Q.value) === 0) return;
    $.issues.push({ origin: typeof $.value, code: "not_multiple_of", divisor: Q.value, input: $.value, inst: X, continue: !Q.abort });
  };
});
var sW = O("$ZodCheckNumberFormat", (X, Q) => {
  var _a;
  w0.init(X, Q), Q.format = Q.format || "float64";
  let $ = (_a = Q.format) == null ? void 0 : _a.includes("int"), Y = $ ? "int" : "number", [W, J] = b8[Q.format];
  X._zod.onattach.push((G) => {
    let H = G._zod.bag;
    if (H.format = Q.format, H.minimum = W, H.maximum = J, $) H.pattern = pW;
  }), X._zod.check = (G) => {
    let H = G.value;
    if ($) {
      if (!Number.isInteger(H)) {
        G.issues.push({ expected: Y, format: Q.format, code: "invalid_type", input: H, inst: X });
        return;
      }
      if (!Number.isSafeInteger(H)) {
        if (H > 0) G.issues.push({ input: H, code: "too_big", maximum: Number.MAX_SAFE_INTEGER, note: "Integers must be within the safe integer range.", inst: X, origin: Y, continue: !Q.abort });
        else G.issues.push({ input: H, code: "too_small", minimum: Number.MIN_SAFE_INTEGER, note: "Integers must be within the safe integer range.", inst: X, origin: Y, continue: !Q.abort });
        return;
      }
    }
    if (H < W) G.issues.push({ origin: "number", input: H, code: "too_small", minimum: W, inclusive: true, inst: X, continue: !Q.abort });
    if (H > J) G.issues.push({ origin: "number", input: H, code: "too_big", maximum: J, inst: X });
  };
});
var eW = O("$ZodCheckMaxLength", (X, Q) => {
  w0.init(X, Q), X._zod.when = ($) => {
    let Y = $.value;
    return !wX(Y) && Y.length !== void 0;
  }, X._zod.onattach.push(($) => {
    var _a;
    let Y = (_a = $._zod.bag.maximum) != null ? _a : Number.POSITIVE_INFINITY;
    if (Q.maximum < Y) $._zod.bag.maximum = Q.maximum;
  }), X._zod.check = ($) => {
    let Y = $.value;
    if (Y.length <= Q.maximum) return;
    let J = jX(Y);
    $.issues.push({ origin: J, code: "too_big", maximum: Q.maximum, inclusive: true, input: Y, inst: X, continue: !Q.abort });
  };
});
var XJ = O("$ZodCheckMinLength", (X, Q) => {
  w0.init(X, Q), X._zod.when = ($) => {
    let Y = $.value;
    return !wX(Y) && Y.length !== void 0;
  }, X._zod.onattach.push(($) => {
    var _a;
    let Y = (_a = $._zod.bag.minimum) != null ? _a : Number.NEGATIVE_INFINITY;
    if (Q.minimum > Y) $._zod.bag.minimum = Q.minimum;
  }), X._zod.check = ($) => {
    let Y = $.value;
    if (Y.length >= Q.minimum) return;
    let J = jX(Y);
    $.issues.push({ origin: J, code: "too_small", minimum: Q.minimum, inclusive: true, input: Y, inst: X, continue: !Q.abort });
  };
});
var QJ = O("$ZodCheckLengthEquals", (X, Q) => {
  w0.init(X, Q), X._zod.when = ($) => {
    let Y = $.value;
    return !wX(Y) && Y.length !== void 0;
  }, X._zod.onattach.push(($) => {
    let Y = $._zod.bag;
    Y.minimum = Q.length, Y.maximum = Q.length, Y.length = Q.length;
  }), X._zod.check = ($) => {
    let Y = $.value, W = Y.length;
    if (W === Q.length) return;
    let J = jX(Y), G = W > Q.length;
    $.issues.push({ origin: J, ...G ? { code: "too_big", maximum: Q.length } : { code: "too_small", minimum: Q.length }, inclusive: true, exact: true, input: $.value, inst: X, continue: !Q.abort });
  };
});
var EX = O("$ZodCheckStringFormat", (X, Q) => {
  var _a, _b;
  var $, Y;
  if (w0.init(X, Q), X._zod.onattach.push((W) => {
    var _a2;
    let J = W._zod.bag;
    if (J.format = Q.format, Q.pattern) (_a2 = J.patterns) != null ? _a2 : J.patterns = /* @__PURE__ */ new Set(), J.patterns.add(Q.pattern);
  }), Q.pattern) (_a = ($ = X._zod).check) != null ? _a : $.check = (W) => {
    if (Q.pattern.lastIndex = 0, Q.pattern.test(W.value)) return;
    W.issues.push({ origin: "string", code: "invalid_format", format: Q.format, input: W.value, ...Q.pattern ? { pattern: Q.pattern.toString() } : {}, inst: X, continue: !Q.abort });
  };
  else (_b = (Y = X._zod).check) != null ? _b : Y.check = () => {
  };
});
var $J = O("$ZodCheckRegex", (X, Q) => {
  EX.init(X, Q), X._zod.check = ($) => {
    if (Q.pattern.lastIndex = 0, Q.pattern.test($.value)) return;
    $.issues.push({ origin: "string", code: "invalid_format", format: "regex", input: $.value, pattern: Q.pattern.toString(), inst: X, continue: !Q.abort });
  };
});
var YJ = O("$ZodCheckLowerCase", (X, Q) => {
  var _a;
  (_a = Q.pattern) != null ? _a : Q.pattern = rW, EX.init(X, Q);
});
var WJ = O("$ZodCheckUpperCase", (X, Q) => {
  var _a;
  (_a = Q.pattern) != null ? _a : Q.pattern = oW, EX.init(X, Q);
});
var JJ = O("$ZodCheckIncludes", (X, Q) => {
  w0.init(X, Q);
  let $ = x1(Q.includes), Y = new RegExp(typeof Q.position === "number" ? `^.{${Q.position}}${$}` : $);
  Q.pattern = Y, X._zod.onattach.push((W) => {
    var _a;
    let J = W._zod.bag;
    (_a = J.patterns) != null ? _a : J.patterns = /* @__PURE__ */ new Set(), J.patterns.add(Y);
  }), X._zod.check = (W) => {
    if (W.value.includes(Q.includes, Q.position)) return;
    W.issues.push({ origin: "string", code: "invalid_format", format: "includes", includes: Q.includes, input: W.value, inst: X, continue: !Q.abort });
  };
});
var GJ = O("$ZodCheckStartsWith", (X, Q) => {
  var _a;
  w0.init(X, Q);
  let $ = new RegExp(`^${x1(Q.prefix)}.*`);
  (_a = Q.pattern) != null ? _a : Q.pattern = $, X._zod.onattach.push((Y) => {
    var _a2;
    let W = Y._zod.bag;
    (_a2 = W.patterns) != null ? _a2 : W.patterns = /* @__PURE__ */ new Set(), W.patterns.add($);
  }), X._zod.check = (Y) => {
    if (Y.value.startsWith(Q.prefix)) return;
    Y.issues.push({ origin: "string", code: "invalid_format", format: "starts_with", prefix: Q.prefix, input: Y.value, inst: X, continue: !Q.abort });
  };
});
var HJ = O("$ZodCheckEndsWith", (X, Q) => {
  var _a;
  w0.init(X, Q);
  let $ = new RegExp(`.*${x1(Q.suffix)}$`);
  (_a = Q.pattern) != null ? _a : Q.pattern = $, X._zod.onattach.push((Y) => {
    var _a2;
    let W = Y._zod.bag;
    (_a2 = W.patterns) != null ? _a2 : W.patterns = /* @__PURE__ */ new Set(), W.patterns.add($);
  }), X._zod.check = (Y) => {
    if (Y.value.endsWith(Q.suffix)) return;
    Y.issues.push({ origin: "string", code: "invalid_format", format: "ends_with", suffix: Q.suffix, input: Y.value, inst: X, continue: !Q.abort });
  };
});
var BJ = O("$ZodCheckOverwrite", (X, Q) => {
  w0.init(X, Q), X._zod.check = ($) => {
    $.value = Q.tx($.value);
  };
});
var u8 = class {
  constructor(X = []) {
    if (this.content = [], this.indent = 0, this) this.args = X;
  }
  indented(X) {
    this.indent += 1, X(this), this.indent -= 1;
  }
  write(X) {
    if (typeof X === "function") {
      X(this, { execution: "sync" }), X(this, { execution: "async" });
      return;
    }
    let $ = X.split(`
`).filter((J) => J), Y = Math.min(...$.map((J) => J.length - J.trimStart().length)), W = $.map((J) => J.slice(Y)).map((J) => " ".repeat(this.indent * 2) + J);
    for (let J of W) this.content.push(J);
  }
  compile() {
    var _a;
    let X = Function, Q = this == null ? void 0 : this.args, Y = [...((_a = this == null ? void 0 : this.content) != null ? _a : [""]).map((W) => `  ${W}`)];
    return new X(...Q, Y.join(`
`));
  }
};
var KJ = { major: 4, minor: 0, patch: 0 };
var X0 = O("$ZodType", (X, Q) => {
  var _a, _b, _c;
  var $;
  X != null ? X : X = {}, X._zod.def = Q, X._zod.bag = X._zod.bag || {}, X._zod.version = KJ;
  let Y = [...(_a = X._zod.def.checks) != null ? _a : []];
  if (X._zod.traits.has("$ZodCheck")) Y.unshift(X);
  for (let W of Y) for (let J of W._zod.onattach) J(X);
  if (Y.length === 0) (_b = ($ = X._zod).deferred) != null ? _b : $.deferred = [], (_c = X._zod.deferred) == null ? void 0 : _c.push(() => {
    X._zod.run = X._zod.parse;
  });
  else {
    let W = (J, G, H) => {
      let B = e1(J), z;
      for (let K of G) {
        if (K._zod.when) {
          if (!K._zod.when(J)) continue;
        } else if (B) continue;
        let V = J.issues.length, L = K._zod.check(J);
        if (L instanceof Promise && (H == null ? void 0 : H.async) === false) throw new _1();
        if (z || L instanceof Promise) z = (z != null ? z : Promise.resolve()).then(async () => {
          if (await L, J.issues.length === V) return;
          if (!B) B = e1(J, V);
        });
        else {
          if (J.issues.length === V) continue;
          if (!B) B = e1(J, V);
        }
      }
      if (z) return z.then(() => {
        return J;
      });
      return J;
    };
    X._zod.run = (J, G) => {
      let H = X._zod.parse(J, G);
      if (H instanceof Promise) {
        if (G.async === false) throw new _1();
        return H.then((B) => W(B, Y, G));
      }
      return W(H, Y, G);
    };
  }
  X["~standard"] = { validate: (W) => {
    var _a2;
    try {
      let J = X6(X, W);
      return J.success ? { value: J.data } : { issues: (_a2 = J.error) == null ? void 0 : _a2.issues };
    } catch (J) {
      return Q6(X, W).then((G) => {
        var _a3;
        return G.success ? { value: G.data } : { issues: (_a3 = G.error) == null ? void 0 : _a3.issues };
      });
    }
  }, vendor: "zod", version: 1 };
});
var IX = O("$ZodString", (X, Q) => {
  var _a, _b, _c;
  X0.init(X, Q), X._zod.pattern = (_c = [...(_b = (_a = X == null ? void 0 : X._zod.bag) == null ? void 0 : _a.patterns) != null ? _b : []].pop()) != null ? _c : cW(X._zod.bag), X._zod.parse = ($, Y) => {
    if (Q.coerce) try {
      $.value = String($.value);
    } catch (W) {
    }
    if (typeof $.value === "string") return $;
    return $.issues.push({ expected: "string", code: "invalid_type", input: $.value, inst: X }), $;
  };
});
var W0 = O("$ZodStringFormat", (X, Q) => {
  EX.init(X, Q), IX.init(X, Q);
});
var m8 = O("$ZodGUID", (X, Q) => {
  var _a;
  (_a = Q.pattern) != null ? _a : Q.pattern = SW, W0.init(X, Q);
});
var c8 = O("$ZodUUID", (X, Q) => {
  var _a, _b;
  if (Q.version) {
    let Y = { v1: 1, v2: 2, v3: 3, v4: 4, v5: 5, v6: 6, v7: 7, v8: 8 }[Q.version];
    if (Y === void 0) throw Error(`Invalid UUID version: "${Q.version}"`);
    (_a = Q.pattern) != null ? _a : Q.pattern = y8(Y);
  } else (_b = Q.pattern) != null ? _b : Q.pattern = y8();
  W0.init(X, Q);
});
var p8 = O("$ZodEmail", (X, Q) => {
  var _a;
  (_a = Q.pattern) != null ? _a : Q.pattern = ZW, W0.init(X, Q);
});
var d8 = O("$ZodURL", (X, Q) => {
  W0.init(X, Q), X._zod.check = ($) => {
    try {
      let Y = $.value, W = new URL(Y), J = W.href;
      if (Q.hostname) {
        if (Q.hostname.lastIndex = 0, !Q.hostname.test(W.hostname)) $.issues.push({ code: "invalid_format", format: "url", note: "Invalid hostname", pattern: yW.source, input: $.value, inst: X, continue: !Q.abort });
      }
      if (Q.protocol) {
        if (Q.protocol.lastIndex = 0, !Q.protocol.test(W.protocol.endsWith(":") ? W.protocol.slice(0, -1) : W.protocol)) $.issues.push({ code: "invalid_format", format: "url", note: "Invalid protocol", pattern: Q.protocol.source, input: $.value, inst: X, continue: !Q.abort });
      }
      if (!Y.endsWith("/") && J.endsWith("/")) $.value = J.slice(0, -1);
      else $.value = J;
      return;
    } catch (Y) {
      $.issues.push({ code: "invalid_format", format: "url", input: $.value, inst: X, continue: !Q.abort });
    }
  };
});
var i8 = O("$ZodEmoji", (X, Q) => {
  var _a;
  (_a = Q.pattern) != null ? _a : Q.pattern = CW(), W0.init(X, Q);
});
var n8 = O("$ZodNanoID", (X, Q) => {
  var _a;
  (_a = Q.pattern) != null ? _a : Q.pattern = bW, W0.init(X, Q);
});
var r8 = O("$ZodCUID", (X, Q) => {
  var _a;
  (_a = Q.pattern) != null ? _a : Q.pattern = MW, W0.init(X, Q);
});
var o8 = O("$ZodCUID2", (X, Q) => {
  var _a;
  (_a = Q.pattern) != null ? _a : Q.pattern = jW, W0.init(X, Q);
});
var t8 = O("$ZodULID", (X, Q) => {
  var _a;
  (_a = Q.pattern) != null ? _a : Q.pattern = RW, W0.init(X, Q);
});
var a8 = O("$ZodXID", (X, Q) => {
  var _a;
  (_a = Q.pattern) != null ? _a : Q.pattern = EW, W0.init(X, Q);
});
var s8 = O("$ZodKSUID", (X, Q) => {
  var _a;
  (_a = Q.pattern) != null ? _a : Q.pattern = IW, W0.init(X, Q);
});
var wJ = O("$ZodISODateTime", (X, Q) => {
  var _a;
  (_a = Q.pattern) != null ? _a : Q.pattern = mW(Q), W0.init(X, Q);
});
var MJ = O("$ZodISODate", (X, Q) => {
  var _a;
  (_a = Q.pattern) != null ? _a : Q.pattern = fW, W0.init(X, Q);
});
var jJ = O("$ZodISOTime", (X, Q) => {
  var _a;
  (_a = Q.pattern) != null ? _a : Q.pattern = lW(Q), W0.init(X, Q);
});
var RJ = O("$ZodISODuration", (X, Q) => {
  var _a;
  (_a = Q.pattern) != null ? _a : Q.pattern = PW, W0.init(X, Q);
});
var e8 = O("$ZodIPv4", (X, Q) => {
  var _a;
  (_a = Q.pattern) != null ? _a : Q.pattern = kW, W0.init(X, Q), X._zod.onattach.push(($) => {
    let Y = $._zod.bag;
    Y.format = "ipv4";
  });
});
var XQ = O("$ZodIPv6", (X, Q) => {
  var _a;
  (_a = Q.pattern) != null ? _a : Q.pattern = vW, W0.init(X, Q), X._zod.onattach.push(($) => {
    let Y = $._zod.bag;
    Y.format = "ipv6";
  }), X._zod.check = ($) => {
    try {
      new URL(`http://[${$.value}]`);
    } catch (e2) {
      $.issues.push({ code: "invalid_format", format: "ipv6", input: $.value, inst: X, continue: !Q.abort });
    }
  };
});
var QQ = O("$ZodCIDRv4", (X, Q) => {
  var _a;
  (_a = Q.pattern) != null ? _a : Q.pattern = TW, W0.init(X, Q);
});
var $Q = O("$ZodCIDRv6", (X, Q) => {
  var _a;
  (_a = Q.pattern) != null ? _a : Q.pattern = _W, W0.init(X, Q), X._zod.check = ($) => {
    let [Y, W] = $.value.split("/");
    try {
      if (!W) throw Error();
      let J = Number(W);
      if (`${J}` !== W) throw Error();
      if (J < 0 || J > 128) throw Error();
      new URL(`http://[${Y}]`);
    } catch (e2) {
      $.issues.push({ code: "invalid_format", format: "cidrv6", input: $.value, inst: X, continue: !Q.abort });
    }
  };
});
function EJ(X) {
  if (X === "") return true;
  if (X.length % 4 !== 0) return false;
  try {
    return atob(X), true;
  } catch (e2) {
    return false;
  }
}
var YQ = O("$ZodBase64", (X, Q) => {
  var _a;
  (_a = Q.pattern) != null ? _a : Q.pattern = xW, W0.init(X, Q), X._zod.onattach.push(($) => {
    $._zod.bag.contentEncoding = "base64";
  }), X._zod.check = ($) => {
    if (EJ($.value)) return;
    $.issues.push({ code: "invalid_format", format: "base64", input: $.value, inst: X, continue: !Q.abort });
  };
});
function lV(X) {
  if (!g8.test(X)) return false;
  let Q = X.replace(/[-_]/g, (Y) => Y === "-" ? "+" : "/"), $ = Q.padEnd(Math.ceil(Q.length / 4) * 4, "=");
  return EJ($);
}
var WQ = O("$ZodBase64URL", (X, Q) => {
  var _a;
  (_a = Q.pattern) != null ? _a : Q.pattern = g8, W0.init(X, Q), X._zod.onattach.push(($) => {
    $._zod.bag.contentEncoding = "base64url";
  }), X._zod.check = ($) => {
    if (lV($.value)) return;
    $.issues.push({ code: "invalid_format", format: "base64url", input: $.value, inst: X, continue: !Q.abort });
  };
});
var JQ = O("$ZodE164", (X, Q) => {
  var _a;
  (_a = Q.pattern) != null ? _a : Q.pattern = gW, W0.init(X, Q);
});
function mV(X, Q = null) {
  try {
    let $ = X.split(".");
    if ($.length !== 3) return false;
    let [Y] = $;
    if (!Y) return false;
    let W = JSON.parse(atob(Y));
    if ("typ" in W && (W == null ? void 0 : W.typ) !== "JWT") return false;
    if (!W.alg) return false;
    if (Q && (!("alg" in W) || W.alg !== Q)) return false;
    return true;
  } catch (e2) {
    return false;
  }
}
var GQ = O("$ZodJWT", (X, Q) => {
  W0.init(X, Q), X._zod.check = ($) => {
    if (mV($.value, Q.alg)) return;
    $.issues.push({ code: "invalid_format", format: "jwt", input: $.value, inst: X, continue: !Q.abort });
  };
});
var v4 = O("$ZodNumber", (X, Q) => {
  var _a;
  X0.init(X, Q), X._zod.pattern = (_a = X._zod.bag.pattern) != null ? _a : dW, X._zod.parse = ($, Y) => {
    if (Q.coerce) try {
      $.value = Number($.value);
    } catch (G) {
    }
    let W = $.value;
    if (typeof W === "number" && !Number.isNaN(W) && Number.isFinite(W)) return $;
    let J = typeof W === "number" ? Number.isNaN(W) ? "NaN" : !Number.isFinite(W) ? "Infinity" : void 0 : void 0;
    return $.issues.push({ expected: "number", code: "invalid_type", input: W, inst: X, ...J ? { received: J } : {} }), $;
  };
});
var HQ = O("$ZodNumber", (X, Q) => {
  sW.init(X, Q), v4.init(X, Q);
});
var BQ = O("$ZodBoolean", (X, Q) => {
  X0.init(X, Q), X._zod.pattern = iW, X._zod.parse = ($, Y) => {
    if (Q.coerce) try {
      $.value = Boolean($.value);
    } catch (J) {
    }
    let W = $.value;
    if (typeof W === "boolean") return $;
    return $.issues.push({ expected: "boolean", code: "invalid_type", input: W, inst: X }), $;
  };
});
var zQ = O("$ZodNull", (X, Q) => {
  X0.init(X, Q), X._zod.pattern = nW, X._zod.values = /* @__PURE__ */ new Set([null]), X._zod.parse = ($, Y) => {
    let W = $.value;
    if (W === null) return $;
    return $.issues.push({ expected: "null", code: "invalid_type", input: W, inst: X }), $;
  };
});
var KQ = O("$ZodUnknown", (X, Q) => {
  X0.init(X, Q), X._zod.parse = ($) => $;
});
var UQ = O("$ZodNever", (X, Q) => {
  X0.init(X, Q), X._zod.parse = ($, Y) => {
    return $.issues.push({ expected: "never", code: "invalid_type", input: $.value, inst: X }), $;
  };
});
function UJ(X, Q, $) {
  if (X.issues.length) Q.issues.push(...B1($, X.issues));
  Q.value[$] = X.value;
}
var VQ = O("$ZodArray", (X, Q) => {
  X0.init(X, Q), X._zod.parse = ($, Y) => {
    let W = $.value;
    if (!Array.isArray(W)) return $.issues.push({ expected: "array", code: "invalid_type", input: W, inst: X }), $;
    $.value = Array(W.length);
    let J = [];
    for (let G = 0; G < W.length; G++) {
      let H = W[G], B = Q.element._zod.run({ value: H, issues: [] }, Y);
      if (B instanceof Promise) J.push(B.then((z) => UJ(z, $, G)));
      else UJ(B, $, G);
    }
    if (J.length) return Promise.all(J).then(() => $);
    return $;
  };
});
function k4(X, Q, $) {
  if (X.issues.length) Q.issues.push(...B1($, X.issues));
  Q.value[$] = X.value;
}
function VJ(X, Q, $, Y) {
  if (X.issues.length) if (Y[$] === void 0) if ($ in Y) Q.value[$] = void 0;
  else Q.value[$] = X.value;
  else Q.issues.push(...B1($, X.issues));
  else if (X.value === void 0) {
    if ($ in Y) Q.value[$] = void 0;
  } else Q.value[$] = X.value;
}
var T4 = O("$ZodObject", (X, Q) => {
  X0.init(X, Q);
  let $ = AX(() => {
    let V = Object.keys(Q.shape);
    for (let U of V) if (!(Q.shape[U] instanceof X0)) throw Error(`Invalid element at key "${U}": expected a Zod schema`);
    let L = I8(Q.shape);
    return { shape: Q.shape, keys: V, keySet: new Set(V), numKeys: V.length, optionalKeys: new Set(L) };
  });
  Y0(X._zod, "propValues", () => {
    var _a;
    let V = Q.shape, L = {};
    for (let U in V) {
      let F = V[U]._zod;
      if (F.values) {
        (_a = L[U]) != null ? _a : L[U] = /* @__PURE__ */ new Set();
        for (let q of F.values) L[U].add(q);
      }
    }
    return L;
  });
  let Y = (V) => {
    let L = new u8(["shape", "payload", "ctx"]), U = $.value, F = (M) => {
      let R = s1(M);
      return `shape[${R}]._zod.run({ value: input[${R}], issues: [] }, ctx)`;
    };
    L.write("const input = payload.value;");
    let q = /* @__PURE__ */ Object.create(null), N = 0;
    for (let M of U.keys) q[M] = `key_${N++}`;
    L.write("const newResult = {}");
    for (let M of U.keys) if (U.optionalKeys.has(M)) {
      let R = q[M];
      L.write(`const ${R} = ${F(M)};`);
      let S = s1(M);
      L.write(`
        if (${R}.issues.length) {
          if (input[${S}] === undefined) {
            if (${S} in input) {
              newResult[${S}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${R}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${S}, ...iss.path] : [${S}],
              }))
            );
          }
        } else if (${R}.value === undefined) {
          if (${S} in input) newResult[${S}] = undefined;
        } else {
          newResult[${S}] = ${R}.value;
        }
        `);
    } else {
      let R = q[M];
      L.write(`const ${R} = ${F(M)};`), L.write(`
          if (${R}.issues.length) payload.issues = payload.issues.concat(${R}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${s1(M)}, ...iss.path] : [${s1(M)}]
          })));`), L.write(`newResult[${s1(M)}] = ${R}.value`);
    }
    L.write("payload.value = newResult;"), L.write("return payload;");
    let A = L.compile();
    return (M, R) => A(V, M, R);
  }, W, J = Z6, G = !I4.jitless, B = G && R8.value, z = Q.catchall, K;
  X._zod.parse = (V, L) => {
    K != null ? K : K = $.value;
    let U = V.value;
    if (!J(U)) return V.issues.push({ expected: "object", code: "invalid_type", input: U, inst: X }), V;
    let F = [];
    if (G && B && (L == null ? void 0 : L.async) === false && L.jitless !== true) {
      if (!W) W = Y(Q.shape);
      V = W(V, L);
    } else {
      V.value = {};
      let R = K.shape;
      for (let S of K.keys) {
        let C = R[S], K0 = C._zod.run({ value: U[S], issues: [] }, L), U0 = C._zod.optin === "optional" && C._zod.optout === "optional";
        if (K0 instanceof Promise) F.push(K0.then((s) => U0 ? VJ(s, V, S, U) : k4(s, V, S)));
        else if (U0) VJ(K0, V, S, U);
        else k4(K0, V, S);
      }
    }
    if (!z) return F.length ? Promise.all(F).then(() => V) : V;
    let q = [], N = K.keySet, A = z._zod, M = A.def.type;
    for (let R of Object.keys(U)) {
      if (N.has(R)) continue;
      if (M === "never") {
        q.push(R);
        continue;
      }
      let S = A.run({ value: U[R], issues: [] }, L);
      if (S instanceof Promise) F.push(S.then((C) => k4(C, V, R)));
      else k4(S, V, R);
    }
    if (q.length) V.issues.push({ code: "unrecognized_keys", keys: q, input: U, inst: X });
    if (!F.length) return V;
    return Promise.all(F).then(() => {
      return V;
    });
  };
});
function LJ(X, Q, $, Y) {
  for (let W of X) if (W.issues.length === 0) return Q.value = W.value, Q;
  return Q.issues.push({ code: "invalid_union", input: Q.value, inst: $, errors: X.map((W) => W.issues.map((J) => o0(J, Y, u0()))) }), Q;
}
var _4 = O("$ZodUnion", (X, Q) => {
  X0.init(X, Q), Y0(X._zod, "optin", () => Q.options.some(($) => $._zod.optin === "optional") ? "optional" : void 0), Y0(X._zod, "optout", () => Q.options.some(($) => $._zod.optout === "optional") ? "optional" : void 0), Y0(X._zod, "values", () => {
    if (Q.options.every(($) => $._zod.values)) return new Set(Q.options.flatMap(($) => Array.from($._zod.values)));
    return;
  }), Y0(X._zod, "pattern", () => {
    if (Q.options.every(($) => $._zod.pattern)) {
      let $ = Q.options.map((Y) => Y._zod.pattern);
      return new RegExp(`^(${$.map((Y) => MX(Y.source)).join("|")})$`);
    }
    return;
  }), X._zod.parse = ($, Y) => {
    let W = false, J = [];
    for (let G of Q.options) {
      let H = G._zod.run({ value: $.value, issues: [] }, Y);
      if (H instanceof Promise) J.push(H), W = true;
      else {
        if (H.issues.length === 0) return H;
        J.push(H);
      }
    }
    if (!W) return LJ(J, $, X, Y);
    return Promise.all(J).then((G) => {
      return LJ(G, $, X, Y);
    });
  };
});
var LQ = O("$ZodDiscriminatedUnion", (X, Q) => {
  _4.init(X, Q);
  let $ = X._zod.parse;
  Y0(X._zod, "propValues", () => {
    let W = {};
    for (let J of Q.options) {
      let G = J._zod.propValues;
      if (!G || Object.keys(G).length === 0) throw Error(`Invalid discriminated union option at index "${Q.options.indexOf(J)}"`);
      for (let [H, B] of Object.entries(G)) {
        if (!W[H]) W[H] = /* @__PURE__ */ new Set();
        for (let z of B) W[H].add(z);
      }
    }
    return W;
  });
  let Y = AX(() => {
    let W = Q.options, J = /* @__PURE__ */ new Map();
    for (let G of W) {
      let H = G._zod.propValues[Q.discriminator];
      if (!H || H.size === 0) throw Error(`Invalid discriminated union option at index "${Q.options.indexOf(G)}"`);
      for (let B of H) {
        if (J.has(B)) throw Error(`Duplicate discriminator value "${String(B)}"`);
        J.set(B, G);
      }
    }
    return J;
  });
  X._zod.parse = (W, J) => {
    let G = W.value;
    if (!Z6(G)) return W.issues.push({ code: "invalid_type", expected: "object", input: G, inst: X }), W;
    let H = Y.value.get(G == null ? void 0 : G[Q.discriminator]);
    if (H) return H._zod.run(W, J);
    if (Q.unionFallback) return $(W, J);
    return W.issues.push({ code: "invalid_union", errors: [], note: "No matching discriminator", input: G, path: [Q.discriminator], inst: X }), W;
  };
});
var qQ = O("$ZodIntersection", (X, Q) => {
  X0.init(X, Q), X._zod.parse = ($, Y) => {
    let W = $.value, J = Q.left._zod.run({ value: W, issues: [] }, Y), G = Q.right._zod.run({ value: W, issues: [] }, Y);
    if (J instanceof Promise || G instanceof Promise) return Promise.all([J, G]).then(([B, z]) => {
      return qJ($, B, z);
    });
    return qJ($, J, G);
  };
});
function l8(X, Q) {
  if (X === Q) return { valid: true, data: X };
  if (X instanceof Date && Q instanceof Date && +X === +Q) return { valid: true, data: X };
  if (C6(X) && C6(Q)) {
    let $ = Object.keys(Q), Y = Object.keys(X).filter((J) => $.indexOf(J) !== -1), W = { ...X, ...Q };
    for (let J of Y) {
      let G = l8(X[J], Q[J]);
      if (!G.valid) return { valid: false, mergeErrorPath: [J, ...G.mergeErrorPath] };
      W[J] = G.data;
    }
    return { valid: true, data: W };
  }
  if (Array.isArray(X) && Array.isArray(Q)) {
    if (X.length !== Q.length) return { valid: false, mergeErrorPath: [] };
    let $ = [];
    for (let Y = 0; Y < X.length; Y++) {
      let W = X[Y], J = Q[Y], G = l8(W, J);
      if (!G.valid) return { valid: false, mergeErrorPath: [Y, ...G.mergeErrorPath] };
      $.push(G.data);
    }
    return { valid: true, data: $ };
  }
  return { valid: false, mergeErrorPath: [] };
}
function qJ(X, Q, $) {
  if (Q.issues.length) X.issues.push(...Q.issues);
  if ($.issues.length) X.issues.push(...$.issues);
  if (e1(X)) return X;
  let Y = l8(Q.value, $.value);
  if (!Y.valid) throw Error(`Unmergable intersection. Error path: ${JSON.stringify(Y.mergeErrorPath)}`);
  return X.value = Y.data, X;
}
var FQ = O("$ZodRecord", (X, Q) => {
  X0.init(X, Q), X._zod.parse = ($, Y) => {
    let W = $.value;
    if (!C6(W)) return $.issues.push({ expected: "record", code: "invalid_type", input: W, inst: X }), $;
    let J = [];
    if (Q.keyType._zod.values) {
      let G = Q.keyType._zod.values;
      $.value = {};
      for (let B of G) if (typeof B === "string" || typeof B === "number" || typeof B === "symbol") {
        let z = Q.valueType._zod.run({ value: W[B], issues: [] }, Y);
        if (z instanceof Promise) J.push(z.then((K) => {
          if (K.issues.length) $.issues.push(...B1(B, K.issues));
          $.value[B] = K.value;
        }));
        else {
          if (z.issues.length) $.issues.push(...B1(B, z.issues));
          $.value[B] = z.value;
        }
      }
      let H;
      for (let B in W) if (!G.has(B)) H = H != null ? H : [], H.push(B);
      if (H && H.length > 0) $.issues.push({ code: "unrecognized_keys", input: W, inst: X, keys: H });
    } else {
      $.value = {};
      for (let G of Reflect.ownKeys(W)) {
        if (G === "__proto__") continue;
        let H = Q.keyType._zod.run({ value: G, issues: [] }, Y);
        if (H instanceof Promise) throw Error("Async schemas not supported in object keys currently");
        if (H.issues.length) {
          $.issues.push({ origin: "record", code: "invalid_key", issues: H.issues.map((z) => o0(z, Y, u0())), input: G, path: [G], inst: X }), $.value[H.value] = H.value;
          continue;
        }
        let B = Q.valueType._zod.run({ value: W[G], issues: [] }, Y);
        if (B instanceof Promise) J.push(B.then((z) => {
          if (z.issues.length) $.issues.push(...B1(G, z.issues));
          $.value[H.value] = z.value;
        }));
        else {
          if (B.issues.length) $.issues.push(...B1(G, B.issues));
          $.value[H.value] = B.value;
        }
      }
    }
    if (J.length) return Promise.all(J).then(() => $);
    return $;
  };
});
var NQ = O("$ZodEnum", (X, Q) => {
  X0.init(X, Q);
  let $ = DX(Q.entries);
  X._zod.values = new Set($), X._zod.pattern = new RegExp(`^(${$.filter((Y) => E8.has(typeof Y)).map((Y) => typeof Y === "string" ? x1(Y) : Y.toString()).join("|")})$`), X._zod.parse = (Y, W) => {
    let J = Y.value;
    if (X._zod.values.has(J)) return Y;
    return Y.issues.push({ code: "invalid_value", values: $, input: J, inst: X }), Y;
  };
});
var OQ = O("$ZodLiteral", (X, Q) => {
  X0.init(X, Q), X._zod.values = new Set(Q.values), X._zod.pattern = new RegExp(`^(${Q.values.map(($) => typeof $ === "string" ? x1($) : $ ? $.toString() : String($)).join("|")})$`), X._zod.parse = ($, Y) => {
    let W = $.value;
    if (X._zod.values.has(W)) return $;
    return $.issues.push({ code: "invalid_value", values: Q.values, input: W, inst: X }), $;
  };
});
var DQ = O("$ZodTransform", (X, Q) => {
  X0.init(X, Q), X._zod.parse = ($, Y) => {
    let W = Q.transform($.value, $);
    if (Y.async) return (W instanceof Promise ? W : Promise.resolve(W)).then((G) => {
      return $.value = G, $;
    });
    if (W instanceof Promise) throw new _1();
    return $.value = W, $;
  };
});
var AQ = O("$ZodOptional", (X, Q) => {
  X0.init(X, Q), X._zod.optin = "optional", X._zod.optout = "optional", Y0(X._zod, "values", () => {
    return Q.innerType._zod.values ? /* @__PURE__ */ new Set([...Q.innerType._zod.values, void 0]) : void 0;
  }), Y0(X._zod, "pattern", () => {
    let $ = Q.innerType._zod.pattern;
    return $ ? new RegExp(`^(${MX($.source)})?$`) : void 0;
  }), X._zod.parse = ($, Y) => {
    if (Q.innerType._zod.optin === "optional") return Q.innerType._zod.run($, Y);
    if ($.value === void 0) return $;
    return Q.innerType._zod.run($, Y);
  };
});
var wQ = O("$ZodNullable", (X, Q) => {
  X0.init(X, Q), Y0(X._zod, "optin", () => Q.innerType._zod.optin), Y0(X._zod, "optout", () => Q.innerType._zod.optout), Y0(X._zod, "pattern", () => {
    let $ = Q.innerType._zod.pattern;
    return $ ? new RegExp(`^(${MX($.source)}|null)$`) : void 0;
  }), Y0(X._zod, "values", () => {
    return Q.innerType._zod.values ? /* @__PURE__ */ new Set([...Q.innerType._zod.values, null]) : void 0;
  }), X._zod.parse = ($, Y) => {
    if ($.value === null) return $;
    return Q.innerType._zod.run($, Y);
  };
});
var MQ = O("$ZodDefault", (X, Q) => {
  X0.init(X, Q), X._zod.optin = "optional", Y0(X._zod, "values", () => Q.innerType._zod.values), X._zod.parse = ($, Y) => {
    if ($.value === void 0) return $.value = Q.defaultValue, $;
    let W = Q.innerType._zod.run($, Y);
    if (W instanceof Promise) return W.then((J) => FJ(J, Q));
    return FJ(W, Q);
  };
});
function FJ(X, Q) {
  if (X.value === void 0) X.value = Q.defaultValue;
  return X;
}
var jQ = O("$ZodPrefault", (X, Q) => {
  X0.init(X, Q), X._zod.optin = "optional", Y0(X._zod, "values", () => Q.innerType._zod.values), X._zod.parse = ($, Y) => {
    if ($.value === void 0) $.value = Q.defaultValue;
    return Q.innerType._zod.run($, Y);
  };
});
var RQ = O("$ZodNonOptional", (X, Q) => {
  X0.init(X, Q), Y0(X._zod, "values", () => {
    let $ = Q.innerType._zod.values;
    return $ ? new Set([...$].filter((Y) => Y !== void 0)) : void 0;
  }), X._zod.parse = ($, Y) => {
    let W = Q.innerType._zod.run($, Y);
    if (W instanceof Promise) return W.then((J) => NJ(J, X));
    return NJ(W, X);
  };
});
function NJ(X, Q) {
  if (!X.issues.length && X.value === void 0) X.issues.push({ code: "invalid_type", expected: "nonoptional", input: X.value, inst: Q });
  return X;
}
var EQ = O("$ZodCatch", (X, Q) => {
  X0.init(X, Q), X._zod.optin = "optional", Y0(X._zod, "optout", () => Q.innerType._zod.optout), Y0(X._zod, "values", () => Q.innerType._zod.values), X._zod.parse = ($, Y) => {
    let W = Q.innerType._zod.run($, Y);
    if (W instanceof Promise) return W.then((J) => {
      if ($.value = J.value, J.issues.length) $.value = Q.catchValue({ ...$, error: { issues: J.issues.map((G) => o0(G, Y, u0())) }, input: $.value }), $.issues = [];
      return $;
    });
    if ($.value = W.value, W.issues.length) $.value = Q.catchValue({ ...$, error: { issues: W.issues.map((J) => o0(J, Y, u0())) }, input: $.value }), $.issues = [];
    return $;
  };
});
var IQ = O("$ZodPipe", (X, Q) => {
  X0.init(X, Q), Y0(X._zod, "values", () => Q.in._zod.values), Y0(X._zod, "optin", () => Q.in._zod.optin), Y0(X._zod, "optout", () => Q.out._zod.optout), X._zod.parse = ($, Y) => {
    let W = Q.in._zod.run($, Y);
    if (W instanceof Promise) return W.then((J) => OJ(J, Q, Y));
    return OJ(W, Q, Y);
  };
});
function OJ(X, Q, $) {
  if (e1(X)) return X;
  return Q.out._zod.run({ value: X.value, issues: X.issues }, $);
}
var bQ = O("$ZodReadonly", (X, Q) => {
  X0.init(X, Q), Y0(X._zod, "propValues", () => Q.innerType._zod.propValues), Y0(X._zod, "values", () => Q.innerType._zod.values), Y0(X._zod, "optin", () => Q.innerType._zod.optin), Y0(X._zod, "optout", () => Q.innerType._zod.optout), X._zod.parse = ($, Y) => {
    let W = Q.innerType._zod.run($, Y);
    if (W instanceof Promise) return W.then(DJ);
    return DJ(W);
  };
});
function DJ(X) {
  return X.value = Object.freeze(X.value), X;
}
var PQ = O("$ZodCustom", (X, Q) => {
  w0.init(X, Q), X0.init(X, Q), X._zod.parse = ($, Y) => {
    return $;
  }, X._zod.check = ($) => {
    let Y = $.value, W = Q.fn(Y);
    if (W instanceof Promise) return W.then((J) => AJ(J, $, Y, X));
    AJ(W, $, Y, X);
    return;
  };
});
function AJ(X, Q, $, Y) {
  var _a;
  if (!X) {
    let W = { code: "custom", input: $, inst: Y, path: [...(_a = Y._zod.def.path) != null ? _a : []], continue: !Y._zod.def.abort };
    if (Y._zod.def.params) W.params = Y._zod.def.params;
    Q.issues.push(P8(W));
  }
}
var cV = (X) => {
  let Q = typeof X;
  switch (Q) {
    case "number":
      return Number.isNaN(X) ? "NaN" : "number";
    case "object": {
      if (Array.isArray(X)) return "array";
      if (X === null) return "null";
      if (Object.getPrototypeOf(X) !== Object.prototype && X.constructor) return X.constructor.name;
    }
  }
  return Q;
};
var pV = () => {
  let X = { string: { unit: "characters", verb: "to have" }, file: { unit: "bytes", verb: "to have" }, array: { unit: "items", verb: "to have" }, set: { unit: "items", verb: "to have" } };
  function Q(Y) {
    var _a;
    return (_a = X[Y]) != null ? _a : null;
  }
  let $ = { regex: "input", email: "email address", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datetime", date: "ISO date", time: "ISO time", duration: "ISO duration", ipv4: "IPv4 address", ipv6: "IPv6 address", cidrv4: "IPv4 range", cidrv6: "IPv6 range", base64: "base64-encoded string", base64url: "base64url-encoded string", json_string: "JSON string", e164: "E.164 number", jwt: "JWT", template_literal: "input" };
  return (Y) => {
    var _a, _b, _c, _d;
    switch (Y.code) {
      case "invalid_type":
        return `Invalid input: expected ${Y.expected}, received ${cV(Y.input)}`;
      case "invalid_value":
        if (Y.values.length === 1) return `Invalid input: expected ${S4(Y.values[0])}`;
        return `Invalid option: expected one of ${b4(Y.values, "|")}`;
      case "too_big": {
        let W = Y.inclusive ? "<=" : "<", J = Q(Y.origin);
        if (J) return `Too big: expected ${(_a = Y.origin) != null ? _a : "value"} to have ${W}${Y.maximum.toString()} ${(_b = J.unit) != null ? _b : "elements"}`;
        return `Too big: expected ${(_c = Y.origin) != null ? _c : "value"} to be ${W}${Y.maximum.toString()}`;
      }
      case "too_small": {
        let W = Y.inclusive ? ">=" : ">", J = Q(Y.origin);
        if (J) return `Too small: expected ${Y.origin} to have ${W}${Y.minimum.toString()} ${J.unit}`;
        return `Too small: expected ${Y.origin} to be ${W}${Y.minimum.toString()}`;
      }
      case "invalid_format": {
        let W = Y;
        if (W.format === "starts_with") return `Invalid string: must start with "${W.prefix}"`;
        if (W.format === "ends_with") return `Invalid string: must end with "${W.suffix}"`;
        if (W.format === "includes") return `Invalid string: must include "${W.includes}"`;
        if (W.format === "regex") return `Invalid string: must match pattern ${W.pattern}`;
        return `Invalid ${(_d = $[W.format]) != null ? _d : Y.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${Y.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${Y.keys.length > 1 ? "s" : ""}: ${b4(Y.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${Y.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${Y.origin}`;
      default:
        return "Invalid input";
    }
  };
};
function SQ() {
  return { localeError: pV() };
}
var x4 = class {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(X, ...Q) {
    let $ = Q[0];
    if (this._map.set(X, $), $ && typeof $ === "object" && "id" in $) {
      if (this._idmap.has($.id)) throw Error(`ID ${$.id} already exists in the registry`);
      this._idmap.set($.id, X);
    }
    return this;
  }
  remove(X) {
    return this._map.delete(X), this;
  }
  get(X) {
    var _a;
    let Q = X._zod.parent;
    if (Q) {
      let $ = { ...(_a = this.get(Q)) != null ? _a : {} };
      return delete $.id, { ...$, ...this._map.get(X) };
    }
    return this._map.get(X);
  }
  has(X) {
    return this._map.has(X);
  }
};
function IJ() {
  return new x4();
}
var y1 = IJ();
function ZQ(X, Q) {
  return new X({ type: "string", ...y(Q) });
}
function CQ(X, Q) {
  return new X({ type: "string", format: "email", check: "string_format", abort: false, ...y(Q) });
}
function y4(X, Q) {
  return new X({ type: "string", format: "guid", check: "string_format", abort: false, ...y(Q) });
}
function kQ(X, Q) {
  return new X({ type: "string", format: "uuid", check: "string_format", abort: false, ...y(Q) });
}
function vQ(X, Q) {
  return new X({ type: "string", format: "uuid", check: "string_format", abort: false, version: "v4", ...y(Q) });
}
function TQ(X, Q) {
  return new X({ type: "string", format: "uuid", check: "string_format", abort: false, version: "v6", ...y(Q) });
}
function _Q(X, Q) {
  return new X({ type: "string", format: "uuid", check: "string_format", abort: false, version: "v7", ...y(Q) });
}
function xQ(X, Q) {
  return new X({ type: "string", format: "url", check: "string_format", abort: false, ...y(Q) });
}
function yQ(X, Q) {
  return new X({ type: "string", format: "emoji", check: "string_format", abort: false, ...y(Q) });
}
function gQ(X, Q) {
  return new X({ type: "string", format: "nanoid", check: "string_format", abort: false, ...y(Q) });
}
function hQ(X, Q) {
  return new X({ type: "string", format: "cuid", check: "string_format", abort: false, ...y(Q) });
}
function fQ(X, Q) {
  return new X({ type: "string", format: "cuid2", check: "string_format", abort: false, ...y(Q) });
}
function uQ(X, Q) {
  return new X({ type: "string", format: "ulid", check: "string_format", abort: false, ...y(Q) });
}
function lQ(X, Q) {
  return new X({ type: "string", format: "xid", check: "string_format", abort: false, ...y(Q) });
}
function mQ(X, Q) {
  return new X({ type: "string", format: "ksuid", check: "string_format", abort: false, ...y(Q) });
}
function cQ(X, Q) {
  return new X({ type: "string", format: "ipv4", check: "string_format", abort: false, ...y(Q) });
}
function pQ(X, Q) {
  return new X({ type: "string", format: "ipv6", check: "string_format", abort: false, ...y(Q) });
}
function dQ(X, Q) {
  return new X({ type: "string", format: "cidrv4", check: "string_format", abort: false, ...y(Q) });
}
function iQ(X, Q) {
  return new X({ type: "string", format: "cidrv6", check: "string_format", abort: false, ...y(Q) });
}
function nQ(X, Q) {
  return new X({ type: "string", format: "base64", check: "string_format", abort: false, ...y(Q) });
}
function rQ(X, Q) {
  return new X({ type: "string", format: "base64url", check: "string_format", abort: false, ...y(Q) });
}
function oQ(X, Q) {
  return new X({ type: "string", format: "e164", check: "string_format", abort: false, ...y(Q) });
}
function tQ(X, Q) {
  return new X({ type: "string", format: "jwt", check: "string_format", abort: false, ...y(Q) });
}
function bJ(X, Q) {
  return new X({ type: "string", format: "datetime", check: "string_format", offset: false, local: false, precision: null, ...y(Q) });
}
function PJ(X, Q) {
  return new X({ type: "string", format: "date", check: "string_format", ...y(Q) });
}
function SJ(X, Q) {
  return new X({ type: "string", format: "time", check: "string_format", precision: null, ...y(Q) });
}
function ZJ(X, Q) {
  return new X({ type: "string", format: "duration", check: "string_format", ...y(Q) });
}
function aQ(X, Q) {
  return new X({ type: "number", checks: [], ...y(Q) });
}
function sQ(X, Q) {
  return new X({ type: "number", check: "number_format", abort: false, format: "safeint", ...y(Q) });
}
function eQ(X, Q) {
  return new X({ type: "boolean", ...y(Q) });
}
function X$(X, Q) {
  return new X({ type: "null", ...y(Q) });
}
function Q$(X) {
  return new X({ type: "unknown" });
}
function $$(X, Q) {
  return new X({ type: "never", ...y(Q) });
}
function g4(X, Q) {
  return new h8({ check: "less_than", ...y(Q), value: X, inclusive: false });
}
function bX(X, Q) {
  return new h8({ check: "less_than", ...y(Q), value: X, inclusive: true });
}
function h4(X, Q) {
  return new f8({ check: "greater_than", ...y(Q), value: X, inclusive: false });
}
function PX(X, Q) {
  return new f8({ check: "greater_than", ...y(Q), value: X, inclusive: true });
}
function f4(X, Q) {
  return new aW({ check: "multiple_of", ...y(Q), value: X });
}
function u4(X, Q) {
  return new eW({ check: "max_length", ...y(Q), maximum: X });
}
function k6(X, Q) {
  return new XJ({ check: "min_length", ...y(Q), minimum: X });
}
function l4(X, Q) {
  return new QJ({ check: "length_equals", ...y(Q), length: X });
}
function Y$(X, Q) {
  return new $J({ check: "string_format", format: "regex", ...y(Q), pattern: X });
}
function W$(X) {
  return new YJ({ check: "string_format", format: "lowercase", ...y(X) });
}
function J$(X) {
  return new WJ({ check: "string_format", format: "uppercase", ...y(X) });
}
function G$(X, Q) {
  return new JJ({ check: "string_format", format: "includes", ...y(Q), includes: X });
}
function H$(X, Q) {
  return new GJ({ check: "string_format", format: "starts_with", ...y(Q), prefix: X });
}
function B$(X, Q) {
  return new HJ({ check: "string_format", format: "ends_with", ...y(Q), suffix: X });
}
function $6(X) {
  return new BJ({ check: "overwrite", tx: X });
}
function z$(X) {
  return $6((Q) => Q.normalize(X));
}
function K$() {
  return $6((X) => X.trim());
}
function U$() {
  return $6((X) => X.toLowerCase());
}
function V$() {
  return $6((X) => X.toUpperCase());
}
function CJ(X, Q, $) {
  return new X({ type: "array", element: Q, ...y($) });
}
function L$(X, Q, $) {
  var _a;
  let Y = y($);
  return (_a = Y.abort) != null ? _a : Y.abort = true, new X({ type: "custom", check: "custom", fn: Q, ...Y });
}
function q$(X, Q, $) {
  return new X({ type: "custom", check: "custom", fn: Q, ...y($) });
}
var PL = O("ZodMiniType", (X, Q) => {
  if (!X._zod) throw Error("Uninitialized schema in ZodMiniType.");
  X0.init(X, Q), X.def = Q, X.parse = ($, Y) => k8(X, $, Y, { callee: X.parse }), X.safeParse = ($, Y) => X6(X, $, Y), X.parseAsync = async ($, Y) => T8(X, $, Y, { callee: X.parseAsync }), X.safeParseAsync = async ($, Y) => Q6(X, $, Y), X.check = (...$) => {
    var _a;
    return X.clone({ ...Q, checks: [...(_a = Q.checks) != null ? _a : [], ...$.map((Y) => typeof Y === "function" ? { _zod: { check: Y, def: { check: "custom" }, onattach: [] } } : Y)] });
  }, X.clone = ($, Y) => l0(X, $, Y), X.brand = () => X, X.register = ($, Y) => {
    return $.add(X, Y), X;
  };
});
var SL = O("ZodMiniObject", (X, Q) => {
  T4.init(X, Q), PL.init(X, Q), i.defineLazy(X, "shape", () => Q.shape);
});
var SX = {};
U7(SX, { time: () => w$, duration: () => M$, datetime: () => D$, date: () => A$, ZodISOTime: () => yJ, ZodISODuration: () => gJ, ZodISODateTime: () => _J, ZodISODate: () => xJ });
var _J = O("ZodISODateTime", (X, Q) => {
  wJ.init(X, Q), H0.init(X, Q);
});
function D$(X) {
  return bJ(_J, X);
}
var xJ = O("ZodISODate", (X, Q) => {
  MJ.init(X, Q), H0.init(X, Q);
});
function A$(X) {
  return PJ(xJ, X);
}
var yJ = O("ZodISOTime", (X, Q) => {
  jJ.init(X, Q), H0.init(X, Q);
});
function w$(X) {
  return SJ(yJ, X);
}
var gJ = O("ZodISODuration", (X, Q) => {
  RJ.init(X, Q), H0.init(X, Q);
});
function M$(X) {
  return ZJ(gJ, X);
}
var hJ = (X, Q) => {
  Z4.init(X, Q), X.name = "ZodError", Object.defineProperties(X, { format: { value: ($) => Z8(X, $) }, flatten: { value: ($) => S8(X, $) }, addIssue: { value: ($) => X.issues.push($) }, addIssues: { value: ($) => X.issues.push(...$) }, isEmpty: { get() {
    return X.issues.length === 0;
  } } });
};
var oS = O("ZodError", hJ);
var ZX = O("ZodError", hJ, { Parent: Error });
var fJ = C8(ZX);
var uJ = v8(ZX);
var lJ = _8(ZX);
var mJ = x8(ZX);
var z0 = O("ZodType", (X, Q) => {
  return X0.init(X, Q), X.def = Q, Object.defineProperty(X, "_def", { value: Q }), X.check = (...$) => {
    var _a;
    return X.clone({ ...Q, checks: [...(_a = Q.checks) != null ? _a : [], ...$.map((Y) => typeof Y === "function" ? { _zod: { check: Y, def: { check: "custom" }, onattach: [] } } : Y)] });
  }, X.clone = ($, Y) => l0(X, $, Y), X.brand = () => X, X.register = ($, Y) => {
    return $.add(X, Y), X;
  }, X.parse = ($, Y) => fJ(X, $, Y, { callee: X.parse }), X.safeParse = ($, Y) => lJ(X, $, Y), X.parseAsync = async ($, Y) => uJ(X, $, Y, { callee: X.parseAsync }), X.safeParseAsync = async ($, Y) => mJ(X, $, Y), X.spa = X.safeParseAsync, X.refine = ($, Y) => X.check(Iq($, Y)), X.superRefine = ($) => X.check(bq($)), X.overwrite = ($) => X.check($6($)), X.optional = () => v(X), X.nullable = () => dJ(X), X.nullish = () => v(dJ(X)), X.nonoptional = ($) => Dq(X, $), X.array = () => r(X), X.or = ($) => J0([X, $]), X.and = ($) => i4(X, $), X.transform = ($) => R$(X, tJ($)), X.default = ($) => Fq(X, $), X.prefault = ($) => Oq(X, $), X.catch = ($) => wq(X, $), X.pipe = ($) => R$(X, $), X.readonly = () => Rq(X), X.describe = ($) => {
    let Y = X.clone();
    return y1.add(Y, { description: $ }), Y;
  }, Object.defineProperty(X, "description", { get() {
    var _a;
    return (_a = y1.get(X)) == null ? void 0 : _a.description;
  }, configurable: true }), X.meta = (...$) => {
    if ($.length === 0) return y1.get(X);
    let Y = X.clone();
    return y1.add(Y, $[0]), Y;
  }, X.isOptional = () => X.safeParse(void 0).success, X.isNullable = () => X.safeParse(null).success, X;
});
var iJ = O("_ZodString", (X, Q) => {
  var _a, _b, _c;
  IX.init(X, Q), z0.init(X, Q);
  let $ = X._zod.bag;
  X.format = (_a = $.format) != null ? _a : null, X.minLength = (_b = $.minimum) != null ? _b : null, X.maxLength = (_c = $.maximum) != null ? _c : null, X.regex = (...Y) => X.check(Y$(...Y)), X.includes = (...Y) => X.check(G$(...Y)), X.startsWith = (...Y) => X.check(H$(...Y)), X.endsWith = (...Y) => X.check(B$(...Y)), X.min = (...Y) => X.check(k6(...Y)), X.max = (...Y) => X.check(u4(...Y)), X.length = (...Y) => X.check(l4(...Y)), X.nonempty = (...Y) => X.check(k6(1, ...Y)), X.lowercase = (Y) => X.check(W$(Y)), X.uppercase = (Y) => X.check(J$(Y)), X.trim = () => X.check(K$()), X.normalize = (...Y) => X.check(z$(...Y)), X.toLowerCase = () => X.check(U$()), X.toUpperCase = () => X.check(V$());
});
var gL = O("ZodString", (X, Q) => {
  IX.init(X, Q), iJ.init(X, Q), X.email = ($) => X.check(CQ(hL, $)), X.url = ($) => X.check(xQ(fL, $)), X.jwt = ($) => X.check(tQ(Xq, $)), X.emoji = ($) => X.check(yQ(uL, $)), X.guid = ($) => X.check(y4(cJ, $)), X.uuid = ($) => X.check(kQ(d4, $)), X.uuidv4 = ($) => X.check(vQ(d4, $)), X.uuidv6 = ($) => X.check(TQ(d4, $)), X.uuidv7 = ($) => X.check(_Q(d4, $)), X.nanoid = ($) => X.check(gQ(lL, $)), X.guid = ($) => X.check(y4(cJ, $)), X.cuid = ($) => X.check(hQ(mL, $)), X.cuid2 = ($) => X.check(fQ(cL, $)), X.ulid = ($) => X.check(uQ(pL, $)), X.base64 = ($) => X.check(nQ(aL, $)), X.base64url = ($) => X.check(rQ(sL, $)), X.xid = ($) => X.check(lQ(dL, $)), X.ksuid = ($) => X.check(mQ(iL, $)), X.ipv4 = ($) => X.check(cQ(nL, $)), X.ipv6 = ($) => X.check(pQ(rL, $)), X.cidrv4 = ($) => X.check(dQ(oL, $)), X.cidrv6 = ($) => X.check(iQ(tL, $)), X.e164 = ($) => X.check(oQ(eL, $)), X.datetime = ($) => X.check(D$($)), X.date = ($) => X.check(A$($)), X.time = ($) => X.check(w$($)), X.duration = ($) => X.check(M$($));
});
function D(X) {
  return ZQ(gL, X);
}
var H0 = O("ZodStringFormat", (X, Q) => {
  W0.init(X, Q), iJ.init(X, Q);
});
var hL = O("ZodEmail", (X, Q) => {
  p8.init(X, Q), H0.init(X, Q);
});
var cJ = O("ZodGUID", (X, Q) => {
  m8.init(X, Q), H0.init(X, Q);
});
var d4 = O("ZodUUID", (X, Q) => {
  c8.init(X, Q), H0.init(X, Q);
});
var fL = O("ZodURL", (X, Q) => {
  d8.init(X, Q), H0.init(X, Q);
});
var uL = O("ZodEmoji", (X, Q) => {
  i8.init(X, Q), H0.init(X, Q);
});
var lL = O("ZodNanoID", (X, Q) => {
  n8.init(X, Q), H0.init(X, Q);
});
var mL = O("ZodCUID", (X, Q) => {
  r8.init(X, Q), H0.init(X, Q);
});
var cL = O("ZodCUID2", (X, Q) => {
  o8.init(X, Q), H0.init(X, Q);
});
var pL = O("ZodULID", (X, Q) => {
  t8.init(X, Q), H0.init(X, Q);
});
var dL = O("ZodXID", (X, Q) => {
  a8.init(X, Q), H0.init(X, Q);
});
var iL = O("ZodKSUID", (X, Q) => {
  s8.init(X, Q), H0.init(X, Q);
});
var nL = O("ZodIPv4", (X, Q) => {
  e8.init(X, Q), H0.init(X, Q);
});
var rL = O("ZodIPv6", (X, Q) => {
  XQ.init(X, Q), H0.init(X, Q);
});
var oL = O("ZodCIDRv4", (X, Q) => {
  QQ.init(X, Q), H0.init(X, Q);
});
var tL = O("ZodCIDRv6", (X, Q) => {
  $Q.init(X, Q), H0.init(X, Q);
});
var aL = O("ZodBase64", (X, Q) => {
  YQ.init(X, Q), H0.init(X, Q);
});
var sL = O("ZodBase64URL", (X, Q) => {
  WQ.init(X, Q), H0.init(X, Q);
});
var eL = O("ZodE164", (X, Q) => {
  JQ.init(X, Q), H0.init(X, Q);
});
var Xq = O("ZodJWT", (X, Q) => {
  GQ.init(X, Q), H0.init(X, Q);
});
var nJ = O("ZodNumber", (X, Q) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i;
  v4.init(X, Q), z0.init(X, Q), X.gt = (Y, W) => X.check(h4(Y, W)), X.gte = (Y, W) => X.check(PX(Y, W)), X.min = (Y, W) => X.check(PX(Y, W)), X.lt = (Y, W) => X.check(g4(Y, W)), X.lte = (Y, W) => X.check(bX(Y, W)), X.max = (Y, W) => X.check(bX(Y, W)), X.int = (Y) => X.check(pJ(Y)), X.safe = (Y) => X.check(pJ(Y)), X.positive = (Y) => X.check(h4(0, Y)), X.nonnegative = (Y) => X.check(PX(0, Y)), X.negative = (Y) => X.check(g4(0, Y)), X.nonpositive = (Y) => X.check(bX(0, Y)), X.multipleOf = (Y, W) => X.check(f4(Y, W)), X.step = (Y, W) => X.check(f4(Y, W)), X.finite = () => X;
  let $ = X._zod.bag;
  X.minValue = (_c = Math.max((_a = $.minimum) != null ? _a : Number.NEGATIVE_INFINITY, (_b = $.exclusiveMinimum) != null ? _b : Number.NEGATIVE_INFINITY)) != null ? _c : null, X.maxValue = (_f = Math.min((_d = $.maximum) != null ? _d : Number.POSITIVE_INFINITY, (_e = $.exclusiveMaximum) != null ? _e : Number.POSITIVE_INFINITY)) != null ? _f : null, X.isInt = ((_g = $.format) != null ? _g : "").includes("int") || Number.isSafeInteger((_h = $.multipleOf) != null ? _h : 0.5), X.isFinite = true, X.format = (_i = $.format) != null ? _i : null;
});
function Q0(X) {
  return aQ(nJ, X);
}
var Qq = O("ZodNumberFormat", (X, Q) => {
  HQ.init(X, Q), nJ.init(X, Q);
});
function pJ(X) {
  return sQ(Qq, X);
}
var $q = O("ZodBoolean", (X, Q) => {
  BQ.init(X, Q), z0.init(X, Q);
});
function M0(X) {
  return eQ($q, X);
}
var Yq = O("ZodNull", (X, Q) => {
  zQ.init(X, Q), z0.init(X, Q);
});
function E$(X) {
  return X$(Yq, X);
}
var Wq = O("ZodUnknown", (X, Q) => {
  KQ.init(X, Q), z0.init(X, Q);
});
function N0() {
  return Q$(Wq);
}
var Jq = O("ZodNever", (X, Q) => {
  UQ.init(X, Q), z0.init(X, Q);
});
function Gq(X) {
  return $$(Jq, X);
}
var Hq = O("ZodArray", (X, Q) => {
  VQ.init(X, Q), z0.init(X, Q), X.element = Q.element, X.min = ($, Y) => X.check(k6($, Y)), X.nonempty = ($) => X.check(k6(1, $)), X.max = ($, Y) => X.check(u4($, Y)), X.length = ($, Y) => X.check(l4($, Y)), X.unwrap = () => X.element;
});
function r(X, Q) {
  return CJ(Hq, X, Q);
}
var rJ = O("ZodObject", (X, Q) => {
  T4.init(X, Q), z0.init(X, Q), i.defineLazy(X, "shape", () => Q.shape), X.keyof = () => j0(Object.keys(X._zod.def.shape)), X.catchall = ($) => X.clone({ ...X._zod.def, catchall: $ }), X.passthrough = () => X.clone({ ...X._zod.def, catchall: N0() }), X.loose = () => X.clone({ ...X._zod.def, catchall: N0() }), X.strict = () => X.clone({ ...X._zod.def, catchall: Gq() }), X.strip = () => X.clone({ ...X._zod.def, catchall: void 0 }), X.extend = ($) => {
    return i.extend(X, $);
  }, X.merge = ($) => i.merge(X, $), X.pick = ($) => i.pick(X, $), X.omit = ($) => i.omit(X, $), X.partial = (...$) => i.partial(aJ, X, $[0]), X.required = (...$) => i.required(sJ, X, $[0]);
});
function I(X, Q) {
  let $ = { type: "object", get shape() {
    return i.assignProp(this, "shape", { ...X }), this.shape;
  }, ...i.normalizeParams(Q) };
  return new rJ($);
}
function c0(X, Q) {
  return new rJ({ type: "object", get shape() {
    return i.assignProp(this, "shape", { ...X }), this.shape;
  }, catchall: N0(), ...i.normalizeParams(Q) });
}
var oJ = O("ZodUnion", (X, Q) => {
  _4.init(X, Q), z0.init(X, Q), X.options = Q.options;
});
function J0(X, Q) {
  return new oJ({ type: "union", options: X, ...i.normalizeParams(Q) });
}
var Bq = O("ZodDiscriminatedUnion", (X, Q) => {
  oJ.init(X, Q), LQ.init(X, Q);
});
function I$(X, Q, $) {
  return new Bq({ type: "union", options: Q, discriminator: X, ...i.normalizeParams($) });
}
var zq = O("ZodIntersection", (X, Q) => {
  qQ.init(X, Q), z0.init(X, Q);
});
function i4(X, Q) {
  return new zq({ type: "intersection", left: X, right: Q });
}
var Kq = O("ZodRecord", (X, Q) => {
  FQ.init(X, Q), z0.init(X, Q), X.keyType = Q.keyType, X.valueType = Q.valueType;
});
function O0(X, Q, $) {
  return new Kq({ type: "record", keyType: X, valueType: Q, ...i.normalizeParams($) });
}
var j$ = O("ZodEnum", (X, Q) => {
  NQ.init(X, Q), z0.init(X, Q), X.enum = Q.entries, X.options = Object.values(Q.entries);
  let $ = new Set(Object.keys(Q.entries));
  X.extract = (Y, W) => {
    let J = {};
    for (let G of Y) if ($.has(G)) J[G] = Q.entries[G];
    else throw Error(`Key ${G} not found in enum`);
    return new j$({ ...Q, checks: [], ...i.normalizeParams(W), entries: J });
  }, X.exclude = (Y, W) => {
    let J = { ...Q.entries };
    for (let G of Y) if ($.has(G)) delete J[G];
    else throw Error(`Key ${G} not found in enum`);
    return new j$({ ...Q, checks: [], ...i.normalizeParams(W), entries: J });
  };
});
function j0(X, Q) {
  let $ = Array.isArray(X) ? Object.fromEntries(X.map((Y) => [Y, Y])) : X;
  return new j$({ type: "enum", entries: $, ...i.normalizeParams(Q) });
}
var Uq = O("ZodLiteral", (X, Q) => {
  OQ.init(X, Q), z0.init(X, Q), X.values = new Set(Q.values), Object.defineProperty(X, "value", { get() {
    if (Q.values.length > 1) throw Error("This schema contains multiple valid literal values. Use `.values` instead.");
    return Q.values[0];
  } });
});
function T(X, Q) {
  return new Uq({ type: "literal", values: Array.isArray(X) ? X : [X], ...i.normalizeParams(Q) });
}
var Vq = O("ZodTransform", (X, Q) => {
  DQ.init(X, Q), z0.init(X, Q), X._zod.parse = ($, Y) => {
    $.addIssue = (J) => {
      var _a, _b, _c, _d;
      if (typeof J === "string") $.issues.push(i.issue(J, $.value, Q));
      else {
        let G = J;
        if (G.fatal) G.continue = false;
        (_a = G.code) != null ? _a : G.code = "custom", (_b = G.input) != null ? _b : G.input = $.value, (_c = G.inst) != null ? _c : G.inst = X, (_d = G.continue) != null ? _d : G.continue = true, $.issues.push(i.issue(G));
      }
    };
    let W = Q.transform($.value, $);
    if (W instanceof Promise) return W.then((J) => {
      return $.value = J, $;
    });
    return $.value = W, $;
  };
});
function tJ(X) {
  return new Vq({ type: "transform", transform: X });
}
var aJ = O("ZodOptional", (X, Q) => {
  AQ.init(X, Q), z0.init(X, Q), X.unwrap = () => X._zod.def.innerType;
});
function v(X) {
  return new aJ({ type: "optional", innerType: X });
}
var Lq = O("ZodNullable", (X, Q) => {
  wQ.init(X, Q), z0.init(X, Q), X.unwrap = () => X._zod.def.innerType;
});
function dJ(X) {
  return new Lq({ type: "nullable", innerType: X });
}
var qq = O("ZodDefault", (X, Q) => {
  MQ.init(X, Q), z0.init(X, Q), X.unwrap = () => X._zod.def.innerType, X.removeDefault = X.unwrap;
});
function Fq(X, Q) {
  return new qq({ type: "default", innerType: X, get defaultValue() {
    return typeof Q === "function" ? Q() : Q;
  } });
}
var Nq = O("ZodPrefault", (X, Q) => {
  jQ.init(X, Q), z0.init(X, Q), X.unwrap = () => X._zod.def.innerType;
});
function Oq(X, Q) {
  return new Nq({ type: "prefault", innerType: X, get defaultValue() {
    return typeof Q === "function" ? Q() : Q;
  } });
}
var sJ = O("ZodNonOptional", (X, Q) => {
  RQ.init(X, Q), z0.init(X, Q), X.unwrap = () => X._zod.def.innerType;
});
function Dq(X, Q) {
  return new sJ({ type: "nonoptional", innerType: X, ...i.normalizeParams(Q) });
}
var Aq = O("ZodCatch", (X, Q) => {
  EQ.init(X, Q), z0.init(X, Q), X.unwrap = () => X._zod.def.innerType, X.removeCatch = X.unwrap;
});
function wq(X, Q) {
  return new Aq({ type: "catch", innerType: X, catchValue: typeof Q === "function" ? Q : () => Q });
}
var Mq = O("ZodPipe", (X, Q) => {
  IQ.init(X, Q), z0.init(X, Q), X.in = Q.in, X.out = Q.out;
});
function R$(X, Q) {
  return new Mq({ type: "pipe", in: X, out: Q });
}
var jq = O("ZodReadonly", (X, Q) => {
  bQ.init(X, Q), z0.init(X, Q);
});
function Rq(X) {
  return new jq({ type: "readonly", innerType: X });
}
var eJ = O("ZodCustom", (X, Q) => {
  PQ.init(X, Q), z0.init(X, Q);
});
function Eq(X, Q) {
  let $ = new w0({ check: "custom", ...i.normalizeParams(Q) });
  return $._zod.check = X, $;
}
function X5(X, Q) {
  return L$(eJ, X != null ? X : (() => true), Q);
}
function Iq(X, Q = {}) {
  return q$(eJ, X, Q);
}
function bq(X, Q) {
  let $ = Eq((Y) => {
    return Y.addIssue = (W) => {
      var _a, _b, _c, _d;
      if (typeof W === "string") Y.issues.push(i.issue(W, Y.value, $._zod.def));
      else {
        let J = W;
        if (J.fatal) J.continue = false;
        (_a = J.code) != null ? _a : J.code = "custom", (_b = J.input) != null ? _b : J.input = Y.value, (_c = J.inst) != null ? _c : J.inst = $, (_d = J.continue) != null ? _d : J.continue = !$._zod.def.abort, Y.issues.push(i.issue(J));
      }
    }, X(Y.value, Y);
  }, Q);
  return $;
}
function b$(X, Q) {
  return R$(tJ(X), Q);
}
u0(SQ());
var K1 = "io.modelcontextprotocol/related-task";
var r4 = "2.0";
var z1 = X5((X) => X !== null && (typeof X === "object" || typeof X === "function"));
var $5 = J0([D(), Q0().int()]);
var Y5 = D();
var Pq = c0({ ttl: J0([Q0(), E$()]).optional(), pollInterval: Q0().optional() });
var S$ = c0({ taskId: D() });
var Sq = c0({ progressToken: $5.optional(), [K1]: S$.optional() });
var _0 = c0({ task: Pq.optional(), _meta: Sq.optional() });
var R0 = I({ method: D(), params: _0.optional() });
var W6 = c0({ _meta: I({ [K1]: v(S$) }).passthrough().optional() });
var p0 = I({ method: D(), params: W6.optional() });
var b0 = c0({ _meta: c0({ [K1]: S$.optional() }).optional() });
var o4 = J0([D(), Q0().int()]);
var W5 = I({ jsonrpc: T(r4), id: o4, ...R0.shape }).strict();
var J5 = I({ jsonrpc: T(r4), ...p0.shape }).strict();
var H5 = I({ jsonrpc: T(r4), id: o4, result: b0 }).strict();
var x;
(function(X) {
  X[X.ConnectionClosed = -32e3] = "ConnectionClosed", X[X.RequestTimeout = -32001] = "RequestTimeout", X[X.ParseError = -32700] = "ParseError", X[X.InvalidRequest = -32600] = "InvalidRequest", X[X.MethodNotFound = -32601] = "MethodNotFound", X[X.InvalidParams = -32602] = "InvalidParams", X[X.InternalError = -32603] = "InternalError", X[X.UrlElicitationRequired = -32042] = "UrlElicitationRequired";
})(x || (x = {}));
var B5 = I({ jsonrpc: T(r4), id: o4, error: I({ code: Q0().int(), message: D(), data: v(N0()) }) }).strict();
var zZ = J0([W5, J5, H5, B5]);
var t4 = b0.strict();
var Zq = W6.extend({ requestId: o4, reason: D().optional() });
var a4 = p0.extend({ method: T("notifications/cancelled"), params: Zq });
var Cq = I({ src: D(), mimeType: D().optional(), sizes: r(D()).optional() });
var kX = I({ icons: r(Cq).optional() });
var _6 = I({ name: D(), title: D().optional() });
var K5 = _6.extend({ ..._6.shape, ...kX.shape, version: D(), websiteUrl: D().optional() });
var kq = i4(I({ applyDefaults: M0().optional() }), O0(D(), N0()));
var vq = b$((X) => {
  if (X && typeof X === "object" && !Array.isArray(X)) {
    if (Object.keys(X).length === 0) return { form: {} };
  }
  return X;
}, i4(I({ form: kq.optional(), url: z1.optional() }), O0(D(), N0()).optional()));
var Tq = I({ list: v(I({}).passthrough()), cancel: v(I({}).passthrough()), requests: v(I({ sampling: v(I({ createMessage: v(I({}).passthrough()) }).passthrough()), elicitation: v(I({ create: v(I({}).passthrough()) }).passthrough()) }).passthrough()) }).passthrough();
var _q = I({ list: v(I({}).passthrough()), cancel: v(I({}).passthrough()), requests: v(I({ tools: v(I({ call: v(I({}).passthrough()) }).passthrough()) }).passthrough()) }).passthrough();
var xq = I({ experimental: O0(D(), z1).optional(), sampling: I({ context: z1.optional(), tools: z1.optional() }).optional(), elicitation: vq.optional(), roots: I({ listChanged: M0().optional() }).optional(), tasks: v(Tq) });
var yq = _0.extend({ protocolVersion: D(), capabilities: xq, clientInfo: K5 });
var C$ = R0.extend({ method: T("initialize"), params: yq });
var gq = I({ experimental: O0(D(), z1).optional(), logging: z1.optional(), completions: z1.optional(), prompts: v(I({ listChanged: v(M0()) })), resources: I({ subscribe: M0().optional(), listChanged: M0().optional() }).optional(), tools: I({ listChanged: M0().optional() }).optional(), tasks: v(_q) }).passthrough();
var hq = b0.extend({ protocolVersion: D(), capabilities: gq, serverInfo: K5, instructions: D().optional() });
var k$ = p0.extend({ method: T("notifications/initialized") });
var s4 = R0.extend({ method: T("ping") });
var fq = I({ progress: Q0(), total: v(Q0()), message: v(D()) });
var uq = I({ ...W6.shape, ...fq.shape, progressToken: $5 });
var e4 = p0.extend({ method: T("notifications/progress"), params: uq });
var lq = _0.extend({ cursor: Y5.optional() });
var vX = R0.extend({ params: lq.optional() });
var TX = b0.extend({ nextCursor: v(Y5) });
var _X = I({ taskId: D(), status: j0(["working", "input_required", "completed", "failed", "cancelled"]), ttl: J0([Q0(), E$()]), createdAt: D(), lastUpdatedAt: D(), pollInterval: v(Q0()), statusMessage: v(D()) });
var x6 = b0.extend({ task: _X });
var mq = W6.merge(_X);
var xX = p0.extend({ method: T("notifications/tasks/status"), params: mq });
var X9 = R0.extend({ method: T("tasks/get"), params: _0.extend({ taskId: D() }) });
var Q9 = b0.merge(_X);
var $9 = R0.extend({ method: T("tasks/result"), params: _0.extend({ taskId: D() }) });
var Y9 = vX.extend({ method: T("tasks/list") });
var W9 = TX.extend({ tasks: r(_X) });
var U5 = R0.extend({ method: T("tasks/cancel"), params: _0.extend({ taskId: D() }) });
var V5 = b0.merge(_X);
var L5 = I({ uri: D(), mimeType: v(D()), _meta: O0(D(), N0()).optional() });
var q5 = L5.extend({ text: D() });
var v$ = D().refine((X) => {
  try {
    return atob(X), true;
  } catch (Q) {
    return false;
  }
}, { message: "Invalid Base64 string" });
var F5 = L5.extend({ blob: v$ });
var y6 = I({ audience: r(j0(["user", "assistant"])).optional(), priority: Q0().min(0).max(1).optional(), lastModified: SX.datetime({ offset: true }).optional() });
var N5 = I({ ..._6.shape, ...kX.shape, uri: D(), description: v(D()), mimeType: v(D()), annotations: y6.optional(), _meta: v(c0({})) });
var cq = I({ ..._6.shape, ...kX.shape, uriTemplate: D(), description: v(D()), mimeType: v(D()), annotations: y6.optional(), _meta: v(c0({})) });
var J9 = vX.extend({ method: T("resources/list") });
var pq = TX.extend({ resources: r(N5) });
var G9 = vX.extend({ method: T("resources/templates/list") });
var dq = TX.extend({ resourceTemplates: r(cq) });
var T$ = _0.extend({ uri: D() });
var iq = T$;
var H9 = R0.extend({ method: T("resources/read"), params: iq });
var nq = b0.extend({ contents: r(J0([q5, F5])) });
var rq = p0.extend({ method: T("notifications/resources/list_changed") });
var oq = T$;
var tq = R0.extend({ method: T("resources/subscribe"), params: oq });
var aq = T$;
var sq = R0.extend({ method: T("resources/unsubscribe"), params: aq });
var eq = W6.extend({ uri: D() });
var XF = p0.extend({ method: T("notifications/resources/updated"), params: eq });
var QF = I({ name: D(), description: v(D()), required: v(M0()) });
var $F = I({ ..._6.shape, ...kX.shape, description: v(D()), arguments: v(r(QF)), _meta: v(c0({})) });
var B9 = vX.extend({ method: T("prompts/list") });
var YF = TX.extend({ prompts: r($F) });
var WF = _0.extend({ name: D(), arguments: O0(D(), D()).optional() });
var z9 = R0.extend({ method: T("prompts/get"), params: WF });
var _$ = I({ type: T("text"), text: D(), annotations: y6.optional(), _meta: O0(D(), N0()).optional() });
var x$ = I({ type: T("image"), data: v$, mimeType: D(), annotations: y6.optional(), _meta: O0(D(), N0()).optional() });
var y$ = I({ type: T("audio"), data: v$, mimeType: D(), annotations: y6.optional(), _meta: O0(D(), N0()).optional() });
var JF = I({ type: T("tool_use"), name: D(), id: D(), input: I({}).passthrough(), _meta: v(I({}).passthrough()) }).passthrough();
var GF = I({ type: T("resource"), resource: J0([q5, F5]), annotations: y6.optional(), _meta: O0(D(), N0()).optional() });
var HF = N5.extend({ type: T("resource_link") });
var g$ = J0([_$, x$, y$, HF, GF]);
var BF = I({ role: j0(["user", "assistant"]), content: g$ });
var zF = b0.extend({ description: v(D()), messages: r(BF) });
var KF = p0.extend({ method: T("notifications/prompts/list_changed") });
var UF = I({ title: D().optional(), readOnlyHint: M0().optional(), destructiveHint: M0().optional(), idempotentHint: M0().optional(), openWorldHint: M0().optional() });
var VF = I({ taskSupport: j0(["required", "optional", "forbidden"]).optional() });
var O5 = I({ ..._6.shape, ...kX.shape, description: D().optional(), inputSchema: I({ type: T("object"), properties: O0(D(), z1).optional(), required: r(D()).optional() }).catchall(N0()), outputSchema: I({ type: T("object"), properties: O0(D(), z1).optional(), required: r(D()).optional() }).catchall(N0()).optional(), annotations: v(UF), execution: v(VF), _meta: O0(D(), N0()).optional() });
var K9 = vX.extend({ method: T("tools/list") });
var LF = TX.extend({ tools: r(O5) });
var U9 = b0.extend({ content: r(g$).default([]), structuredContent: O0(D(), N0()).optional(), isError: v(M0()) });
var KZ = U9.or(b0.extend({ toolResult: N0() }));
var qF = _0.extend({ name: D(), arguments: v(O0(D(), N0())) });
var g6 = R0.extend({ method: T("tools/call"), params: qF });
var FF = p0.extend({ method: T("notifications/tools/list_changed") });
var yX = j0(["debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"]);
var NF = _0.extend({ level: yX });
var h$ = R0.extend({ method: T("logging/setLevel"), params: NF });
var OF = W6.extend({ level: yX, logger: D().optional(), data: N0() });
var DF = p0.extend({ method: T("notifications/message"), params: OF });
var AF = I({ name: D().optional() });
var wF = I({ hints: v(r(AF)), costPriority: v(Q0().min(0).max(1)), speedPriority: v(Q0().min(0).max(1)), intelligencePriority: v(Q0().min(0).max(1)) });
var MF = I({ mode: v(j0(["auto", "required", "none"])) });
var jF = I({ type: T("tool_result"), toolUseId: D().describe("The unique identifier for the corresponding tool call."), content: r(g$).default([]), structuredContent: I({}).passthrough().optional(), isError: v(M0()), _meta: v(I({}).passthrough()) }).passthrough();
var RF = I$("type", [_$, x$, y$]);
var n4 = I$("type", [_$, x$, y$, JF, jF]);
var EF = I({ role: j0(["user", "assistant"]), content: J0([n4, r(n4)]), _meta: v(I({}).passthrough()) }).passthrough();
var IF = _0.extend({ messages: r(EF), modelPreferences: wF.optional(), systemPrompt: D().optional(), includeContext: j0(["none", "thisServer", "allServers"]).optional(), temperature: Q0().optional(), maxTokens: Q0().int(), stopSequences: r(D()).optional(), metadata: z1.optional(), tools: v(r(O5)), toolChoice: v(MF) });
var bF = R0.extend({ method: T("sampling/createMessage"), params: IF });
var f$ = b0.extend({ model: D(), stopReason: v(j0(["endTurn", "stopSequence", "maxTokens"]).or(D())), role: j0(["user", "assistant"]), content: RF });
var u$ = b0.extend({ model: D(), stopReason: v(j0(["endTurn", "stopSequence", "maxTokens", "toolUse"]).or(D())), role: j0(["user", "assistant"]), content: J0([n4, r(n4)]) });
var PF = I({ type: T("boolean"), title: D().optional(), description: D().optional(), default: M0().optional() });
var SF = I({ type: T("string"), title: D().optional(), description: D().optional(), minLength: Q0().optional(), maxLength: Q0().optional(), format: j0(["email", "uri", "date", "date-time"]).optional(), default: D().optional() });
var ZF = I({ type: j0(["number", "integer"]), title: D().optional(), description: D().optional(), minimum: Q0().optional(), maximum: Q0().optional(), default: Q0().optional() });
var CF = I({ type: T("string"), title: D().optional(), description: D().optional(), enum: r(D()), default: D().optional() });
var kF = I({ type: T("string"), title: D().optional(), description: D().optional(), oneOf: r(I({ const: D(), title: D() })), default: D().optional() });
var vF = I({ type: T("string"), title: D().optional(), description: D().optional(), enum: r(D()), enumNames: r(D()).optional(), default: D().optional() });
var TF = J0([CF, kF]);
var _F = I({ type: T("array"), title: D().optional(), description: D().optional(), minItems: Q0().optional(), maxItems: Q0().optional(), items: I({ type: T("string"), enum: r(D()) }), default: r(D()).optional() });
var xF = I({ type: T("array"), title: D().optional(), description: D().optional(), minItems: Q0().optional(), maxItems: Q0().optional(), items: I({ anyOf: r(I({ const: D(), title: D() })) }), default: r(D()).optional() });
var yF = J0([_F, xF]);
var gF = J0([vF, TF, yF]);
var hF = J0([gF, PF, SF, ZF]);
var fF = _0.extend({ mode: T("form").optional(), message: D(), requestedSchema: I({ type: T("object"), properties: O0(D(), hF), required: r(D()).optional() }) });
var uF = _0.extend({ mode: T("url"), message: D(), elicitationId: D(), url: D().url() });
var lF = J0([fF, uF]);
var mF = R0.extend({ method: T("elicitation/create"), params: lF });
var cF = W6.extend({ elicitationId: D() });
var pF = p0.extend({ method: T("notifications/elicitation/complete"), params: cF });
var V9 = b0.extend({ action: j0(["accept", "decline", "cancel"]), content: b$((X) => X === null ? void 0 : X, O0(D(), J0([D(), Q0(), M0(), r(D())])).optional()) });
var dF = I({ type: T("ref/resource"), uri: D() });
var iF = I({ type: T("ref/prompt"), name: D() });
var nF = _0.extend({ ref: J0([iF, dF]), argument: I({ name: D(), value: D() }), context: I({ arguments: O0(D(), D()).optional() }).optional() });
var L9 = R0.extend({ method: T("completion/complete"), params: nF });
var rF = b0.extend({ completion: c0({ values: r(D()).max(100), total: v(Q0().int()), hasMore: v(M0()) }) });
var oF = I({ uri: D().startsWith("file://"), name: D().optional(), _meta: O0(D(), N0()).optional() });
var tF = R0.extend({ method: T("roots/list") });
var l$ = b0.extend({ roots: r(oF) });
var aF = p0.extend({ method: T("notifications/roots/list_changed") });
var UZ = J0([s4, C$, L9, h$, z9, B9, J9, G9, H9, tq, sq, g6, K9, X9, $9, Y9]);
var VZ = J0([a4, e4, k$, aF, xX]);
var LZ = J0([t4, f$, u$, V9, l$, Q9, W9, x6]);
var qZ = J0([s4, bF, mF, tF, X9, $9, Y9]);
var FZ = J0([a4, e4, DF, XF, rq, FF, KF, xX, pF]);
var NZ = J0([t4, hq, rF, zF, YF, pq, dq, nq, U9, LF, Q9, W9, x6]);
var XN = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
var gz = K7(cY(), 1);
var hz = K7(yz(), 1);
var lz;
(function(X) {
  X.Completable = "McpCompletable";
})(lz || (lz = {}));
function u_({ prompt: X, options: Q }) {
  let { systemPrompt: $, settingSources: Y, sandbox: W, ...J } = Q != null ? Q : {}, G, H;
  if ($ === void 0) G = "";
  else if (typeof $ === "string") G = $;
  else if ($.type === "preset") H = $.append;
  let B = J.pathToClaudeCodeExecutable;
  if (!B) {
    let q6 = (0, import_url.fileURLToPath)(import_meta.url), F6 = (0, import_path3.join)(q6, "..");
    B = (0, import_path3.join)(F6, "cli.js");
  }
  process.env.CLAUDE_AGENT_SDK_VERSION = "0.2.17";
  let { abortController: z = N6(), additionalDirectories: K = [], agent: V, agents: L, allowedTools: U = [], betas: F, canUseTool: q, continue: N, cwd: A, disallowedTools: M = [], tools: R, env: S, executable: C = j6() ? "bun" : "node", executableArgs: K0 = [], extraArgs: U0 = {}, fallbackModel: s, enableFileCheckpointing: D0, forkSession: q0, hooks: W1, includePartialMessages: P1, persistSession: U6, maxThinkingTokens: d, maxTurns: Q8, maxBudgetUsd: o6, mcpServers: V6, model: t6, outputFormat: a6, permissionMode: B4 = "default", allowDangerouslySkipPermissions: S0 = false, permissionPromptToolName: S1, plugins: s6, resume: oz, resumeSessionAt: tz, stderr: az, strictMcpConfig: sz } = J, G7 = (a6 == null ? void 0 : a6.type) === "json_schema" ? a6.schema : void 0, L6 = S;
  if (!L6) L6 = { ...process.env };
  if (!L6.CLAUDE_CODE_ENTRYPOINT) L6.CLAUDE_CODE_ENTRYPOINT = "sdk-ts";
  if (D0) L6.CLAUDE_CODE_ENABLE_SDK_FILE_CHECKPOINTING = "true";
  if (!B) throw Error("pathToClaudeCodeExecutable is required");
  let $8 = {}, H7 = /* @__PURE__ */ new Map();
  if (V6) for (let [q6, F6] of Object.entries(V6)) if (F6.type === "sdk" && "instance" in F6) H7.set(q6, F6.instance), $8[q6] = { type: "sdk", name: q6 };
  else $8[q6] = F6;
  let ez = typeof X === "string", B7 = new XX({ abortController: z, additionalDirectories: K, agent: V, betas: F, cwd: A, executable: C, executableArgs: K0, extraArgs: U0, pathToClaudeCodeExecutable: B, env: L6, forkSession: q0, stderr: az, maxThinkingTokens: d, maxTurns: Q8, maxBudgetUsd: o6, model: t6, fallbackModel: s, jsonSchema: G7, permissionMode: B4, allowDangerouslySkipPermissions: S0, permissionPromptToolName: S1, continueConversation: N, resume: oz, resumeSessionAt: tz, settingSources: Y != null ? Y : [], allowedTools: U, disallowedTools: M, tools: R, mcpServers: $8, strictMcpConfig: sz, canUseTool: !!q, hooks: !!W1, includePartialMessages: P1, persistSession: U6, plugins: s6, sandbox: W, spawnClaudeCodeProcess: J.spawnClaudeCodeProcess }), z7 = new $X(B7, ez, q, W1, z, H7, G7, { systemPrompt: G, appendSystemPrompt: H, agents: L });
  if (typeof X === "string") B7.write(Z0({ type: "user", session_id: "", message: { role: "user", content: [{ type: "text", text: X }] }, parent_tool_use_id: null }) + `
`);
  else z7.streamInput(X);
  return z7;
}

// src/core/agent/ClaudianService.ts
var import_obsidian3 = require("obsidian");

// src/utils/context.ts
var CURRENT_NOTE_PREFIX_REGEX = /^<current_note>\n[\s\S]*?<\/current_note>\n\n/;
var CURRENT_NOTE_SUFFIX_REGEX = /\n\n<current_note>\n[\s\S]*?<\/current_note>$/;
var XML_CONTEXT_PATTERN = /\n\n<(?:current_note|editor_selection|editor_cursor|context_files)[\s>]/;
function formatCurrentNote(notePath) {
  return `<current_note>
${notePath}
</current_note>`;
}
function appendCurrentNote(prompt, notePath) {
  return `${prompt}

${formatCurrentNote(notePath)}`;
}
function stripCurrentNoteContext(prompt) {
  const strippedPrefix = prompt.replace(CURRENT_NOTE_PREFIX_REGEX, "");
  if (strippedPrefix !== prompt) {
    return strippedPrefix;
  }
  return prompt.replace(CURRENT_NOTE_SUFFIX_REGEX, "");
}
function extractContentBeforeXmlContext(text) {
  if (!text) return void 0;
  const queryMatch = text.match(/<query>\n?([\s\S]*?)\n?<\/query>/);
  if (queryMatch) {
    return queryMatch[1].trim();
  }
  const xmlMatch = text.match(XML_CONTEXT_PATTERN);
  if ((xmlMatch == null ? void 0 : xmlMatch.index) !== void 0) {
    return text.substring(0, xmlMatch.index).trim();
  }
  return void 0;
}
function extractUserQuery(prompt) {
  if (!prompt) return "";
  const extracted = extractContentBeforeXmlContext(prompt);
  if (extracted !== void 0) {
    return extracted;
  }
  return prompt.replace(/<current_note>[\s\S]*?<\/current_note>\s*/g, "").replace(/<editor_selection[\s\S]*?<\/editor_selection>\s*/g, "").replace(/<editor_cursor[\s\S]*?<\/editor_cursor>\s*/g, "").replace(/<context_files>[\s\S]*?<\/context_files>\s*/g, "").trim();
}
function formatContextFilesLine(files) {
  return `<context_files>
${files.join(", ")}
</context_files>`;
}
function appendContextFiles(prompt, files) {
  return `${prompt}

${formatContextFilesLine(files)}`;
}

// src/utils/session.ts
var SESSION_ERROR_PATTERNS = [
  "session expired",
  "session not found",
  "invalid session",
  "session invalid",
  "process exited with code"
];
var SESSION_ERROR_COMPOUND_PATTERNS = [
  { includes: ["session", "expired"] },
  { includes: ["resume", "failed"] },
  { includes: ["resume", "error"] }
];
function isSessionExpiredError(error) {
  const msg = error instanceof Error ? error.message.toLowerCase() : "";
  for (const pattern of SESSION_ERROR_PATTERNS) {
    if (msg.includes(pattern)) {
      return true;
    }
  }
  for (const { includes } of SESSION_ERROR_COMPOUND_PATTERNS) {
    if (includes.every((part) => msg.includes(part))) {
      return true;
    }
  }
  return false;
}
function formatToolInput(input, maxLength = 200) {
  if (!input || Object.keys(input).length === 0) return "";
  try {
    const parts = [];
    for (const [key, value] of Object.entries(input)) {
      if (value === void 0 || value === null) continue;
      let valueStr;
      if (typeof value === "string") {
        valueStr = value.length > 100 ? `${value.slice(0, 100)}...` : value;
      } else if (typeof value === "object") {
        valueStr = "[object]";
      } else {
        valueStr = String(value);
      }
      parts.push(`${key}=${valueStr}`);
    }
    const result = parts.join(", ");
    return result.length > maxLength ? `${result.slice(0, maxLength)}...` : result;
  } catch (e2) {
    return "[input formatting error]";
  }
}
function formatToolCallForContext(toolCall, maxErrorLength = 500) {
  var _a;
  const status = (_a = toolCall.status) != null ? _a : "completed";
  const isFailed = status === "error" || status === "blocked";
  const inputStr = formatToolInput(toolCall.input);
  const inputPart = inputStr ? ` input: ${inputStr}` : "";
  if (!isFailed) {
    return `[Tool ${toolCall.name}${inputPart} status=${status}]`;
  }
  const hasResult = typeof toolCall.result === "string" && toolCall.result.trim().length > 0;
  if (!hasResult) {
    return `[Tool ${toolCall.name}${inputPart} status=${status}]`;
  }
  const errorMsg = truncateToolResult(toolCall.result, maxErrorLength);
  return `[Tool ${toolCall.name}${inputPart} status=${status}] error: ${errorMsg}`;
}
function truncateToolResult(result, maxLength = 500) {
  if (result.length > maxLength) {
    return `${result.slice(0, maxLength)}... (truncated)`;
  }
  return result;
}
function formatContextLine(message) {
  if (!message.currentNote) {
    return null;
  }
  return formatCurrentNote(message.currentNote);
}
function formatThinkingBlocks(message) {
  if (!message.contentBlocks) return [];
  const thinkingBlocks = message.contentBlocks.filter(
    (block) => block.type === "thinking"
  );
  if (thinkingBlocks.length === 0) return [];
  const totalDuration = thinkingBlocks.reduce(
    (sum, block) => {
      var _a;
      return sum + ((_a = block.durationSeconds) != null ? _a : 0);
    },
    0
  );
  const durationPart = totalDuration > 0 ? `, ${totalDuration.toFixed(1)}s total` : "";
  return [`[Thinking: ${thinkingBlocks.length} block(s)${durationPart}]`];
}
function buildContextFromHistory(messages) {
  var _a, _b, _c;
  const parts = [];
  for (const message of messages) {
    if (message.role !== "user" && message.role !== "assistant") {
      continue;
    }
    if (message.isInterrupt) {
      continue;
    }
    if (message.role === "assistant") {
      const hasContent = message.content && message.content.trim().length > 0;
      const hasToolCalls = message.toolCalls && message.toolCalls.length > 0;
      const hasThinking = (_a = message.contentBlocks) == null ? void 0 : _a.some((b3) => b3.type === "thinking");
      if (!hasContent && !hasToolCalls && !hasThinking) {
        continue;
      }
    }
    const role = message.role === "user" ? "User" : "Assistant";
    const lines = [];
    const content = (_b = message.content) == null ? void 0 : _b.trim();
    const contextLine = formatContextLine(message);
    const userPayload = contextLine ? content ? `${contextLine}

${content}` : contextLine : content;
    lines.push(userPayload ? `${role}: ${userPayload}` : `${role}:`);
    if (message.role === "assistant") {
      const thinkingLines = formatThinkingBlocks(message);
      if (thinkingLines.length > 0) {
        lines.push(...thinkingLines);
      }
    }
    if (message.role === "assistant" && ((_c = message.toolCalls) == null ? void 0 : _c.length)) {
      const toolLines = message.toolCalls.map((tc) => formatToolCallForContext(tc)).filter(Boolean);
      if (toolLines.length > 0) {
        lines.push(...toolLines);
      }
    }
    parts.push(lines.join("\n"));
  }
  return parts.join("\n\n");
}
function getLastUserMessage(messages) {
  for (let i2 = messages.length - 1; i2 >= 0; i2--) {
    if (messages[i2].role === "user") {
      return messages[i2];
    }
  }
  return void 0;
}
function buildPromptWithHistoryContext(historyContext, prompt, actualPrompt, conversationHistory) {
  var _a, _b;
  if (!historyContext) return prompt;
  const lastUserMessage = getLastUserMessage(conversationHistory);
  const lastUserQuery = (_b = lastUserMessage == null ? void 0 : lastUserMessage.displayContent) != null ? _b : extractUserQuery((_a = lastUserMessage == null ? void 0 : lastUserMessage.content) != null ? _a : "");
  const currentUserQuery = extractUserQuery(actualPrompt);
  const shouldAppendPrompt = !lastUserMessage || lastUserQuery.trim() !== currentUserQuery.trim();
  return shouldAppendPrompt ? `${historyContext}

User: ${prompt}` : historyContext;
}

// src/core/hooks/SecurityHooks.ts
var import_obsidian2 = require("obsidian");

// src/core/security/BashPathValidator.ts
var path5 = __toESM(require("path"));
function tokenizeBashCommand(command) {
  var _a;
  const tokens = [];
  const tokenRegex = /(['"`])(.*?)\1|[^\s]+/g;
  let match;
  while ((match = tokenRegex.exec(command)) !== null) {
    const token = (_a = match[2]) != null ? _a : match[0];
    const cleaned = token.trim();
    if (!cleaned) continue;
    tokens.push(cleaned);
  }
  return tokens;
}
function splitBashTokensIntoSegments(tokens) {
  const separators = /* @__PURE__ */ new Set(["&&", "||", ";", "|"]);
  const segments = [];
  let current = [];
  for (const token of tokens) {
    if (separators.has(token)) {
      if (current.length > 0) {
        segments.push(current);
        current = [];
      }
      continue;
    }
    current.push(token);
  }
  if (current.length > 0) {
    segments.push(current);
  }
  return segments;
}
function getBashSegmentCommandName(segment) {
  const wrappers = /* @__PURE__ */ new Set(["command", "env", "sudo"]);
  let cmdIndex = 0;
  while (cmdIndex < segment.length) {
    const token = segment[cmdIndex];
    if (wrappers.has(token)) {
      cmdIndex += 1;
      continue;
    }
    if (!token.startsWith("-") && token.includes("=")) {
      cmdIndex += 1;
      continue;
    }
    break;
  }
  const rawCmd = segment[cmdIndex] || "";
  const cmdName = path5.basename(rawCmd);
  return { cmdName, cmdIndex };
}
function isBashOutputRedirectOperator(token) {
  return token === ">" || token === ">>" || token === "1>" || token === "1>>" || token === "2>" || token === "2>>" || token === "&>" || token === "&>>" || token === ">|";
}
function isBashInputRedirectOperator(token) {
  return token === "<" || token === "<<" || token === "0<" || token === "0<<";
}
function isBashOutputOptionExpectingValue(token) {
  return token === "-o" || token === "--output" || token === "--out" || token === "--outfile" || token === "--output-file";
}
function cleanPathToken(raw) {
  let token = raw.trim();
  if (!token) return null;
  if (token.startsWith('"') && token.endsWith('"') || token.startsWith("'") && token.endsWith("'") || token.startsWith("`") && token.endsWith("`")) {
    token = token.slice(1, -1).trim();
  }
  while (token.startsWith("(") || token.startsWith("[") || token.startsWith("{")) {
    token = token.slice(1).trim();
  }
  while (token.endsWith(")") || token.endsWith("]") || token.endsWith("}") || token.endsWith(";") || token.endsWith(",")) {
    token = token.slice(0, -1).trim();
  }
  if (!token) return null;
  if (token.startsWith('"') && token.endsWith('"') || token.startsWith("'") && token.endsWith("'") || token.startsWith("`") && token.endsWith("`")) {
    token = token.slice(1, -1).trim();
  }
  if (!token) return null;
  if (token === "." || token === "/" || token === "\\" || token === "--") return null;
  return token;
}
function isPathLikeToken(token) {
  const cleaned = token.trim();
  if (!cleaned) return false;
  if (cleaned === "." || cleaned === "/" || cleaned === "\\" || cleaned === "--") return false;
  const isWindows2 = process.platform === "win32";
  return (
    // Home directory paths (Unix and Windows style)
    cleaned === "~" || cleaned.startsWith("~/") || isWindows2 && cleaned.startsWith("~\\") || // Relative paths
    cleaned.startsWith("./") || cleaned.startsWith("../") || cleaned === ".." || isWindows2 && (cleaned.startsWith(".\\") || cleaned.startsWith("..\\")) || // Absolute paths (Unix)
    cleaned.startsWith("/") || // Absolute paths (Windows drive letters)
    isWindows2 && /^[A-Za-z]:[\\/]/.test(cleaned) || // Absolute paths (Windows UNC)
    isWindows2 && (cleaned.startsWith("\\\\") || cleaned.startsWith("//")) || // Contains path separators
    cleaned.includes("/") || isWindows2 && cleaned.includes("\\")
  );
}
function checkBashPathAccess(candidate, access, context) {
  const cleaned = cleanPathToken(candidate);
  if (!cleaned) return null;
  const accessType = context.getPathAccessType(cleaned);
  if (accessType === "vault" || accessType === "readwrite") {
    return null;
  }
  if (accessType === "context") {
    return null;
  }
  if (accessType === "export") {
    return access === "write" ? null : { type: "export_path_read", path: cleaned };
  }
  return { type: "outside_vault", path: cleaned };
}
function findBashPathViolationInSegment(segment, context) {
  if (segment.length === 0) return null;
  const { cmdName, cmdIndex } = getBashSegmentCommandName(segment);
  const destinationCommands = /* @__PURE__ */ new Set(["cp", "mv", "rsync"]);
  let destinationTokenIndex = null;
  if (destinationCommands.has(cmdName)) {
    const pathArgIndices = [];
    let seenDoubleDash = false;
    for (let i2 = cmdIndex + 1; i2 < segment.length; i2 += 1) {
      const token = segment[i2];
      if (!seenDoubleDash && token === "--") {
        seenDoubleDash = true;
        continue;
      }
      if (!seenDoubleDash && token.startsWith("-")) {
        continue;
      }
      if (isPathLikeToken(token)) {
        pathArgIndices.push(i2);
      }
    }
    if (pathArgIndices.length > 0) {
      destinationTokenIndex = pathArgIndices[pathArgIndices.length - 1];
    }
  }
  let expectWriteNext = false;
  for (let i2 = 0; i2 < segment.length; i2 += 1) {
    const token = segment[i2];
    if (isBashOutputRedirectOperator(token)) {
      expectWriteNext = true;
      continue;
    }
    if (isBashInputRedirectOperator(token)) {
      expectWriteNext = false;
      continue;
    }
    if (isBashOutputOptionExpectingValue(token)) {
      expectWriteNext = true;
      continue;
    }
    const embeddedOutputRedirect = token.match(/^(?:&>>|&>|\d*>>|\d*>\||\d*>|>>|>\||>)(.+)$/);
    if (embeddedOutputRedirect) {
      const violation2 = checkBashPathAccess(embeddedOutputRedirect[1], "write", context);
      if (violation2) return violation2;
      continue;
    }
    const embeddedInputRedirect = token.match(/^(?:\d*<<|\d*<|<<|<)(.+)$/);
    if (embeddedInputRedirect) {
      const violation2 = checkBashPathAccess(embeddedInputRedirect[1], "read", context);
      if (violation2) return violation2;
      continue;
    }
    const embeddedLongOutput = token.match(/^--(?:output|out|outfile|output-file)=(.+)$/);
    if (embeddedLongOutput) {
      const violation2 = checkBashPathAccess(embeddedLongOutput[1], "write", context);
      if (violation2) return violation2;
      continue;
    }
    const embeddedShortOutput = token.match(/^-o(.+)$/);
    if (embeddedShortOutput) {
      const violation2 = checkBashPathAccess(embeddedShortOutput[1], "write", context);
      if (violation2) return violation2;
      continue;
    }
    const eqIndex = token.indexOf("=");
    if (eqIndex > 0) {
      const key = token.slice(0, eqIndex);
      const value = token.slice(eqIndex + 1);
      if (key.startsWith("-") && isPathLikeToken(value)) {
        const violation2 = checkBashPathAccess(value, "read", context);
        if (violation2) return violation2;
      }
    }
    if (!isPathLikeToken(token)) {
      expectWriteNext = false;
      continue;
    }
    const access = i2 === destinationTokenIndex || expectWriteNext ? "write" : "read";
    const violation = checkBashPathAccess(token, access, context);
    if (violation) return violation;
    expectWriteNext = false;
  }
  return null;
}
function findBashCommandPathViolation(command, context) {
  if (!command) return null;
  const tokens = tokenizeBashCommand(command);
  const segments = splitBashTokensIntoSegments(tokens);
  for (const segment of segments) {
    const violation = findBashPathViolationInSegment(segment, context);
    if (violation) {
      return violation;
    }
  }
  return null;
}

// src/core/security/BlocklistChecker.ts
function isCommandBlocked(command, patterns, enableBlocklist) {
  if (!enableBlocklist) {
    return false;
  }
  return patterns.some((pattern) => {
    try {
      return new RegExp(pattern, "i").test(command);
    } catch (e2) {
      return command.toLowerCase().includes(pattern.toLowerCase());
    }
  });
}

// src/core/tools/toolNames.ts
var TOOL_AGENT_OUTPUT = "TaskOutput";
var TOOL_BASH = "Bash";
var TOOL_BASH_OUTPUT = "BashOutput";
var TOOL_EDIT = "Edit";
var TOOL_GLOB = "Glob";
var TOOL_GREP = "Grep";
var TOOL_KILL_SHELL = "KillShell";
var TOOL_LS = "LS";
var TOOL_LIST_MCP_RESOURCES = "ListMcpResources";
var TOOL_MCP = "Mcp";
var TOOL_NOTEBOOK_EDIT = "NotebookEdit";
var TOOL_READ = "Read";
var TOOL_READ_MCP_RESOURCE = "ReadMcpResource";
var TOOL_SKILL = "Skill";
var TOOL_TASK = "Task";
var TOOL_TODO_WRITE = "TodoWrite";
var TOOL_WEB_FETCH = "WebFetch";
var TOOL_WEB_SEARCH = "WebSearch";
var TOOL_WRITE = "Write";
var EDIT_TOOLS = [TOOL_WRITE, TOOL_EDIT, TOOL_NOTEBOOK_EDIT];
var WRITE_EDIT_TOOLS = [TOOL_WRITE, TOOL_EDIT];
var FILE_TOOLS = [
  TOOL_READ,
  TOOL_WRITE,
  TOOL_EDIT,
  TOOL_GLOB,
  TOOL_GREP,
  TOOL_LS,
  TOOL_NOTEBOOK_EDIT,
  TOOL_BASH
];
var READ_ONLY_TOOLS = [
  TOOL_READ,
  TOOL_GREP,
  TOOL_GLOB,
  TOOL_LS,
  TOOL_WEB_SEARCH,
  TOOL_WEB_FETCH
];
function isEditTool(toolName) {
  return EDIT_TOOLS.includes(toolName);
}
function isWriteEditTool(toolName) {
  return WRITE_EDIT_TOOLS.includes(toolName);
}
function isFileTool(toolName) {
  return FILE_TOOLS.includes(toolName);
}
function isReadOnlyTool(toolName) {
  return READ_ONLY_TOOLS.includes(toolName);
}

// src/core/tools/toolInput.ts
function getPathFromToolInput(toolName, toolInput) {
  switch (toolName) {
    case TOOL_READ:
    case TOOL_WRITE:
    case TOOL_EDIT:
    case TOOL_NOTEBOOK_EDIT:
      return toolInput.file_path || toolInput.notebook_path || null;
    case TOOL_GLOB:
      return toolInput.path || toolInput.pattern || null;
    case TOOL_GREP:
      return toolInput.path || null;
    case TOOL_LS:
      return toolInput.path || null;
    default:
      return null;
  }
}

// src/core/hooks/SecurityHooks.ts
function createBlocklistHook(getContext) {
  return {
    matcher: TOOL_BASH,
    hooks: [
      async (hookInput) => {
        var _a;
        const input = hookInput;
        const command = ((_a = input.tool_input) == null ? void 0 : _a.command) || "";
        const context = getContext();
        const bashToolCommands = getBashToolBlockedCommands(context.blockedCommands);
        if (isCommandBlocked(command, bashToolCommands, context.enableBlocklist)) {
          new import_obsidian2.Notice("Command blocked by security policy");
          return {
            continue: false,
            hookSpecificOutput: {
              hookEventName: "PreToolUse",
              permissionDecision: "deny",
              permissionDecisionReason: `Command blocked by blocklist: ${command}`
            }
          };
        }
        return { continue: true };
      }
    ]
  };
}
function createVaultRestrictionHook(context) {
  return {
    hooks: [
      async (hookInput) => {
        var _a;
        const input = hookInput;
        const toolName = input.tool_name;
        if (toolName === TOOL_BASH) {
          const command = ((_a = input.tool_input) == null ? void 0 : _a.command) || "";
          const pathCheckContext = {
            getPathAccessType: (p2) => context.getPathAccessType(p2)
          };
          const violation = findBashCommandPathViolation(command, pathCheckContext);
          if (violation) {
            const reason = violation.type === "export_path_read" ? `Access denied: Command path "${violation.path}" is in an allowed export directory, but export paths are write-only.` : `Access denied: Command path "${violation.path}" is outside the vault. Agent is restricted to vault directory only.`;
            return {
              continue: false,
              hookSpecificOutput: {
                hookEventName: "PreToolUse",
                permissionDecision: "deny",
                permissionDecisionReason: reason
              }
            };
          }
          return { continue: true };
        }
        if (!isFileTool(toolName)) {
          return { continue: true };
        }
        const filePath = getPathFromToolInput(toolName, input.tool_input);
        if (filePath) {
          const accessType = context.getPathAccessType(filePath);
          if (accessType === "vault" || accessType === "readwrite" || accessType === "context") {
            return { continue: true };
          }
          if (isEditTool(toolName) && accessType === "export") {
            return { continue: true };
          }
          if (!isEditTool(toolName) && accessType === "export") {
            return {
              continue: false,
              hookSpecificOutput: {
                hookEventName: "PreToolUse",
                permissionDecision: "deny",
                permissionDecisionReason: `Access denied: Path "${filePath}" is in an allowed export directory, but export paths are write-only.`
              }
            };
          }
          return {
            continue: false,
            hookSpecificOutput: {
              hookEventName: "PreToolUse",
              permissionDecision: "deny",
              permissionDecisionReason: `Access denied: Path "${filePath}" is outside the vault. Agent is restricted to vault directory only.`
            }
          };
        }
        return { continue: true };
      }
    ]
  };
}

// src/core/sdk/transformSDKMessage.ts
function* transformSDKMessage(message, options) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
  const parentToolUseId = message.type === "result" ? null : (_a = message.parent_tool_use_id) != null ? _a : null;
  switch (message.type) {
    case "system":
      if (message.subtype === "init" && message.session_id) {
        yield { type: "session_init", sessionId: message.session_id };
      }
      break;
    case "assistant": {
      if (((_b = message.message) == null ? void 0 : _b.content) && Array.isArray(message.message.content)) {
        for (const block of message.message.content) {
          if (block.type === "thinking" && block.thinking) {
            yield { type: "thinking", content: block.thinking, parentToolUseId };
          } else if (block.type === "text" && block.text) {
            yield { type: "text", content: block.text, parentToolUseId };
          } else if (block.type === "tool_use") {
            yield {
              type: "tool_use",
              id: block.id || `tool-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`,
              name: block.name || "unknown",
              input: block.input || {},
              parentToolUseId
            };
          }
        }
      }
      const apiMessage = message.message;
      if (parentToolUseId === null && (apiMessage == null ? void 0 : apiMessage.usage)) {
        const usage = apiMessage.usage;
        const inputTokens = (_c = usage.input_tokens) != null ? _c : 0;
        const cacheCreationInputTokens = (_d = usage.cache_creation_input_tokens) != null ? _d : 0;
        const cacheReadInputTokens = (_e = usage.cache_read_input_tokens) != null ? _e : 0;
        const contextTokens = inputTokens + cacheCreationInputTokens + cacheReadInputTokens;
        const model = (_f = options == null ? void 0 : options.intendedModel) != null ? _f : "sonnet";
        const contextWindow = getContextWindowSize(model, (_g = options == null ? void 0 : options.is1MEnabled) != null ? _g : false, options == null ? void 0 : options.customContextLimits);
        const percentage = Math.min(100, Math.max(0, Math.round(contextTokens / contextWindow * 100)));
        const usageInfo = {
          model,
          inputTokens,
          cacheCreationInputTokens,
          cacheReadInputTokens,
          contextWindow,
          contextTokens,
          percentage
        };
        yield { type: "usage", usage: usageInfo };
      }
      break;
    }
    case "user":
      if (message._blocked && message._blockReason) {
        yield {
          type: "blocked",
          content: message._blockReason
        };
        break;
      }
      if (message.tool_use_result !== void 0 && message.parent_tool_use_id) {
        yield {
          type: "tool_result",
          id: message.parent_tool_use_id,
          content: typeof message.tool_use_result === "string" ? message.tool_use_result : JSON.stringify(message.tool_use_result, null, 2),
          isError: false,
          parentToolUseId,
          toolUseResult: (_h = message.tool_use_result) != null ? _h : void 0
        };
      }
      if (((_i = message.message) == null ? void 0 : _i.content) && Array.isArray(message.message.content)) {
        for (const block of message.message.content) {
          if (block.type === "tool_result") {
            yield {
              type: "tool_result",
              id: block.tool_use_id || message.parent_tool_use_id || "",
              content: typeof block.content === "string" ? block.content : JSON.stringify(block.content, null, 2),
              isError: block.is_error || false,
              parentToolUseId,
              toolUseResult: (_j = message.tool_use_result) != null ? _j : void 0
            };
          }
        }
      }
      break;
    case "stream_event": {
      const event = message.event;
      if ((event == null ? void 0 : event.type) === "content_block_start" && ((_k = event.content_block) == null ? void 0 : _k.type) === "tool_use") {
        yield {
          type: "tool_use",
          id: event.content_block.id || `tool-${Date.now()}`,
          name: event.content_block.name || "unknown",
          input: event.content_block.input || {},
          parentToolUseId
        };
      } else if ((event == null ? void 0 : event.type) === "content_block_start" && ((_l = event.content_block) == null ? void 0 : _l.type) === "thinking") {
        if (event.content_block.thinking) {
          yield { type: "thinking", content: event.content_block.thinking, parentToolUseId };
        }
      } else if ((event == null ? void 0 : event.type) === "content_block_start" && ((_m = event.content_block) == null ? void 0 : _m.type) === "text") {
        if (event.content_block.text) {
          yield { type: "text", content: event.content_block.text, parentToolUseId };
        }
      } else if ((event == null ? void 0 : event.type) === "content_block_delta") {
        if (((_n = event.delta) == null ? void 0 : _n.type) === "thinking_delta" && event.delta.thinking) {
          yield { type: "thinking", content: event.delta.thinking, parentToolUseId };
        } else if (((_o = event.delta) == null ? void 0 : _o.type) === "text_delta" && event.delta.text) {
          yield { type: "text", content: event.delta.text, parentToolUseId };
        }
      }
      break;
    }
    case "result":
      break;
    case "error":
      if (message.error) {
        yield { type: "error", content: message.error };
      }
      break;
  }
}

// src/core/sdk/typeGuards.ts
function isSessionInitEvent(event) {
  return event.type === "session_init";
}
function isStreamChunk(event) {
  return event.type !== "session_init";
}

// src/core/security/ApprovalManager.ts
function getActionPattern(toolName, input) {
  switch (toolName) {
    case TOOL_BASH:
      return typeof input.command === "string" ? input.command.trim() : "";
    case TOOL_READ:
    case TOOL_WRITE:
    case TOOL_EDIT:
      return input.file_path || "*";
    case TOOL_NOTEBOOK_EDIT:
      return input.notebook_path || input.file_path || "*";
    case TOOL_GLOB:
      return input.pattern || "*";
    case TOOL_GREP:
      return input.pattern || "*";
    default:
      return JSON.stringify(input);
  }
}
function generatePermissionRule(toolName, input) {
  const pattern = getActionPattern(toolName, input);
  if (!pattern || pattern === "*" || pattern.startsWith("{")) {
    return createPermissionRule(toolName);
  }
  return createPermissionRule(`${toolName}(${pattern})`);
}
function getActionDescription(toolName, input) {
  switch (toolName) {
    case TOOL_BASH:
      return `Run command: ${input.command}`;
    case TOOL_READ:
      return `Read file: ${input.file_path}`;
    case TOOL_WRITE:
      return `Write to file: ${input.file_path}`;
    case TOOL_EDIT:
      return `Edit file: ${input.file_path}`;
    case TOOL_GLOB:
      return `Search files matching: ${input.pattern}`;
    case TOOL_GREP:
      return `Search content matching: ${input.pattern}`;
    default:
      return `${toolName}: ${JSON.stringify(input)}`;
  }
}
function matchesRulePattern(toolName, actionPattern, rulePattern) {
  if (!rulePattern) return true;
  const normalizedAction = actionPattern.replace(/\\/g, "/");
  const normalizedRule = rulePattern.replace(/\\/g, "/");
  if (normalizedRule === "*") return true;
  if (normalizedAction === normalizedRule) return true;
  if (toolName === TOOL_BASH) {
    if (normalizedRule.endsWith("*")) {
      const prefix = normalizedRule.slice(0, -1);
      return normalizedAction.startsWith(prefix);
    }
    if (normalizedRule.endsWith(":*")) {
      const prefix = normalizedRule.slice(0, -2);
      return normalizedAction.startsWith(prefix);
    }
    return false;
  }
  if (toolName === TOOL_READ || toolName === TOOL_WRITE || toolName === TOOL_EDIT || toolName === TOOL_NOTEBOOK_EDIT) {
    return isPathPrefixMatch(normalizedAction, normalizedRule);
  }
  if (normalizedAction.startsWith(normalizedRule)) return true;
  return false;
}
function isPathPrefixMatch(actionPath, approvedPath) {
  if (!actionPath.startsWith(approvedPath)) {
    return false;
  }
  if (approvedPath.endsWith("/")) {
    return true;
  }
  if (actionPath.length === approvedPath.length) {
    return true;
  }
  return actionPath.charAt(approvedPath.length) === "/";
}
function matchesAnyRule(rules, toolName, actionPattern) {
  if (!rules || rules.length === 0) return false;
  return rules.some((rule) => {
    const { tool, pattern } = parseCCPermissionRule(rule);
    if (tool !== toolName) return false;
    return matchesRulePattern(toolName, actionPattern, pattern);
  });
}
var ApprovalManager = class {
  constructor(getPermissions) {
    this.sessionPermissions = [];
    this.addAllowRuleCallback = null;
    this.addDenyRuleCallback = null;
    this.getPermissions = getPermissions;
  }
  setAddAllowRuleCallback(callback) {
    this.addAllowRuleCallback = callback;
  }
  setAddDenyRuleCallback(callback) {
    this.addDenyRuleCallback = callback;
  }
  /**
   * Check permission for an action.
   *
   * Priority (highest to lowest):
   * 1. Session deny (ephemeral, this session only)
   * 2. Permanent deny (persisted in settings.json)
   * 3. Permanent ask (forces prompt even if allow rule exists)
   * 4. Session allow (ephemeral, this session only)
   * 5. Permanent allow (persisted in settings.json)
   * 6. Fallback to ask (no matching rule found)
   *
   * @returns 'allow' | 'deny' | 'ask'
   */
  checkPermission(toolName, input) {
    const actionPattern = getActionPattern(toolName, input);
    const permissions = this.getPermissions();
    const sessionDenied = this.sessionPermissions.some(
      (sp) => sp.type === "deny" && this.matchesSessionPermission(sp.rule, toolName, actionPattern)
    );
    if (sessionDenied) return "deny";
    if (matchesAnyRule(permissions.deny, toolName, actionPattern)) {
      return "deny";
    }
    if (matchesAnyRule(permissions.ask, toolName, actionPattern)) {
      return "ask";
    }
    const sessionAllowed = this.sessionPermissions.some(
      (sp) => sp.type === "allow" && this.matchesSessionPermission(sp.rule, toolName, actionPattern)
    );
    if (sessionAllowed) return "allow";
    if (matchesAnyRule(permissions.allow, toolName, actionPattern)) {
      return "allow";
    }
    return "ask";
  }
  /**
   * Legacy method for compatibility.
   * @deprecated Use checkPermission instead
   */
  isActionApproved(toolName, input) {
    return this.checkPermission(toolName, input) === "allow";
  }
  matchesSessionPermission(rule, toolName, actionPattern) {
    const { tool, pattern } = parseCCPermissionRule(rule);
    if (tool !== toolName) return false;
    return matchesRulePattern(toolName, actionPattern, pattern);
  }
  /**
   * Approve an action (add to allow list).
   * @throws Error if scope is 'always' but no callback is registered
   */
  async approveAction(toolName, input, scope) {
    const rule = generatePermissionRule(toolName, input);
    if (scope === "session") {
      this.sessionPermissions.push({ rule, type: "allow" });
    } else {
      if (!this.addAllowRuleCallback) {
        throw new Error("[ApprovalManager] Cannot persist allow rule: addAllowRuleCallback not registered");
      }
      await this.addAllowRuleCallback(rule);
    }
  }
  /**
   * Deny an action (add to deny list).
   * @throws Error if scope is 'always' but no callback is registered
   */
  async denyAction(toolName, input, scope) {
    const rule = generatePermissionRule(toolName, input);
    if (scope === "session") {
      this.sessionPermissions.push({ rule, type: "deny" });
    } else {
      if (!this.addDenyRuleCallback) {
        throw new Error("[ApprovalManager] Cannot persist deny rule: addDenyRuleCallback not registered");
      }
      await this.addDenyRuleCallback(rule);
    }
  }
  clearSessionPermissions() {
    this.sessionPermissions = [];
  }
  /**
   * Get session-scoped permissions (for testing/debugging).
   */
  getSessionPermissions() {
    return [...this.sessionPermissions];
  }
};

// src/core/agent/types.ts
var MESSAGE_CHANNEL_CONFIG = {
  MAX_QUEUED_MESSAGES: 8,
  // Memory protection from rapid user input
  MAX_MERGED_CHARS: 12e3
  // ~3k tokens  batch size under context limits
};
function createResponseHandler(options) {
  let _sawStreamText = false;
  let _sawAnyChunk = false;
  return {
    id: options.id,
    onChunk: options.onChunk,
    onDone: options.onDone,
    onError: options.onError,
    get sawStreamText() {
      return _sawStreamText;
    },
    get sawAnyChunk() {
      return _sawAnyChunk;
    },
    markStreamTextSeen() {
      _sawStreamText = true;
    },
    resetStreamText() {
      _sawStreamText = false;
    },
    markChunkSeen() {
      _sawAnyChunk = true;
    }
  };
}
var UNSUPPORTED_SDK_TOOLS = [
  "AskUserQuestion",
  "EnterPlanMode",
  "ExitPlanMode"
];
var DISABLED_BUILTIN_SUBAGENTS = [
  "Task(statusline-setup)"
];
function isTurnCompleteMessage(message) {
  const messageType = message.type;
  return messageType === "result" || messageType === "error";
}
function computeSystemPromptKey(settings11) {
  const parts = [
    settings11.mediaFolder || "",
    settings11.customPrompt || "",
    (settings11.allowedExportPaths || []).sort().join("|"),
    settings11.vaultPath || "",
    (settings11.userName || "").trim()
    // Note: hasEditorContext is per-message, not tracked here
  ];
  return parts.join("::");
}

// src/core/agent/MessageChannel.ts
var MessageChannel = class {
  constructor(onWarning = () => {
  }) {
    this.queue = [];
    this.turnActive = false;
    this.closed = false;
    this.resolveNext = null;
    this.currentSessionId = null;
    this.onWarning = onWarning;
  }
  setSessionId(sessionId) {
    this.currentSessionId = sessionId;
  }
  isTurnActive() {
    return this.turnActive;
  }
  isClosed() {
    return this.closed;
  }
  /**
   * Enqueue a message. If a turn is active:
   * - Text-only: merge with queued text (up to MAX_MERGED_CHARS)
   * - With attachments: replace any existing queued attachment (one at a time)
   */
  enqueue(message) {
    if (this.closed) {
      throw new Error("MessageChannel is closed");
    }
    const hasAttachments = this.messageHasAttachments(message);
    if (!this.turnActive) {
      if (this.resolveNext) {
        this.turnActive = true;
        const resolve3 = this.resolveNext;
        this.resolveNext = null;
        resolve3({ value: message, done: false });
      } else {
        if (this.queue.length >= MESSAGE_CHANNEL_CONFIG.MAX_QUEUED_MESSAGES) {
          this.onWarning(`[MessageChannel] Queue full (${MESSAGE_CHANNEL_CONFIG.MAX_QUEUED_MESSAGES}), dropping newest`);
          return;
        }
        if (hasAttachments) {
          this.queue.push({ type: "attachment", message });
        } else {
          this.queue.push({ type: "text", content: this.extractTextContent(message) });
        }
      }
      return;
    }
    if (hasAttachments) {
      const existingIdx = this.queue.findIndex((m) => m.type === "attachment");
      if (existingIdx >= 0) {
        this.queue[existingIdx] = { type: "attachment", message };
        this.onWarning("[MessageChannel] Attachment message replaced (only one can be queued)");
      } else {
        this.queue.push({ type: "attachment", message });
      }
      return;
    }
    const textContent = this.extractTextContent(message);
    const existingTextIdx = this.queue.findIndex((m) => m.type === "text");
    if (existingTextIdx >= 0) {
      const existing = this.queue[existingTextIdx];
      const mergedContent = existing.content + "\n\n" + textContent;
      if (mergedContent.length > MESSAGE_CHANNEL_CONFIG.MAX_MERGED_CHARS) {
        this.onWarning(`[MessageChannel] Merged content exceeds ${MESSAGE_CHANNEL_CONFIG.MAX_MERGED_CHARS} chars, dropping newest`);
        return;
      }
      existing.content = mergedContent;
    } else {
      if (this.queue.length >= MESSAGE_CHANNEL_CONFIG.MAX_QUEUED_MESSAGES) {
        this.onWarning(`[MessageChannel] Queue full (${MESSAGE_CHANNEL_CONFIG.MAX_QUEUED_MESSAGES}), dropping newest`);
        return;
      }
      this.queue.push({ type: "text", content: textContent });
    }
  }
  onTurnComplete() {
    this.turnActive = false;
    if (this.queue.length > 0 && this.resolveNext) {
      const pending = this.queue.shift();
      this.turnActive = true;
      const resolve3 = this.resolveNext;
      this.resolveNext = null;
      resolve3({ value: this.pendingToMessage(pending), done: false });
    }
  }
  close() {
    this.closed = true;
    this.queue = [];
    if (this.resolveNext) {
      const resolve3 = this.resolveNext;
      this.resolveNext = null;
      resolve3({ value: void 0, done: true });
    }
  }
  reset() {
    this.queue = [];
    this.turnActive = false;
    this.closed = false;
    this.resolveNext = null;
  }
  getQueueLength() {
    return this.queue.length;
  }
  [Symbol.asyncIterator]() {
    return {
      next: () => {
        if (this.closed) {
          return Promise.resolve({ value: void 0, done: true });
        }
        if (this.queue.length > 0 && !this.turnActive) {
          const pending = this.queue.shift();
          this.turnActive = true;
          return Promise.resolve({ value: this.pendingToMessage(pending), done: false });
        }
        return new Promise((resolve3) => {
          this.resolveNext = resolve3;
        });
      }
    };
  }
  messageHasAttachments(message) {
    var _a;
    if (!((_a = message.message) == null ? void 0 : _a.content)) return false;
    if (typeof message.message.content === "string") return false;
    return message.message.content.some((block) => block.type === "image");
  }
  extractTextContent(message) {
    var _a;
    if (!((_a = message.message) == null ? void 0 : _a.content)) return "";
    if (typeof message.message.content === "string") return message.message.content;
    return message.message.content.filter((block) => block.type === "text").map((block) => block.text).join("\n\n");
  }
  pendingToMessage(pending) {
    if (pending.type === "attachment") {
      return pending.message;
    }
    return {
      type: "user",
      message: {
        role: "user",
        content: pending.content
      },
      parent_tool_use_id: null,
      session_id: this.currentSessionId || ""
    };
  }
};

// src/utils/date.ts
function getTodayDate() {
  const now = /* @__PURE__ */ new Date();
  const readable = now.toLocaleDateString("en-US", {
    weekday: "long",
    year: "numeric",
    month: "long",
    day: "numeric"
  });
  const iso = now.toISOString().split("T")[0];
  return `${readable} (${iso})`;
}
function formatDurationMmSs(seconds) {
  if (!Number.isFinite(seconds) || seconds < 0) {
    return "0s";
  }
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  if (mins === 0) {
    return `${secs}s`;
  }
  return `${mins}m ${secs}s`;
}

// src/core/prompts/mainAgent.ts
function getBaseSystemPrompt(vaultPath, userName) {
  const vaultInfo = vaultPath ? `

Vault absolute path: ${vaultPath}` : "";
  const trimmedUserName = userName == null ? void 0 : userName.trim();
  const userContext = trimmedUserName ? `## User Context

You are collaborating with **${trimmedUserName}**.

` : "";
  return `${userContext}## Time Context

- **Current Date**: ${getTodayDate()}
- **Knowledge Status**: You possess extensive internal knowledge up to your training cutoff. You do not know the exact date of your cutoff, but you must assume that your internal weights are static and "past," while the Current Date is "present."

## Identity & Role

You are **Claudian**, an expert AI assistant specialized in Obsidian vault management, knowledge organization, and code analysis. You operate directly inside the user's Obsidian vault.

**Core Principles:**
1.  **Obsidian Native**: You understand Markdown, YAML frontmatter, Wiki-links, and the "second brain" philosophy.
2.  **Safety First**: You never overwrite data without understanding context. You always use relative paths.
3.  **Proactive Thinking**: You do not just execute; you *plan* and *verify*. You anticipate potential issues (like broken links or missing files).
4.  **Clarity**: Your changes are precise, minimizing "noise" in the user's notes or code.

The current working directory is the user's vault root.${vaultInfo}

## Path Rules (MUST FOLLOW)

| Location | Access | Path Format | Example |
|----------|--------|-------------|---------|
| **Vault** | Read/Write | Relative from vault root | \`notes/my-note.md\`, \`.\` |
| **Export paths** | Write-only | \`~\` or absolute | \`~/Desktop/output.docx\` |
| **External contexts** | Full access | Absolute path | \`/Users/me/Workspace/file.ts\` |

**Vault files** (default):
- \u2713 Correct: \`notes/my-note.md\`, \`my-note.md\`, \`folder/subfolder/file.md\`, \`.\`
- \u2717 WRONG: \`/notes/my-note.md\`, \`${vaultPath || "/absolute/path"}/file.md\`
- A leading slash or absolute path will FAIL for vault operations.

**Path specificity**: When paths overlap, the **more specific path wins**:
- If \`~/Desktop\` is export (write-only) and \`~/Desktop/Workspace\` is external context (full access)
- \u2192 Files in \`~/Desktop/Workspace\` have full read/write access
- \u2192 Files directly in \`~/Desktop\` remain write-only

## User Message Format

User messages have the query first, followed by optional XML context tags:

\`\`\`
User's question or request here

<current_note>
path/to/note.md
</current_note>

<editor_selection path="path/to/note.md" lines="10-15">
selected text content
</editor_selection>
\`\`\`

- The user's query/instruction always comes first in the message.
- \`<current_note>\`: The note the user is currently viewing/focused on. Read this to understand context.
- \`<editor_selection>\`: Text currently selected in the editor, with file path and line numbers.
- \`@filename.md\`: Files mentioned with @ in the query. Read these files when referenced.

## Obsidian Context

- **Structure**: Files are Markdown (.md). Folders organize content.
- **Frontmatter**: YAML at the top of files (metadata). Respect existing fields.
- **Links**: Internal Wiki-links \`[[note-name]]\` or \`[[folder/note-name]]\`. External links \`[text](url)\`.
  - When reading a note with wikilinks, consider reading linked notes\u2014they often contain related context that helps understand the current note.
- **Tags**: #tag-name for categorization.
- **Dataview**: You may encounter Dataview queries (in \`\`\`dataview\`\`\` blocks). Do not break them unless asked.
- **Vault Config**: \`.obsidian/\` contains internal config. Touch only if you know what you are doing.

**File References in Responses:**
When mentioning vault files in your responses, use wikilink format so users can click to open them:
- \u2713 Use: \`[[folder/note.md]]\` or \`[[note]]\`
- \u2717 Avoid: plain paths like \`folder/note.md\` (not clickable)

**Image embeds:** Use \`![[image.png]]\` to display images directly in chat. Images render visually, making it easy to show diagrams, screenshots, or visual content you're discussing.

Examples:
- "I found your notes in [[30.areas/finance/Investment lessons/2024.Current trading lessons.md]]"
- "See [[daily notes/2024-01-15]] for more details"
- "Here's the diagram: ![[attachments/architecture.png]]"

## Tool Usage Guidelines

Standard tools (Read, Write, Edit, Glob, Grep, LS, Bash, WebSearch, WebFetch, Skills) work as expected.

**Thinking Process:**
Before taking action, explicitly THINK about:
1.  **Context**: Do I have enough information? (Use Read/Search if not).
2.  **Impact**: What will this change affect? (Links, other files).
3.  **Plan**: What are the steps? (Use TodoWrite for >2 steps).

**Tool-Specific Rules:**
- **Read**:
    - Always Read a file before Editing it.
    - Read can view images (PNG, JPG, GIF, WebP) for visual analysis.
- **Edit**:
    - Requires **EXACT** \`old_string\` match including whitespace/indentation.
    - If Edit fails, Read the file again to check the current content.
- **Bash**:
    - Runs with vault as working directory.
    - **Prefer** Read/Write/Edit over shell commands for file operations (safer).
    - **Stdout-capable tools** (pandoc, jq, imagemagick): Prefer piping output directly instead of creating temporary files when the result will be used immediately.
    - Use BashOutput/KillShell to manage background processes.
- **LS**: Uses "." for vault root.
- **WebFetch**: For text/HTML/PDF only. Avoid binaries.

### WebSearch

Use WebSearch strictly according to the following logic:

1.  **Static/Historical**: Rely on internal knowledge for established facts, history, or older code libraries. Use WebSearch to confirm or expand on your knowledge.
2.  **Dynamic/Recent**: **MUST** search for:
    - "Latest" news, versions, docs.
    - Events in the current/previous year.
    - Volatile data (prices, weather).
3.  **Date Awareness**: If user says "yesterday", calculate the date relative to **Current Date**.
4.  **Ambiguity**: If unsure whether knowledge is outdated, SEARCH.

### Task (Subagents)

Spawn subagents for complex multi-step tasks. Parameters: \`prompt\`, \`description\`, \`subagent_type\`, \`run_in_background\`.

**CRITICAL - Subagent Path Rules:**
- Subagents inherit the vault as their working directory.
- Reference files using **RELATIVE** paths.
- NEVER use absolute paths in subagent prompts.

**When to use:**
- Parallelizable work (main + subagent or multiple subagents)
- Preserve main agent's context window
- Offload contained tasks while continuing other work

**IMPORTANT:** Always explicitly set \`run_in_background\` - never omit it:
- \`run_in_background=false\` for sync (inline) tasks
- \`run_in_background=true\` for async (background) tasks

**Sync Mode (\`run_in_background=false\`)**:
- Runs inline, result returned directly.
- **DEFAULT** to this unless explicitly asked or the task is very long-running.

**Async Mode (\`run_in_background=true\`)**:
- Use ONLY when explicitly requested or task is clearly long-running.
- Returns \`task_id\` and \`output_file\` path immediately.
- System sends \`<task-notification>\` with result when complete.
- Full transcript persists in \`output_file\`.

**Retrieving async results (three options):**
- Wait for \`<task-notification>\` (automatic, includes result)
- Use \`TaskOutput task_id="..." block=true\` (blocking) or \`block=false\` (polling)
- Read \`output_file\` directly with Read tool

**Async workflow:**
1. Launch: \`Task prompt="..." run_in_background=true\` \u2192 get \`task_id\` and \`output_file\`
2. Continue working on other tasks (if any)
3. If no other work: use \`TaskOutput task_id="..." block=true\` to wait for completion
4. Report result to user

**Critical:** Never end response without retrieving async task results. When idle, MUST actively wait with \`TaskOutput block=true\` rather than waiting passively.

### TodoWrite

Track task progress. Parameter: \`todos\` (array of {content, status, activeForm}).
- Statuses: \`pending\`, \`in_progress\`, \`completed\`
- \`content\`: imperative ("Fix the bug")
- \`activeForm\`: present continuous ("Fixing the bug")

**Use for:** Tasks with 2+ steps, multi-file changes, complex operations.
Use proactively for any task meeting these criteria to keep progress visible.

**Workflow:**
1.  **Plan**: Create the todo list at the start.
2.  **Execute**: Mark \`in_progress\` -> do work -> Mark \`completed\`.
3.  **Update**: If new tasks arise, add them.

**Example:** User asks "refactor auth and add tests"
\`\`\`
[
  {content: "Analyze auth module", status: "in_progress", activeForm: "Analyzing auth module"},
  {content: "Refactor auth code", status: "pending", activeForm: "Refactoring auth code"},
  {content: "Add unit tests", status: "pending", activeForm: "Adding unit tests"}
]
\`\`\`

### Skills

Reusable capability modules. Use the \`Skill\` tool to invoke them when their description matches the user's need.

## Editor Selection

User messages may include an \`<editor_selection>\` tag showing text the user selected:

\`\`\`xml
<editor_selection path="path/to/file.md" lines="line numbers">
selected text here
possibly multiple lines
</editor_selection>
\`\`\`

**When present:** The user selected this text before sending their message. Use this context to understand what they're referring to.`;
}
function getImageInstructions(mediaFolder) {
  const folder = mediaFolder.trim();
  const mediaPath = folder ? "./" + folder : ".";
  const examplePath = folder ? folder + "/" : "";
  return `

## Embedded Images in Notes

**Proactive image reading**: When reading a note with embedded images, read them alongside text for full context. Images often contain critical information (diagrams, screenshots, charts).

**Local images** (\`![[image.jpg]]\`):
- Located in media folder: \`${mediaPath}\`
- Read with: \`Read file_path="${examplePath}image.jpg"\`
- Formats: PNG, JPG/JPEG, GIF, WebP

**External images** (\`![alt](url)\`):
- WebFetch does NOT support images
- Download to media folder \u2192 Read \u2192 Replace URL with wiki-link:

\`\`\`bash
# Download to media folder with descriptive name
mkdir -p ${mediaPath}
img_name="downloaded_\\$(date +%s).png"
curl -sfo "${examplePath}$img_name" 'URL'
\`\`\`

Then read with \`Read file_path="${examplePath}$img_name"\`, and replace the markdown link \`![alt](url)\` with \`![[${examplePath}$img_name]]\` in the note.

**Benefits**: Image becomes a permanent vault asset, works offline, and uses Obsidian's native embed syntax.`;
}
function getExportInstructions(allowedExportPaths) {
  if (allowedExportPaths.length === 0) {
    return "";
  }
  const uniquePaths = Array.from(new Set(allowedExportPaths.map((p2) => p2.trim()).filter(Boolean)));
  if (uniquePaths.length === 0) {
    return "";
  }
  const formattedPaths = uniquePaths.map((p2) => `- ${p2}`).join("\n");
  return `

## Allowed Export Paths

Write-only destinations outside the vault:

${formattedPaths}

Examples:
\`\`\`bash
pandoc ./note.md -o ~/Desktop/note.docx   # Direct export
pandoc ./note.md | head -100              # Pipe to stdout (no temp file)
cp ./note.md ~/Desktop/note.md
\`\`\``;
}
function buildSystemPrompt(settings11 = {}) {
  var _a;
  let prompt = getBaseSystemPrompt(settings11.vaultPath, settings11.userName);
  prompt += getImageInstructions(settings11.mediaFolder || "");
  prompt += getExportInstructions(settings11.allowedExportPaths || []);
  if ((_a = settings11.customPrompt) == null ? void 0 : _a.trim()) {
    prompt += "\n\n## Custom Instructions\n\n" + settings11.customPrompt.trim();
  }
  return prompt;
}

// src/core/agent/customSpawn.ts
var import_child_process3 = require("child_process");
function createCustomSpawnFunction(enhancedPath) {
  return (options) => {
    let { command } = options;
    const { args, cwd, env, signal } = options;
    const shouldPipeStderr = !!(env == null ? void 0 : env.DEBUG_CLAUDE_AGENT_SDK);
    if (command === "node") {
      const nodeFullPath = findNodeExecutable(enhancedPath);
      if (nodeFullPath) {
        command = nodeFullPath;
      }
    }
    const child = (0, import_child_process3.spawn)(command, args, {
      cwd,
      env,
      signal,
      stdio: ["pipe", "pipe", shouldPipeStderr ? "pipe" : "ignore"],
      windowsHide: true
    });
    if (shouldPipeStderr && child.stderr && typeof child.stderr.on === "function") {
      child.stderr.on("data", () => {
      });
    }
    if (!child.stdin || !child.stdout) {
      throw new Error("Failed to create process streams");
    }
    return child;
  };
}

// src/core/agent/QueryOptionsBuilder.ts
var QueryOptionsBuilder = class _QueryOptionsBuilder {
  /**
   * Some changes (model, thinking tokens) can be updated dynamically; others require restart.
   */
  static needsRestart(currentConfig, newConfig) {
    if (!currentConfig) return true;
    if (currentConfig.systemPromptKey !== newConfig.systemPromptKey) return true;
    if (currentConfig.disallowedToolsKey !== newConfig.disallowedToolsKey) return true;
    if (currentConfig.pluginsKey !== newConfig.pluginsKey) return true;
    if (currentConfig.settingSources !== newConfig.settingSources) return true;
    if (currentConfig.claudeCliPath !== newConfig.claudeCliPath) return true;
    if (currentConfig.show1MModel !== newConfig.show1MModel) return true;
    if (currentConfig.enableChrome !== newConfig.enableChrome) return true;
    if (_QueryOptionsBuilder.pathsChanged(currentConfig.allowedExportPaths, newConfig.allowedExportPaths)) {
      return true;
    }
    if (_QueryOptionsBuilder.pathsChanged(currentConfig.externalContextPaths, newConfig.externalContextPaths)) {
      return true;
    }
    return false;
  }
  /** Builds configuration snapshot for restart detection. */
  static buildPersistentQueryConfig(ctx, externalContextPaths) {
    var _a;
    const systemPromptSettings = {
      mediaFolder: ctx.settings.mediaFolder,
      customPrompt: ctx.settings.systemPrompt,
      allowedExportPaths: ctx.settings.allowedExportPaths,
      vaultPath: ctx.vaultPath,
      userName: ctx.settings.userName
    };
    const budgetSetting = ctx.settings.thinkingBudget;
    const budgetConfig = THINKING_BUDGETS.find((b3) => b3.value === budgetSetting);
    const thinkingTokens = (_a = budgetConfig == null ? void 0 : budgetConfig.tokens) != null ? _a : null;
    const allDisallowedTools = ctx.mcpManager.getAllDisallowedMcpTools();
    const disallowedToolsKey = allDisallowedTools.join("|");
    const pluginsKey = ctx.pluginManager.getPluginsKey();
    return {
      model: ctx.settings.model,
      thinkingTokens: thinkingTokens && thinkingTokens > 0 ? thinkingTokens : null,
      permissionMode: ctx.settings.permissionMode,
      systemPromptKey: computeSystemPromptKey(systemPromptSettings),
      disallowedToolsKey,
      mcpServersKey: "",
      // Dynamic via setMcpServers, not tracked for restart
      pluginsKey,
      externalContextPaths: externalContextPaths || [],
      allowedExportPaths: ctx.settings.allowedExportPaths,
      settingSources: ctx.settings.loadUserClaudeSettings ? "user,project" : "project",
      claudeCliPath: ctx.cliPath,
      show1MModel: ctx.settings.show1MModel,
      enableChrome: ctx.settings.enableChrome
    };
  }
  /** Builds SDK options for the persistent query. */
  static buildPersistentQueryOptions(ctx) {
    const permissionMode = ctx.settings.permissionMode;
    const resolved = resolveModelWithBetas(ctx.settings.model, ctx.settings.show1MModel);
    const systemPrompt = buildSystemPrompt({
      mediaFolder: ctx.settings.mediaFolder,
      customPrompt: ctx.settings.systemPrompt,
      allowedExportPaths: ctx.settings.allowedExportPaths,
      vaultPath: ctx.vaultPath,
      userName: ctx.settings.userName
    });
    const options = {
      cwd: ctx.vaultPath,
      systemPrompt,
      model: resolved.model,
      abortController: ctx.abortController,
      pathToClaudeCodeExecutable: ctx.cliPath,
      settingSources: ctx.settings.loadUserClaudeSettings ? ["user", "project"] : ["project"],
      env: {
        ...process.env,
        ...ctx.customEnv,
        PATH: ctx.enhancedPath
      },
      includePartialMessages: true
    };
    if (resolved.betas) {
      options.betas = resolved.betas;
    }
    _QueryOptionsBuilder.applyExtraArgs(options, ctx.settings);
    options.disallowedTools = [
      ...ctx.mcpManager.getAllDisallowedMcpTools(),
      ...UNSUPPORTED_SDK_TOOLS,
      ...DISABLED_BUILTIN_SUBAGENTS
    ];
    const pluginConfigs = ctx.pluginManager.getActivePluginConfigs();
    if (pluginConfigs.length > 0) {
      options.plugins = pluginConfigs;
    }
    _QueryOptionsBuilder.applyAgents(options, ctx.agentManager);
    _QueryOptionsBuilder.applyPermissionMode(options, permissionMode, ctx.canUseTool);
    _QueryOptionsBuilder.applyThinkingBudget(options, ctx.settings.thinkingBudget);
    options.hooks = ctx.hooks;
    if (ctx.resumeSessionId) {
      options.resume = ctx.resumeSessionId;
    }
    if (ctx.externalContextPaths && ctx.externalContextPaths.length > 0) {
      options.additionalDirectories = ctx.externalContextPaths;
    }
    options.spawnClaudeCodeProcess = createCustomSpawnFunction(ctx.enhancedPath);
    return options;
  }
  /** Builds SDK options for a cold-start query. */
  static buildColdStartQueryOptions(ctx) {
    var _a;
    const permissionMode = ctx.settings.permissionMode;
    const selectedModel = (_a = ctx.modelOverride) != null ? _a : ctx.settings.model;
    const resolved = resolveModelWithBetas(selectedModel, ctx.settings.show1MModel);
    const systemPrompt = buildSystemPrompt({
      mediaFolder: ctx.settings.mediaFolder,
      customPrompt: ctx.settings.systemPrompt,
      allowedExportPaths: ctx.settings.allowedExportPaths,
      vaultPath: ctx.vaultPath,
      userName: ctx.settings.userName
    });
    const options = {
      cwd: ctx.vaultPath,
      systemPrompt,
      model: resolved.model,
      abortController: ctx.abortController,
      pathToClaudeCodeExecutable: ctx.cliPath,
      // User settings may contain permission rules that bypass Claudian's permission system
      settingSources: ctx.settings.loadUserClaudeSettings ? ["user", "project"] : ["project"],
      env: {
        ...process.env,
        ...ctx.customEnv,
        PATH: ctx.enhancedPath
      },
      includePartialMessages: true
    };
    if (resolved.betas) {
      options.betas = resolved.betas;
    }
    _QueryOptionsBuilder.applyExtraArgs(options, ctx.settings);
    const mcpMentions = ctx.mcpMentions || /* @__PURE__ */ new Set();
    const uiEnabledServers = ctx.enabledMcpServers || /* @__PURE__ */ new Set();
    const combinedMentions = /* @__PURE__ */ new Set([...mcpMentions, ...uiEnabledServers]);
    const mcpServers = ctx.mcpManager.getActiveServers(combinedMentions);
    if (Object.keys(mcpServers).length > 0) {
      options.mcpServers = mcpServers;
    }
    const disallowedMcpTools = ctx.mcpManager.getDisallowedMcpTools(combinedMentions);
    options.disallowedTools = [
      ...disallowedMcpTools,
      ...UNSUPPORTED_SDK_TOOLS,
      ...DISABLED_BUILTIN_SUBAGENTS
    ];
    const pluginConfigs = ctx.pluginManager.getActivePluginConfigs();
    if (pluginConfigs.length > 0) {
      options.plugins = pluginConfigs;
    }
    _QueryOptionsBuilder.applyAgents(options, ctx.agentManager);
    _QueryOptionsBuilder.applyPermissionMode(options, permissionMode, ctx.canUseTool);
    options.hooks = ctx.hooks;
    _QueryOptionsBuilder.applyThinkingBudget(options, ctx.settings.thinkingBudget);
    if (ctx.allowedTools !== void 0 && ctx.allowedTools.length > 0) {
      options.tools = ctx.allowedTools;
    }
    if (ctx.sessionId) {
      options.resume = ctx.sessionId;
    }
    if (ctx.externalContextPaths && ctx.externalContextPaths.length > 0) {
      options.additionalDirectories = ctx.externalContextPaths;
    }
    options.spawnClaudeCodeProcess = createCustomSpawnFunction(ctx.enhancedPath);
    return options;
  }
  static getMcpServersConfig(mcpManager, mcpMentions, enabledMcpServers) {
    const mentions = mcpMentions || /* @__PURE__ */ new Set();
    const uiEnabled = enabledMcpServers || /* @__PURE__ */ new Set();
    const combined = /* @__PURE__ */ new Set([...mentions, ...uiEnabled]);
    const servers = mcpManager.getActiveServers(combined);
    return {
      servers,
      key: JSON.stringify(servers)
    };
  }
  // ============================================
  // Private Helpers
  // ============================================
  /**
   * Always sets allowDangerouslySkipPermissions: true to enable dynamic
   * switching between permission modes without requiring a process restart.
   */
  static applyPermissionMode(options, permissionMode, canUseTool) {
    options.allowDangerouslySkipPermissions = true;
    if (permissionMode === "yolo") {
      options.permissionMode = "bypassPermissions";
    } else {
      options.permissionMode = "default";
      if (canUseTool) {
        options.canUseTool = canUseTool;
      }
    }
  }
  static applyExtraArgs(options, settings11) {
    if (settings11.enableChrome) {
      options.extraArgs = { ...options.extraArgs, chrome: null };
    }
  }
  static applyThinkingBudget(options, budgetSetting) {
    const budgetConfig = THINKING_BUDGETS.find((b3) => b3.value === budgetSetting);
    if (budgetConfig && budgetConfig.tokens > 0) {
      options.maxThinkingTokens = budgetConfig.tokens;
    }
  }
  static pathsChanged(a, b3) {
    const aKey = [...a || []].sort().join("|");
    const bKey = [...b3 || []].sort().join("|");
    return aKey !== bKey;
  }
  /**
   * Applies custom agents to options (filters out built-ins managed by SDK).
   */
  static applyAgents(options, agentManager) {
    var _a;
    const agents = (_a = agentManager == null ? void 0 : agentManager.getAvailableAgents().filter((a) => a.source !== "builtin")) != null ? _a : [];
    if (agents.length > 0) {
      options.agents = _QueryOptionsBuilder.buildSdkAgentsRecord(agents);
    }
  }
  static buildSdkAgentsRecord(agents) {
    const record = {};
    for (const agent of agents) {
      record[agent.id] = {
        description: agent.description,
        prompt: agent.prompt,
        tools: agent.tools,
        disallowedTools: agent.disallowedTools,
        // SDK expects undefined for 'inherit', not the string
        model: agent.model === "inherit" ? void 0 : agent.model
      };
    }
    return record;
  }
};

// src/core/agent/SessionManager.ts
var SessionManager = class {
  constructor() {
    this.state = {
      sessionId: null,
      sessionModel: null,
      pendingSessionModel: null,
      wasInterrupted: false,
      needsHistoryRebuild: false,
      sessionInvalidated: false
    };
  }
  getSessionId() {
    return this.state.sessionId;
  }
  setSessionId(id, defaultModel) {
    this.state.sessionId = id;
    this.state.sessionModel = id ? defaultModel != null ? defaultModel : null : null;
    this.state.needsHistoryRebuild = false;
    this.state.sessionInvalidated = false;
  }
  wasInterrupted() {
    return this.state.wasInterrupted;
  }
  markInterrupted() {
    this.state.wasInterrupted = true;
  }
  clearInterrupted() {
    this.state.wasInterrupted = false;
  }
  setPendingModel(model) {
    this.state.pendingSessionModel = model;
  }
  clearPendingModel() {
    this.state.pendingSessionModel = null;
  }
  /**
   * Captures a session ID from SDK response.
   * Detects mismatch if we had a different session ID before (context lost).
   */
  captureSession(sessionId) {
    const hadSession = this.state.sessionId !== null;
    const isDifferent = this.state.sessionId !== sessionId;
    if (hadSession && isDifferent) {
      this.state.needsHistoryRebuild = true;
    }
    this.state.sessionId = sessionId;
    this.state.sessionModel = this.state.pendingSessionModel;
    this.state.pendingSessionModel = null;
    this.state.sessionInvalidated = false;
  }
  needsHistoryRebuild() {
    return this.state.needsHistoryRebuild;
  }
  clearHistoryRebuild() {
    this.state.needsHistoryRebuild = false;
  }
  invalidateSession() {
    this.state.sessionId = null;
    this.state.sessionModel = null;
    this.state.sessionInvalidated = true;
  }
  /** Consume the invalidation flag (returns true once). */
  consumeInvalidation() {
    const wasInvalidated = this.state.sessionInvalidated;
    this.state.sessionInvalidated = false;
    return wasInvalidated;
  }
  reset() {
    this.state = {
      sessionId: null,
      sessionModel: null,
      pendingSessionModel: null,
      wasInterrupted: false,
      needsHistoryRebuild: false,
      sessionInvalidated: false
    };
  }
};

// src/core/agent/ClaudianService.ts
var ClaudianService = class {
  // Prevent consumer error restarts during cold-start
  constructor(plugin, mcpManager) {
    this.abortController = null;
    this.approvalCallback = null;
    this.vaultPath = null;
    this.currentExternalContextPaths = [];
    // Modular components
    this.sessionManager = new SessionManager();
    this.ccPermissions = { allow: [], deny: [], ask: [] };
    // ============================================
    // Persistent Query State (Phase 1)
    // ============================================
    this.persistentQuery = null;
    this.messageChannel = null;
    this.queryAbortController = null;
    this.responseHandlers = [];
    this.responseConsumerRunning = false;
    this.shuttingDown = false;
    // Tracked configuration for detecting changes that require restart
    this.currentConfig = null;
    // Current allowed tools for canUseTool enforcement (null = no restriction)
    this.currentAllowedTools = null;
    // Last sent message for crash recovery (Phase 1.3)
    this.lastSentMessage = null;
    this.lastSentQueryOptions = null;
    this.crashRecoveryAttempted = false;
    this.coldStartInProgress = false;
    this.plugin = plugin;
    this.mcpManager = mcpManager;
    this.approvalManager = new ApprovalManager(
      () => this.ccPermissions
    );
    this.approvalManager.setAddAllowRuleCallback(async (rule) => {
      try {
        await this.plugin.storage.addAllowRule(rule);
        await this.loadCCPermissions();
      } catch (e2) {
        new import_obsidian3.Notice("Failed to save permission rule");
      }
    });
    this.approvalManager.setAddDenyRuleCallback(async (rule) => {
      try {
        await this.plugin.storage.addDenyRule(rule);
        await this.loadCCPermissions();
      } catch (e2) {
        new import_obsidian3.Notice("Failed to save permission rule");
      }
    });
  }
  async loadCCPermissions() {
    this.ccPermissions = await this.plugin.storage.getPermissions();
  }
  async loadMcpServers() {
    await this.mcpManager.loadServers();
  }
  async reloadMcpServers() {
    await this.mcpManager.loadServers();
  }
  // ============================================
  // Persistent Query Lifecycle (Phase 1.3)
  // ============================================
  /**
   * Ensures the persistent query is running with current configuration.
   * Unified API that replaces preWarm() and restartPersistentQuery().
   *
   * Behavior:
   * - If not running  start (if paths available)
   * - If running and force=true  close and restart
   * - If running and config changed  close and restart
   * - If running and config unchanged  no-op
   *
   * Note: When restart is needed, the query is closed BEFORE checking if we can
   * start a new one. This ensures fallback to cold-start if CLI becomes unavailable.
   *
   * @returns true if the query was (re)started, false otherwise
   */
  async ensureReady(options) {
    var _a, _b, _c;
    const vaultPath = getVaultPath(this.plugin.app);
    if (options && options.externalContextPaths !== void 0) {
      this.currentExternalContextPaths = options.externalContextPaths;
    }
    const effectiveSessionId = (_b = (_a = options == null ? void 0 : options.sessionId) != null ? _a : this.sessionManager.getSessionId()) != null ? _b : void 0;
    const externalContextPaths = (_c = options == null ? void 0 : options.externalContextPaths) != null ? _c : this.currentExternalContextPaths;
    if (!this.persistentQuery) {
      if (!vaultPath) return false;
      const cliPath2 = this.plugin.getResolvedClaudeCliPath();
      if (!cliPath2) return false;
      await this.startPersistentQuery(vaultPath, cliPath2, effectiveSessionId, externalContextPaths);
      return true;
    }
    if (options == null ? void 0 : options.force) {
      this.closePersistentQuery("forced restart", { preserveHandlers: options.preserveHandlers });
      if (!vaultPath) return false;
      const cliPath2 = this.plugin.getResolvedClaudeCliPath();
      if (!cliPath2) return false;
      await this.startPersistentQuery(vaultPath, cliPath2, effectiveSessionId, externalContextPaths);
      return true;
    }
    if (!vaultPath) return false;
    const cliPath = this.plugin.getResolvedClaudeCliPath();
    if (!cliPath) return false;
    const newConfig = this.buildPersistentQueryConfig(vaultPath, cliPath, externalContextPaths);
    if (this.needsRestart(newConfig)) {
      this.closePersistentQuery("config changed", { preserveHandlers: options == null ? void 0 : options.preserveHandlers });
      const cliPathAfterClose = this.plugin.getResolvedClaudeCliPath();
      if (cliPathAfterClose) {
        await this.startPersistentQuery(vaultPath, cliPathAfterClose, effectiveSessionId, externalContextPaths);
        return true;
      }
      return false;
    }
    return false;
  }
  /**
   * Starts the persistent query for the active chat conversation.
   */
  async startPersistentQuery(vaultPath, cliPath, resumeSessionId, externalContextPaths) {
    if (this.persistentQuery) {
      return;
    }
    this.shuttingDown = false;
    this.vaultPath = vaultPath;
    this.messageChannel = new MessageChannel();
    if (resumeSessionId) {
      this.messageChannel.setSessionId(resumeSessionId);
      this.sessionManager.setSessionId(resumeSessionId, this.plugin.settings.model);
    }
    this.queryAbortController = new AbortController();
    const config = this.buildPersistentQueryConfig(vaultPath, cliPath, externalContextPaths);
    this.currentConfig = config;
    const options = await this.buildPersistentQueryOptions(
      vaultPath,
      cliPath,
      resumeSessionId,
      externalContextPaths
    );
    this.persistentQuery = u_({
      prompt: this.messageChannel,
      options
    });
    this.attachPersistentQueryStdinErrorHandler(this.persistentQuery);
    this.startResponseConsumer();
  }
  attachPersistentQueryStdinErrorHandler(query) {
    var _a;
    const stdin = (_a = query.transport) == null ? void 0 : _a.processStdin;
    if (!stdin || typeof stdin.on !== "function" || typeof stdin.once !== "function") {
      return;
    }
    const handler = (error) => {
      if (this.shuttingDown || this.isPipeError(error)) {
        return;
      }
      this.closePersistentQuery("stdin error");
    };
    stdin.on("error", handler);
    stdin.once("close", () => {
      stdin.removeListener("error", handler);
    });
  }
  isPipeError(error) {
    if (!error || typeof error !== "object") {
      return false;
    }
    const maybeError = error;
    if (maybeError.code === "EPIPE") {
      return true;
    }
    return typeof maybeError.message === "string" && maybeError.message.includes("EPIPE");
  }
  /**
   * Closes the persistent query and cleans up resources.
   */
  closePersistentQuery(_reason, options) {
    var _a, _b, _c;
    if (!this.persistentQuery) {
      return;
    }
    const preserveHandlers = (_a = options == null ? void 0 : options.preserveHandlers) != null ? _a : false;
    this.shuttingDown = true;
    (_b = this.messageChannel) == null ? void 0 : _b.close();
    void this.persistentQuery.interrupt().catch(() => {
    });
    (_c = this.queryAbortController) == null ? void 0 : _c.abort();
    if (!preserveHandlers) {
      for (const handler of this.responseHandlers) {
        handler.onDone();
      }
    }
    this.persistentQuery = null;
    this.messageChannel = null;
    this.queryAbortController = null;
    this.responseConsumerRunning = false;
    this.currentConfig = null;
    if (!preserveHandlers) {
      this.responseHandlers = [];
      this.currentAllowedTools = null;
    }
    this.shuttingDown = false;
  }
  /**
   * Checks if the persistent query needs to be restarted based on configuration changes.
   */
  needsRestart(newConfig) {
    return QueryOptionsBuilder.needsRestart(this.currentConfig, newConfig);
  }
  /**
   * Builds configuration object for tracking changes.
   */
  buildPersistentQueryConfig(vaultPath, cliPath, externalContextPaths) {
    return QueryOptionsBuilder.buildPersistentQueryConfig(
      this.buildQueryOptionsContext(vaultPath, cliPath),
      externalContextPaths
    );
  }
  /**
   * Builds the base query options context from current state.
   */
  buildQueryOptionsContext(vaultPath, cliPath) {
    const customEnv = parseEnvironmentVariables(this.plugin.getActiveEnvironmentVariables());
    const enhancedPath = getEnhancedPath(customEnv.PATH, cliPath);
    return {
      vaultPath,
      cliPath,
      settings: this.plugin.settings,
      customEnv,
      enhancedPath,
      mcpManager: this.mcpManager,
      pluginManager: this.plugin.pluginManager,
      agentManager: this.plugin.agentManager
    };
  }
  /**
   * Builds SDK options for the persistent query.
   */
  buildPersistentQueryOptions(vaultPath, cliPath, resumeSessionId, externalContextPaths) {
    var _a;
    const baseContext = this.buildQueryOptionsContext(vaultPath, cliPath);
    const hooks = this.buildHooks();
    const permissionMode = this.plugin.settings.permissionMode;
    const ctx = {
      ...baseContext,
      abortController: (_a = this.queryAbortController) != null ? _a : void 0,
      resumeSessionId,
      canUseTool: permissionMode !== "yolo" ? this.createApprovalCallback() : void 0,
      hooks,
      externalContextPaths
    };
    return QueryOptionsBuilder.buildPersistentQueryOptions(ctx);
  }
  /**
   * Builds the hooks for SDK options.
   * Hooks need access to `this` for dynamic settings, so they're built here.
   *
   * @param externalContextPaths - Optional external context paths for cold-start queries.
   *        If not provided, the closure reads this.currentExternalContextPaths at execution
   *        time (for persistent queries where the value may change dynamically).
   */
  buildHooks(externalContextPaths) {
    const blocklistHook = createBlocklistHook(() => ({
      blockedCommands: this.plugin.settings.blockedCommands,
      enableBlocklist: this.plugin.settings.enableBlocklist
    }));
    const vaultRestrictionHook = createVaultRestrictionHook({
      getPathAccessType: (p2) => {
        if (!this.vaultPath) return "vault";
        const paths = externalContextPaths != null ? externalContextPaths : this.currentExternalContextPaths;
        return getPathAccessType(
          p2,
          paths,
          this.plugin.settings.allowedExportPaths,
          this.vaultPath
        );
      }
    });
    return {
      PreToolUse: [blocklistHook, vaultRestrictionHook]
    };
  }
  // ============================================
  // Response Consumer Loop (Phase 1.4)
  // ============================================
  /**
   * Starts the background consumer loop that routes chunks to handlers.
   */
  startResponseConsumer() {
    if (this.responseConsumerRunning) {
      return;
    }
    this.responseConsumerRunning = true;
    const queryForThisConsumer = this.persistentQuery;
    void (async () => {
      var _a;
      if (!this.persistentQuery) return;
      try {
        for await (const message of this.persistentQuery) {
          if (this.shuttingDown) break;
          await this.routeMessage(message);
        }
      } catch (error) {
        if (this.persistentQuery !== queryForThisConsumer && this.persistentQuery !== null) {
          return;
        }
        if (!this.shuttingDown && !this.coldStartInProgress) {
          const handler = this.responseHandlers[this.responseHandlers.length - 1];
          const errorInstance = error instanceof Error ? error : new Error(String(error));
          const messageToReplay = this.lastSentMessage;
          if (!this.crashRecoveryAttempted && messageToReplay && handler && !handler.sawAnyChunk) {
            this.crashRecoveryAttempted = true;
            try {
              await this.ensureReady({ force: true, preserveHandlers: true });
              if (!this.messageChannel) {
                throw new Error("Persistent query restart did not create message channel");
              }
              await this.applyDynamicUpdates((_a = this.lastSentQueryOptions) != null ? _a : void 0, { preserveHandlers: true });
              this.messageChannel.enqueue(messageToReplay);
              return;
            } catch (restartError) {
              if (isSessionExpiredError(restartError)) {
                this.sessionManager.invalidateSession();
              }
              handler.onError(errorInstance);
              return;
            }
          }
          if (handler) {
            handler.onError(errorInstance);
          }
          if (!this.crashRecoveryAttempted) {
            this.crashRecoveryAttempted = true;
            try {
              await this.ensureReady({ force: true });
            } catch (restartError) {
              if (isSessionExpiredError(restartError)) {
                this.sessionManager.invalidateSession();
              }
            }
          }
        }
      } finally {
        if (this.persistentQuery === queryForThisConsumer || this.persistentQuery === null) {
          this.responseConsumerRunning = false;
        }
      }
    })();
  }
  /** @param modelOverride - Optional model override for cold-start queries */
  getTransformOptions(modelOverride) {
    var _a;
    return {
      intendedModel: modelOverride != null ? modelOverride : this.plugin.settings.model,
      is1MEnabled: (_a = this.plugin.settings.show1MModel) != null ? _a : false,
      customContextLimits: this.plugin.settings.customContextLimits
    };
  }
  /**
   * Routes an SDK message to the active response handler.
   *
   * Design: Only one handler exists at a time because MessageChannel enforces
   * single-turn processing. When a turn is active, new messages are queued/merged.
   * The next message only dequeues after onTurnComplete(), which calls onDone()
   * on the current handler. A new handler is registered only when the next query starts.
   */
  async routeMessage(message) {
    var _a, _b;
    const handler = this.responseHandlers[this.responseHandlers.length - 1];
    if (handler && this.isStreamTextEvent(message)) {
      handler.markStreamTextSeen();
    }
    for (const event of transformSDKMessage(message, this.getTransformOptions())) {
      if (isSessionInitEvent(event)) {
        this.sessionManager.captureSession(event.sessionId);
        (_a = this.messageChannel) == null ? void 0 : _a.setSessionId(event.sessionId);
      } else if (isStreamChunk(event)) {
        if (message.type === "assistant" && (handler == null ? void 0 : handler.sawStreamText) && event.type === "text") {
          continue;
        }
        if (handler) {
          if (event.type === "usage") {
            handler.onChunk({ ...event, sessionId: this.sessionManager.getSessionId() });
          } else {
            handler.onChunk(event);
          }
        }
      }
    }
    if (isTurnCompleteMessage(message)) {
      (_b = this.messageChannel) == null ? void 0 : _b.onTurnComplete();
      if (handler) {
        handler.resetStreamText();
        handler.onDone();
      }
    }
  }
  registerResponseHandler(handler) {
    this.responseHandlers.push(handler);
  }
  unregisterResponseHandler(handlerId) {
    const idx = this.responseHandlers.findIndex((h) => h.id === handlerId);
    if (idx >= 0) {
      this.responseHandlers.splice(idx, 1);
    }
  }
  isPersistentQueryActive() {
    return this.persistentQuery !== null && !this.shuttingDown;
  }
  /**
   * Sends a query to Claude and streams the response.
   *
   * Query selection:
   * - Persistent query: default chat conversation
   * - Cold-start query: only when forceColdStart is set
   */
  async *query(prompt, images, conversationHistory, queryOptions) {
    var _a;
    const vaultPath = getVaultPath(this.plugin.app);
    if (!vaultPath) {
      yield { type: "error", content: "Could not determine vault path" };
      return;
    }
    const resolvedClaudePath = this.plugin.getResolvedClaudeCliPath();
    if (!resolvedClaudePath) {
      yield { type: "error", content: "Claude CLI not found. Please install Claude Code CLI." };
      return;
    }
    const customEnv = parseEnvironmentVariables(this.plugin.getActiveEnvironmentVariables());
    const enhancedPath = getEnhancedPath(customEnv.PATH, resolvedClaudePath);
    const missingNodeError = getMissingNodeError(resolvedClaudePath, enhancedPath);
    if (missingNodeError) {
      yield { type: "error", content: missingNodeError };
      return;
    }
    let promptToSend = prompt;
    let forceColdStart = false;
    if (this.sessionManager.wasInterrupted()) {
      this.sessionManager.clearInterrupted();
    }
    if (this.sessionManager.needsHistoryRebuild() && conversationHistory && conversationHistory.length > 0) {
      const historyContext = buildContextFromHistory(conversationHistory);
      const actualPrompt = stripCurrentNoteContext(prompt);
      promptToSend = buildPromptWithHistoryContext(historyContext, prompt, actualPrompt, conversationHistory);
      this.sessionManager.clearHistoryRebuild();
    }
    const noSessionButHasHistory = !this.sessionManager.getSessionId() && conversationHistory && conversationHistory.length > 0;
    if (noSessionButHasHistory) {
      const historyContext = buildContextFromHistory(conversationHistory);
      const actualPrompt = stripCurrentNoteContext(prompt);
      promptToSend = buildPromptWithHistoryContext(historyContext, prompt, actualPrompt, conversationHistory);
      forceColdStart = true;
    }
    const effectiveQueryOptions = forceColdStart ? { ...queryOptions, forceColdStart: true } : queryOptions;
    if (forceColdStart) {
      this.coldStartInProgress = true;
      this.closePersistentQuery("session invalidated");
    }
    const shouldUsePersistent = this.shouldUsePersistentQuery(effectiveQueryOptions);
    if (shouldUsePersistent) {
      if (!this.persistentQuery && !this.shuttingDown) {
        await this.startPersistentQuery(
          vaultPath,
          resolvedClaudePath,
          (_a = this.sessionManager.getSessionId()) != null ? _a : void 0
        );
      }
      if (this.persistentQuery && !this.shuttingDown) {
        try {
          yield* this.queryViaPersistent(promptToSend, images, vaultPath, resolvedClaudePath, effectiveQueryOptions);
          return;
        } catch (error) {
          if (isSessionExpiredError(error) && conversationHistory && conversationHistory.length > 0) {
            this.sessionManager.invalidateSession();
            const retryRequest = this.buildHistoryRebuildRequest(prompt, conversationHistory);
            this.coldStartInProgress = true;
            this.abortController = new AbortController();
            try {
              yield* this.queryViaSDK(
                retryRequest.prompt,
                vaultPath,
                resolvedClaudePath,
                // Use current message's images, fallback to history images
                images != null ? images : retryRequest.images,
                effectiveQueryOptions
              );
            } catch (retryError) {
              const msg = retryError instanceof Error ? retryError.message : "Unknown error";
              yield { type: "error", content: msg };
            } finally {
              this.coldStartInProgress = false;
              this.abortController = null;
            }
            return;
          }
          throw error;
        }
      }
    }
    this.coldStartInProgress = true;
    this.abortController = new AbortController();
    try {
      yield* this.queryViaSDK(promptToSend, vaultPath, resolvedClaudePath, images, effectiveQueryOptions);
    } catch (error) {
      if (isSessionExpiredError(error) && conversationHistory && conversationHistory.length > 0) {
        this.sessionManager.invalidateSession();
        const retryRequest = this.buildHistoryRebuildRequest(prompt, conversationHistory);
        try {
          yield* this.queryViaSDK(
            retryRequest.prompt,
            vaultPath,
            resolvedClaudePath,
            // Use current message's images, fallback to history images
            images != null ? images : retryRequest.images,
            effectiveQueryOptions
          );
        } catch (retryError) {
          const msg2 = retryError instanceof Error ? retryError.message : "Unknown error";
          yield { type: "error", content: msg2 };
        }
        return;
      }
      const msg = error instanceof Error ? error.message : "Unknown error";
      yield { type: "error", content: msg };
    } finally {
      this.coldStartInProgress = false;
      this.abortController = null;
    }
  }
  buildHistoryRebuildRequest(prompt, conversationHistory) {
    const historyContext = buildContextFromHistory(conversationHistory);
    const actualPrompt = stripCurrentNoteContext(prompt);
    const fullPrompt = buildPromptWithHistoryContext(historyContext, prompt, actualPrompt, conversationHistory);
    const lastUserMessage = getLastUserMessage(conversationHistory);
    return {
      prompt: fullPrompt,
      images: lastUserMessage == null ? void 0 : lastUserMessage.images
    };
  }
  shouldUsePersistentQuery(queryOptions) {
    if (queryOptions == null ? void 0 : queryOptions.forceColdStart) return false;
    return true;
  }
  /**
   * Query via persistent query (Phase 1.5).
   * Uses the message channel to send messages without cold-start latency.
   */
  async *queryViaPersistent(prompt, images, vaultPath, cliPath, queryOptions) {
    if (!this.persistentQuery || !this.messageChannel) {
      yield* this.queryViaSDK(prompt, vaultPath, cliPath, images, queryOptions);
      return;
    }
    if ((queryOptions == null ? void 0 : queryOptions.allowedTools) !== void 0) {
      this.currentAllowedTools = queryOptions.allowedTools.length > 0 ? [...queryOptions.allowedTools, TOOL_SKILL] : [];
    } else {
      this.currentAllowedTools = null;
    }
    const savedAllowedTools = this.currentAllowedTools;
    await this.applyDynamicUpdates(queryOptions);
    this.currentAllowedTools = savedAllowedTools;
    if (!this.persistentQuery || !this.messageChannel) {
      yield* this.queryViaSDK(prompt, vaultPath, cliPath, images, queryOptions);
      return;
    }
    if (!this.responseConsumerRunning) {
      yield* this.queryViaSDK(prompt, vaultPath, cliPath, images, queryOptions);
      return;
    }
    const message = this.buildSDKUserMessage(prompt, images);
    const state = {
      chunks: [],
      resolveChunk: null,
      done: false,
      error: null
    };
    const handlerId = `handler-${Date.now()}-${Math.random().toString(36).slice(2)}`;
    const handler = createResponseHandler({
      id: handlerId,
      onChunk: (chunk) => {
        handler.markChunkSeen();
        if (state.resolveChunk) {
          state.resolveChunk(chunk);
          state.resolveChunk = null;
        } else {
          state.chunks.push(chunk);
        }
      },
      onDone: () => {
        state.done = true;
        if (state.resolveChunk) {
          state.resolveChunk(null);
          state.resolveChunk = null;
        }
      },
      onError: (err) => {
        state.error = err;
        state.done = true;
        if (state.resolveChunk) {
          state.resolveChunk(null);
          state.resolveChunk = null;
        }
      }
    });
    this.registerResponseHandler(handler);
    try {
      this.lastSentMessage = message;
      this.lastSentQueryOptions = queryOptions != null ? queryOptions : null;
      this.crashRecoveryAttempted = false;
      try {
        this.messageChannel.enqueue(message);
      } catch (error) {
        if (error instanceof Error && error.message.includes("closed")) {
          yield* this.queryViaSDK(prompt, vaultPath, cliPath, images, queryOptions);
          return;
        }
        throw error;
      }
      while (!state.done) {
        if (state.chunks.length > 0) {
          yield state.chunks.shift();
        } else {
          const chunk = await new Promise((resolve3) => {
            state.resolveChunk = resolve3;
          });
          if (chunk) {
            yield chunk;
          }
        }
      }
      while (state.chunks.length > 0) {
        yield state.chunks.shift();
      }
      if (state.error) {
        if (isSessionExpiredError(state.error)) {
          throw state.error;
        }
        yield { type: "error", content: state.error.message };
      }
      this.lastSentMessage = null;
      this.lastSentQueryOptions = null;
      yield { type: "done" };
    } finally {
      this.unregisterResponseHandler(handlerId);
      this.currentAllowedTools = null;
    }
  }
  buildSDKUserMessage(prompt, images) {
    const sessionId = this.sessionManager.getSessionId() || "";
    if (!images || images.length === 0) {
      return {
        type: "user",
        message: {
          role: "user",
          content: prompt
        },
        parent_tool_use_id: null,
        session_id: sessionId
      };
    }
    const content = [];
    for (const image of images) {
      content.push({
        type: "image",
        source: {
          type: "base64",
          media_type: image.mediaType,
          data: image.data
        }
      });
    }
    if (prompt.trim()) {
      content.push({
        type: "text",
        text: prompt
      });
    }
    return {
      type: "user",
      message: {
        role: "user",
        content
      },
      parent_tool_use_id: null,
      session_id: sessionId
    };
  }
  /**
   * Apply dynamic updates to the persistent query before sending a message (Phase 1.6).
   */
  async applyDynamicUpdates(queryOptions, restartOptions, allowRestart = true) {
    var _a, _b, _c;
    if (!this.persistentQuery) return;
    if (!this.vaultPath) {
      return;
    }
    const cliPath = this.plugin.getResolvedClaudeCliPath();
    if (!cliPath) {
      return;
    }
    const selectedModel = (queryOptions == null ? void 0 : queryOptions.model) || this.plugin.settings.model;
    const permissionMode = this.plugin.settings.permissionMode;
    const budgetSetting = this.plugin.settings.thinkingBudget;
    const budgetConfig = THINKING_BUDGETS.find((b3) => b3.value === budgetSetting);
    const thinkingTokens = (_a = budgetConfig == null ? void 0 : budgetConfig.tokens) != null ? _a : null;
    const show1MModel = this.plugin.settings.show1MModel;
    if (this.currentConfig && selectedModel !== this.currentConfig.model) {
      const resolved = resolveModelWithBetas(selectedModel, show1MModel);
      try {
        await this.persistentQuery.setModel(resolved.model);
        this.currentConfig.model = selectedModel;
      } catch (e2) {
      }
    }
    const currentThinking = (_c = (_b = this.currentConfig) == null ? void 0 : _b.thinkingTokens) != null ? _c : null;
    if (thinkingTokens !== currentThinking) {
      try {
        await this.persistentQuery.setMaxThinkingTokens(thinkingTokens);
        if (this.currentConfig) {
          this.currentConfig.thinkingTokens = thinkingTokens;
        }
      } catch (e2) {
      }
    }
    if (this.currentConfig && permissionMode !== this.currentConfig.permissionMode) {
      const sdkMode = permissionMode === "yolo" ? "bypassPermissions" : "default";
      try {
        await this.persistentQuery.setPermissionMode(sdkMode);
        this.currentConfig.permissionMode = permissionMode;
      } catch (e2) {
      }
    }
    const mcpMentions = (queryOptions == null ? void 0 : queryOptions.mcpMentions) || /* @__PURE__ */ new Set();
    const uiEnabledServers = (queryOptions == null ? void 0 : queryOptions.enabledMcpServers) || /* @__PURE__ */ new Set();
    const combinedMentions = /* @__PURE__ */ new Set([...mcpMentions, ...uiEnabledServers]);
    const mcpServers = this.mcpManager.getActiveServers(combinedMentions);
    const mcpServersKey = JSON.stringify(mcpServers);
    if (this.currentConfig && mcpServersKey !== this.currentConfig.mcpServersKey) {
      const serverConfigs = {};
      for (const [name, config] of Object.entries(mcpServers)) {
        serverConfigs[name] = config;
      }
      try {
        await this.persistentQuery.setMcpServers(serverConfigs);
        this.currentConfig.mcpServersKey = mcpServersKey;
      } catch (e2) {
      }
    }
    const newExternalContextPaths = (queryOptions == null ? void 0 : queryOptions.externalContextPaths) || [];
    this.currentExternalContextPaths = newExternalContextPaths;
    if (!allowRestart) {
      return;
    }
    const newConfig = this.buildPersistentQueryConfig(this.vaultPath, cliPath, newExternalContextPaths);
    if (!this.needsRestart(newConfig)) {
      return;
    }
    const restarted = await this.ensureReady({
      externalContextPaths: newExternalContextPaths,
      preserveHandlers: restartOptions == null ? void 0 : restartOptions.preserveHandlers,
      force: true
    });
    if (restarted && this.persistentQuery) {
      await this.applyDynamicUpdates(queryOptions, restartOptions, false);
    }
  }
  isStreamTextEvent(message) {
    var _a, _b;
    if (message.type !== "stream_event") return false;
    const event = message.event;
    if (!event) return false;
    if (event.type === "content_block_start") {
      return ((_a = event.content_block) == null ? void 0 : _a.type) === "text";
    }
    if (event.type === "content_block_delta") {
      return ((_b = event.delta) == null ? void 0 : _b.type) === "text_delta";
    }
    return false;
  }
  buildPromptWithImages(prompt, images) {
    if (!images || images.length === 0) {
      return prompt;
    }
    const content = [];
    for (const image of images) {
      content.push({
        type: "image",
        source: {
          type: "base64",
          media_type: image.mediaType,
          data: image.data
        }
      });
    }
    if (prompt.trim()) {
      content.push({
        type: "text",
        text: prompt
      });
    }
    async function* messageGenerator() {
      yield {
        type: "user",
        message: {
          role: "user",
          content
        }
      };
    }
    return messageGenerator();
  }
  async *queryViaSDK(prompt, cwd, cliPath, images, queryOptions) {
    var _a, _b, _c;
    const selectedModel = (queryOptions == null ? void 0 : queryOptions.model) || this.plugin.settings.model;
    const permissionMode = this.plugin.settings.permissionMode;
    this.sessionManager.setPendingModel(selectedModel);
    this.vaultPath = cwd;
    const queryPrompt = this.buildPromptWithImages(prompt, images);
    const baseContext = this.buildQueryOptionsContext(cwd, cliPath);
    const externalContextPaths = (queryOptions == null ? void 0 : queryOptions.externalContextPaths) || [];
    const hooks = this.buildHooks(externalContextPaths);
    const hasEditorContext = prompt.includes("<editor_selection");
    let allowedTools;
    if ((queryOptions == null ? void 0 : queryOptions.allowedTools) !== void 0 && queryOptions.allowedTools.length > 0) {
      const toolSet = /* @__PURE__ */ new Set([...queryOptions.allowedTools, TOOL_SKILL]);
      allowedTools = [...toolSet];
    }
    const ctx = {
      ...baseContext,
      abortController: (_a = this.abortController) != null ? _a : void 0,
      sessionId: (_b = this.sessionManager.getSessionId()) != null ? _b : void 0,
      modelOverride: queryOptions == null ? void 0 : queryOptions.model,
      canUseTool: permissionMode !== "yolo" ? this.createApprovalCallback() : void 0,
      hooks,
      mcpMentions: queryOptions == null ? void 0 : queryOptions.mcpMentions,
      enabledMcpServers: queryOptions == null ? void 0 : queryOptions.enabledMcpServers,
      allowedTools,
      hasEditorContext,
      externalContextPaths
    };
    const options = QueryOptionsBuilder.buildColdStartQueryOptions(ctx);
    let sawStreamText = false;
    try {
      const response = u_({ prompt: queryPrompt, options });
      let streamSessionId = this.sessionManager.getSessionId();
      for await (const message of response) {
        if (this.isStreamTextEvent(message)) {
          sawStreamText = true;
        }
        if ((_c = this.abortController) == null ? void 0 : _c.signal.aborted) {
          await response.interrupt();
          break;
        }
        for (const event of transformSDKMessage(message, this.getTransformOptions(selectedModel))) {
          if (isSessionInitEvent(event)) {
            this.sessionManager.captureSession(event.sessionId);
            streamSessionId = event.sessionId;
          } else if (isStreamChunk(event)) {
            if (message.type === "assistant" && sawStreamText && event.type === "text") {
              continue;
            }
            if (event.type === "usage") {
              yield { ...event, sessionId: streamSessionId };
            } else {
              yield event;
            }
          }
        }
        if (message.type === "result") {
          sawStreamText = false;
        }
      }
    } catch (error) {
      if (isSessionExpiredError(error)) {
        throw error;
      }
      const msg = error instanceof Error ? error.message : "Unknown error";
      yield { type: "error", content: msg };
    } finally {
      this.sessionManager.clearPendingModel();
      this.currentAllowedTools = null;
    }
    yield { type: "done" };
  }
  cancel() {
    if (this.abortController) {
      this.abortController.abort();
      this.sessionManager.markInterrupted();
    }
    if (this.persistentQuery && !this.shuttingDown) {
      void this.persistentQuery.interrupt().catch(() => {
      });
    }
  }
  /**
   * Reset the conversation session.
   * Closes the persistent query since session is changing.
   */
  resetSession() {
    this.closePersistentQuery("session reset");
    this.crashRecoveryAttempted = false;
    this.sessionManager.reset();
    this.approvalManager.clearSessionPermissions();
  }
  getSessionId() {
    return this.sessionManager.getSessionId();
  }
  /** Consume session invalidation flag for persistence updates. */
  consumeSessionInvalidation() {
    return this.sessionManager.consumeInvalidation();
  }
  /**
   * Check if the service is ready (persistent query is active).
   * Used to determine if SDK skills are available.
   */
  isReady() {
    return this.isPersistentQueryActive();
  }
  /**
   * Get supported commands (SDK skills) from the persistent query.
   * Returns an empty array if the query is not ready.
   */
  async getSupportedCommands() {
    if (!this.persistentQuery) {
      return [];
    }
    try {
      const sdkCommands = await this.persistentQuery.supportedCommands();
      return sdkCommands.map((cmd) => ({
        id: `sdk:${cmd.name}`,
        name: cmd.name,
        description: cmd.description,
        argumentHint: cmd.argumentHint,
        content: "",
        // SDK skills don't need content - they're handled by the SDK
        source: "sdk"
      }));
    } catch (e2) {
      return [];
    }
  }
  /**
   * Set the session ID (for restoring from saved conversation).
   * Closes persistent query synchronously if session is changing, then ensures query is ready.
   *
   * @param id - Session ID to restore, or null for new session
   * @param externalContextPaths - External context paths for the session (prevents stale contexts)
   */
  setSessionId(id, externalContextPaths) {
    const currentId = this.sessionManager.getSessionId();
    const sessionChanged = currentId !== id;
    if (sessionChanged) {
      this.closePersistentQuery("session switch");
      this.crashRecoveryAttempted = false;
    }
    this.sessionManager.setSessionId(id, this.plugin.settings.model);
    this.ensureReady({
      sessionId: id != null ? id : void 0,
      externalContextPaths
    }).catch(() => {
    });
  }
  /**
   * Cleanup resources (Phase 5).
   * Called on plugin unload to close persistent query and abort any cold-start query.
   */
  cleanup() {
    this.closePersistentQuery("plugin cleanup");
    this.cancel();
    this.resetSession();
  }
  setApprovalCallback(callback) {
    this.approvalCallback = callback;
  }
  /**
   * Create approval callback for normal mode.
   * Enforces tool restrictions and handles approval flow.
   */
  createApprovalCallback() {
    return async (toolName, input) => {
      if (this.currentAllowedTools !== null) {
        if (!this.currentAllowedTools.includes(toolName) && toolName !== TOOL_SKILL) {
          const allowedList = this.currentAllowedTools.length > 0 ? ` Allowed tools: ${this.currentAllowedTools.join(", ")}.` : " No tools are allowed for this query type.";
          return {
            behavior: "deny",
            message: `Tool "${toolName}" is not allowed for this query.${allowedList}`
          };
        }
      }
      return this.handleNormalModeApproval(toolName, input);
    };
  }
  /**
   * Handle normal mode approval - check approved actions, then prompt user.
   */
  async handleNormalModeApproval(toolName, input) {
    if (this.approvalManager.isActionApproved(toolName, input)) {
      return { behavior: "allow", updatedInput: input };
    }
    if (!this.approvalCallback) {
      return {
        behavior: "deny",
        message: "No approval handler available. Please enable YOLO mode or configure permissions."
      };
    }
    const description = getActionDescription(toolName, input);
    try {
      const decision = await this.approvalCallback(toolName, input, description);
      if (decision === "cancel") {
        return {
          behavior: "deny",
          message: "User interrupted.",
          interrupt: true
        };
      }
      if (decision === "deny") {
        await this.approvalManager.denyAction(toolName, input, "session");
        return {
          behavior: "deny",
          message: "User denied this action.",
          interrupt: false
        };
      }
      if (decision === "deny-always") {
        await this.approvalManager.denyAction(toolName, input, "always");
        return {
          behavior: "deny",
          message: "User denied this action.",
          interrupt: false
        };
      }
      if (decision === "allow-always") {
        await this.approvalManager.approveAction(toolName, input, "always");
      } else if (decision === "allow") {
        await this.approvalManager.approveAction(toolName, input, "session");
      }
      return { behavior: "allow", updatedInput: input };
    } catch (error) {
      return {
        behavior: "deny",
        message: `Approval request failed: ${error instanceof Error ? error.message : "Unknown error"}`,
        interrupt: true
      };
    }
  }
};

// src/core/commands/builtInCommands.ts
var BUILT_IN_COMMANDS = [
  {
    name: "clear",
    aliases: ["new"],
    description: "Start a new conversation",
    action: "clear"
  },
  {
    name: "add-dir",
    description: "Add external context directory",
    action: "add-dir",
    hasArgs: true,
    argumentHint: "path/to/directory"
  }
];
var commandMap = /* @__PURE__ */ new Map();
for (const cmd of BUILT_IN_COMMANDS) {
  commandMap.set(cmd.name.toLowerCase(), cmd);
  if (cmd.aliases) {
    for (const alias of cmd.aliases) {
      commandMap.set(alias.toLowerCase(), cmd);
    }
  }
}
function detectBuiltInCommand(input) {
  const trimmed = input.trim();
  if (!trimmed.startsWith("/")) return null;
  const match = trimmed.match(/^\/([a-zA-Z0-9_-]+)(?:\s(.*))?$/);
  if (!match) return null;
  const cmdName = match[1].toLowerCase();
  const command = commandMap.get(cmdName);
  if (!command) return null;
  const args = (match[2] || "").trim();
  return { command, args };
}
function getBuiltInCommandsForDropdown() {
  return BUILT_IN_COMMANDS.map((cmd) => ({
    id: `builtin:${cmd.name}`,
    name: cmd.name,
    description: cmd.description,
    content: "",
    // Built-in commands don't have prompt content
    argumentHint: cmd.argumentHint
  }));
}

// src/shared/components/SlashCommandDropdown.ts
var FILTERED_SDK_COMMANDS = /* @__PURE__ */ new Set([
  "compact",
  "context",
  "cost",
  "init",
  "release-notes",
  "security-review"
]);
var SlashCommandDropdown = class {
  constructor(containerEl, inputEl, callbacks, options = {}) {
    this.dropdownEl = null;
    this.slashStartIndex = -1;
    this.selectedIndex = 0;
    this.filteredCommands = [];
    // SDK skills cache
    this.cachedSdkSkills = [];
    this.sdkSkillsFetched = false;
    // Race condition guard for async dropdown rendering
    this.requestId = 0;
    var _a, _b;
    this.containerEl = containerEl;
    this.inputEl = inputEl;
    this.callbacks = callbacks;
    this.isFixed = (_a = options.fixed) != null ? _a : false;
    this.hiddenCommands = (_b = options.hiddenCommands) != null ? _b : /* @__PURE__ */ new Set();
    this.onInput = () => this.handleInputChange();
    this.inputEl.addEventListener("input", this.onInput);
  }
  setHiddenCommands(commands) {
    this.hiddenCommands = commands;
  }
  handleInputChange() {
    const text = this.getInputValue();
    const cursorPos = this.getCursorPosition();
    const textBeforeCursor = text.substring(0, cursorPos);
    if (text.charAt(0) !== "/") {
      this.hide();
      return;
    }
    const slashIndex = 0;
    const searchText = textBeforeCursor.substring(slashIndex + 1);
    if (/\s/.test(searchText)) {
      this.hide();
      return;
    }
    this.slashStartIndex = slashIndex;
    this.showDropdown(searchText);
  }
  handleKeydown(e2) {
    if (!this.isVisible()) return false;
    switch (e2.key) {
      case "ArrowDown":
        e2.preventDefault();
        this.navigate(1);
        return true;
      case "ArrowUp":
        e2.preventDefault();
        this.navigate(-1);
        return true;
      case "Enter":
      case "Tab":
        if (this.filteredCommands.length > 0) {
          e2.preventDefault();
          this.selectItem();
          return true;
        }
        return false;
      case "Escape":
        e2.preventDefault();
        this.hide();
        return true;
    }
    return false;
  }
  isVisible() {
    var _a, _b;
    return (_b = (_a = this.dropdownEl) == null ? void 0 : _a.hasClass("visible")) != null ? _b : false;
  }
  hide() {
    if (this.dropdownEl) {
      this.dropdownEl.removeClass("visible");
    }
    this.slashStartIndex = -1;
    this.callbacks.onHide();
  }
  destroy() {
    this.inputEl.removeEventListener("input", this.onInput);
    if (this.dropdownEl) {
      this.dropdownEl.remove();
      this.dropdownEl = null;
    }
  }
  /**
   * Resets the SDK skills cache.
   * Call this when switching conversations or creating a new chat.
   */
  resetSdkSkillsCache() {
    this.cachedSdkSkills = [];
    this.sdkSkillsFetched = false;
    this.requestId = 0;
  }
  getInputValue() {
    return this.inputEl.value;
  }
  getCursorPosition() {
    return this.inputEl.selectionStart || 0;
  }
  setInputValue(value) {
    this.inputEl.value = value;
  }
  setCursorPosition(pos) {
    this.inputEl.selectionStart = pos;
    this.inputEl.selectionEnd = pos;
  }
  async showDropdown(searchText) {
    const currentRequest = ++this.requestId;
    const builtInCommands = getBuiltInCommandsForDropdown();
    const searchLower = searchText.toLowerCase();
    if (!this.sdkSkillsFetched && this.callbacks.getSdkCommands) {
      try {
        const sdkCommands = await this.callbacks.getSdkCommands();
        if (currentRequest !== this.requestId) return;
        if (sdkCommands.length > 0) {
          this.cachedSdkSkills = sdkCommands;
          this.sdkSkillsFetched = true;
        }
      } catch (e2) {
        if (currentRequest !== this.requestId) return;
      }
    }
    const allCommands = this.buildCommandList(builtInCommands);
    this.filteredCommands = allCommands.filter(
      (cmd) => {
        var _a;
        return cmd.name.toLowerCase().includes(searchLower) || ((_a = cmd.description) == null ? void 0 : _a.toLowerCase().includes(searchLower));
      }
    ).sort((a, b3) => a.name.localeCompare(b3.name));
    if (currentRequest !== this.requestId) return;
    if (searchText.length > 0 && this.filteredCommands.length === 0) {
      this.hide();
      return;
    }
    this.selectedIndex = 0;
    this.render();
  }
  /**
   * Builds the merged command list from built-in and SDK commands.
   * Built-in commands have highest priority and are not subject to hiding.
   * SDK commands are deduplicated, filtered, and respect user hiding.
   */
  buildCommandList(builtInCommands) {
    const seenNames = /* @__PURE__ */ new Set();
    const allCommands = [];
    for (const cmd of builtInCommands) {
      const nameLower = cmd.name.toLowerCase();
      if (!seenNames.has(nameLower)) {
        seenNames.add(nameLower);
        allCommands.push(cmd);
      }
    }
    for (const cmd of this.cachedSdkSkills) {
      const nameLower = cmd.name.toLowerCase();
      if (FILTERED_SDK_COMMANDS.has(nameLower) || seenNames.has(nameLower) || this.hiddenCommands.has(nameLower)) {
        continue;
      }
      seenNames.add(nameLower);
      allCommands.push(cmd);
    }
    return allCommands;
  }
  render() {
    if (!this.dropdownEl) {
      this.dropdownEl = this.createDropdownElement();
    }
    this.dropdownEl.empty();
    if (this.filteredCommands.length === 0) {
      const emptyEl = this.dropdownEl.createDiv({ cls: "claudian-slash-empty" });
      emptyEl.setText("No matching commands");
    } else {
      for (let i2 = 0; i2 < this.filteredCommands.length; i2++) {
        const cmd = this.filteredCommands[i2];
        const itemEl = this.dropdownEl.createDiv({ cls: "claudian-slash-item" });
        if (i2 === this.selectedIndex) {
          itemEl.addClass("selected");
        }
        const nameEl = itemEl.createSpan({ cls: "claudian-slash-name" });
        nameEl.setText(`/${cmd.name}`);
        if (cmd.argumentHint) {
          const hintEl = itemEl.createSpan({ cls: "claudian-slash-hint" });
          hintEl.setText(`[${cmd.argumentHint}]`);
        }
        if (cmd.description) {
          const descEl = itemEl.createDiv({ cls: "claudian-slash-desc" });
          descEl.setText(cmd.description);
        }
        itemEl.addEventListener("click", () => {
          this.selectedIndex = i2;
          this.selectItem();
        });
        itemEl.addEventListener("mouseenter", () => {
          this.selectedIndex = i2;
          this.updateSelection();
        });
      }
    }
    this.dropdownEl.addClass("visible");
    if (this.isFixed) {
      this.positionFixed();
    }
  }
  createDropdownElement() {
    if (this.isFixed) {
      const dropdown = this.containerEl.createDiv({
        cls: "claudian-slash-dropdown claudian-slash-dropdown-fixed"
      });
      return dropdown;
    } else {
      return this.containerEl.createDiv({ cls: "claudian-slash-dropdown" });
    }
  }
  positionFixed() {
    if (!this.dropdownEl || !this.isFixed) return;
    const inputRect = this.inputEl.getBoundingClientRect();
    this.dropdownEl.style.position = "fixed";
    this.dropdownEl.style.bottom = `${window.innerHeight - inputRect.top + 4}px`;
    this.dropdownEl.style.left = `${inputRect.left}px`;
    this.dropdownEl.style.right = "auto";
    this.dropdownEl.style.width = `${Math.max(inputRect.width, 280)}px`;
    this.dropdownEl.style.zIndex = "10001";
  }
  navigate(direction) {
    const maxIndex = this.filteredCommands.length - 1;
    this.selectedIndex = Math.max(0, Math.min(maxIndex, this.selectedIndex + direction));
    this.updateSelection();
  }
  updateSelection() {
    var _a;
    const items = (_a = this.dropdownEl) == null ? void 0 : _a.querySelectorAll(".claudian-slash-item");
    items == null ? void 0 : items.forEach((item, index) => {
      if (index === this.selectedIndex) {
        item.addClass("selected");
        item.scrollIntoView({ block: "nearest" });
      } else {
        item.removeClass("selected");
      }
    });
  }
  selectItem() {
    if (this.filteredCommands.length === 0) return;
    const selected = this.filteredCommands[this.selectedIndex];
    if (!selected) return;
    const text = this.getInputValue();
    const beforeSlash = text.substring(0, this.slashStartIndex);
    const afterCursor = text.substring(this.getCursorPosition());
    const replacement = `/${selected.name} `;
    this.setInputValue(beforeSlash + replacement + afterCursor);
    this.setCursorPosition(beforeSlash.length + replacement.length);
    this.hide();
    this.callbacks.onSelect(selected);
    this.inputEl.focus();
  }
};

// src/features/chat/controllers/ConversationController.ts
var import_obsidian9 = require("obsidian");

// src/features/chat/rendering/MessageRenderer.ts
var import_obsidian8 = require("obsidian");

// src/utils/fileLink.ts
var WIKILINK_PATTERN_SOURCE = "(?<!!)\\[\\[([^\\]|#^]+)(?:#[^\\]|]+)?(?:\\^[^\\]|]+)?(?:\\|[^\\]]+)?\\]\\]";
function createWikilinkPattern() {
  return new RegExp(WIKILINK_PATTERN_SOURCE, "g");
}
function extractLinkTarget(fullMatch) {
  const inner = fullMatch.slice(2, -2);
  const pipeIndex = inner.indexOf("|");
  return pipeIndex >= 0 ? inner.slice(0, pipeIndex) : inner;
}
function findWikilinks(app, text) {
  const pattern = createWikilinkPattern();
  const matches = [];
  let match;
  while ((match = pattern.exec(text)) !== null) {
    const fullMatch = match[0];
    const linkPath = match[1];
    const linkTarget = extractLinkTarget(fullMatch);
    if (!fileExistsInVault(app, linkPath)) continue;
    const pipeIndex = fullMatch.lastIndexOf("|");
    const displayText = pipeIndex > 0 ? fullMatch.slice(pipeIndex + 1, -2) : linkPath;
    matches.push({ index: match.index, fullMatch, linkPath, linkTarget, displayText });
  }
  return matches.sort((a, b3) => b3.index - a.index);
}
function fileExistsInVault(app, linkPath) {
  const file = app.metadataCache.getFirstLinkpathDest(linkPath, "");
  if (file) {
    return true;
  }
  const directFile = app.vault.getFileByPath(linkPath);
  if (directFile) {
    return true;
  }
  if (!linkPath.endsWith(".md")) {
    const withExt = app.vault.getFileByPath(linkPath + ".md");
    if (withExt) {
      return true;
    }
  }
  return false;
}
function createWikilink(linkTarget, displayText) {
  const link = document.createElement("a");
  link.className = "claudian-file-link internal-link";
  link.textContent = displayText;
  link.setAttribute("data-href", linkTarget);
  link.setAttribute("href", linkTarget);
  return link;
}
function registerFileLinkHandler(app, container, component) {
  component.registerDomEvent(container, "click", (event) => {
    const target = event.target;
    const link = target.closest(".claudian-file-link, .internal-link");
    if (link) {
      event.preventDefault();
      const linkTarget = link.dataset.href || link.getAttribute("href");
      if (linkTarget) {
        void app.workspace.openLinkText(linkTarget, "", "tab");
      }
    }
  });
}
function buildFragmentWithLinks(text, matches) {
  const fragment = document.createDocumentFragment();
  let currentIndex = text.length;
  for (const { index, fullMatch, linkTarget, displayText } of matches) {
    const endIndex = index + fullMatch.length;
    if (endIndex < currentIndex) {
      fragment.insertBefore(
        document.createTextNode(text.slice(endIndex, currentIndex)),
        fragment.firstChild
      );
    }
    fragment.insertBefore(createWikilink(linkTarget, displayText), fragment.firstChild);
    currentIndex = index;
  }
  if (currentIndex > 0) {
    fragment.insertBefore(
      document.createTextNode(text.slice(0, currentIndex)),
      fragment.firstChild
    );
  }
  return fragment;
}
function processTextNode(app, node) {
  var _a;
  const text = node.textContent;
  if (!text || !text.includes("[[")) return false;
  const matches = findWikilinks(app, text);
  if (matches.length === 0) return false;
  (_a = node.parentNode) == null ? void 0 : _a.replaceChild(buildFragmentWithLinks(text, matches), node);
  return true;
}
function processFileLinks(app, container) {
  if (!app || !container) return;
  container.querySelectorAll("code").forEach((codeEl) => {
    var _a;
    if (((_a = codeEl.parentElement) == null ? void 0 : _a.tagName) === "PRE") return;
    const text = codeEl.textContent;
    if (!text || !text.includes("[[")) return;
    const matches = findWikilinks(app, text);
    if (matches.length === 0) return;
    codeEl.textContent = "";
    codeEl.appendChild(buildFragmentWithLinks(text, matches));
  });
  const walker = document.createTreeWalker(
    container,
    NodeFilter.SHOW_TEXT,
    {
      acceptNode(node2) {
        const parent = node2.parentElement;
        if (!parent) return NodeFilter.FILTER_REJECT;
        const tagName = parent.tagName.toUpperCase();
        if (tagName === "PRE" || tagName === "CODE" || tagName === "A") {
          return NodeFilter.FILTER_REJECT;
        }
        if (parent.closest("pre, code, a, .claudian-file-link, .internal-link")) {
          return NodeFilter.FILTER_REJECT;
        }
        return NodeFilter.FILTER_ACCEPT;
      }
    }
  );
  const textNodes = [];
  let node;
  while (node = walker.nextNode()) {
    textNodes.push(node);
  }
  for (const textNode of textNodes) {
    processTextNode(app, textNode);
  }
}

// src/utils/imageEmbed.ts
var IMAGE_EXTENSIONS = /* @__PURE__ */ new Set([
  "png",
  "jpg",
  "jpeg",
  "gif",
  "webp",
  "svg",
  "bmp",
  "ico"
]);
var IMAGE_EMBED_PATTERN = /!\[\[([^\]|]+)(?:\|([^\]]+))?\]\]/g;
function isImagePath(path10) {
  var _a;
  const ext = (_a = path10.split(".").pop()) == null ? void 0 : _a.toLowerCase();
  return ext ? IMAGE_EXTENSIONS.has(ext) : false;
}
function resolveImageFile(app, imagePath, mediaFolder) {
  let file = app.vault.getFileByPath(imagePath);
  if (file) return file;
  if (mediaFolder) {
    const withFolder = `${mediaFolder}/${imagePath}`;
    file = app.vault.getFileByPath(withFolder);
    if (file) return file;
  }
  const resolved = app.metadataCache.getFirstLinkpathDest(imagePath, "");
  if (resolved) return resolved;
  return null;
}
function escapeHtml(str) {
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
}
function buildStyleAttribute(altText) {
  if (!altText) return "";
  const dimMatch = altText.match(/^(\d+)(?:x(\d+))?$/);
  if (!dimMatch) return "";
  const width = dimMatch[1];
  const height = dimMatch[2];
  if (height) {
    return ` style="width: ${width}px; height: ${height}px;"`;
  }
  return ` style="width: ${width}px;"`;
}
function createImageHtml(app, file, altText) {
  const src = app.vault.getResourcePath(file);
  const alt = escapeHtml(altText || file.basename);
  const style = buildStyleAttribute(altText);
  return `<span class="claudian-embedded-image"><img src="${escapeHtml(src)}" alt="${alt}" loading="lazy"${style}></span>`;
}
function createFallbackHtml(wikilink) {
  return `<span class="claudian-embedded-image-fallback">${escapeHtml(wikilink)}</span>`;
}
function replaceImageEmbedsWithHtml(markdown, app, mediaFolder = "") {
  if (!(app == null ? void 0 : app.vault) || !(app == null ? void 0 : app.metadataCache)) {
    return markdown;
  }
  IMAGE_EMBED_PATTERN.lastIndex = 0;
  return markdown.replace(
    IMAGE_EMBED_PATTERN,
    (match, imagePath, altText) => {
      try {
        if (!isImagePath(imagePath)) {
          return match;
        }
        const file = resolveImageFile(app, imagePath, mediaFolder);
        if (!file) {
          return createFallbackHtml(match);
        }
        return createImageHtml(app, file, altText);
      } catch (e2) {
        return createFallbackHtml(match);
      }
    }
  );
}

// src/features/chat/rendering/SubagentRenderer.ts
var import_obsidian6 = require("obsidian");

// src/core/tools/todo.ts
function isValidTodoItem(item) {
  if (typeof item !== "object" || item === null) return false;
  const record = item;
  return typeof record.content === "string" && record.content.length > 0 && typeof record.activeForm === "string" && record.activeForm.length > 0 && typeof record.status === "string" && ["pending", "in_progress", "completed"].includes(record.status);
}
function parseTodoInput(input) {
  if (!input.todos || !Array.isArray(input.todos)) {
    return null;
  }
  const validTodos = [];
  for (const item of input.todos) {
    if (isValidTodoItem(item)) {
      validTodos.push(item);
    }
  }
  return validTodos.length > 0 ? validTodos : null;
}

// src/core/tools/toolIcons.ts
var TOOL_ICONS = {
  [TOOL_READ]: "file-text",
  [TOOL_WRITE]: "file-plus",
  [TOOL_EDIT]: "file-pen",
  [TOOL_NOTEBOOK_EDIT]: "file-pen",
  [TOOL_BASH]: "terminal",
  [TOOL_BASH_OUTPUT]: "terminal",
  [TOOL_KILL_SHELL]: "terminal",
  [TOOL_GLOB]: "folder-search",
  [TOOL_GREP]: "search",
  [TOOL_LS]: "list",
  [TOOL_TODO_WRITE]: "list-checks",
  [TOOL_TASK]: "bot",
  [TOOL_LIST_MCP_RESOURCES]: "list",
  [TOOL_READ_MCP_RESOURCE]: "file-text",
  [TOOL_MCP]: "wrench",
  [TOOL_WEB_SEARCH]: "globe",
  [TOOL_WEB_FETCH]: "download",
  [TOOL_AGENT_OUTPUT]: "bot",
  [TOOL_SKILL]: "zap"
};
var MCP_ICON_MARKER = "__mcp_icon__";
function getToolIcon(toolName) {
  if (toolName.startsWith("mcp__")) {
    return MCP_ICON_MARKER;
  }
  return TOOL_ICONS[toolName] || "wrench";
}

// src/features/chat/rendering/collapsible.ts
function setupCollapsible(wrapperEl, headerEl, contentEl, state, options = {}) {
  const { initiallyExpanded = false, onToggle, baseAriaLabel } = options;
  const updateAriaLabel = (isExpanded) => {
    if (baseAriaLabel) {
      const action = isExpanded ? "click to collapse" : "click to expand";
      headerEl.setAttribute("aria-label", `${baseAriaLabel} - ${action}`);
    }
  };
  state.isExpanded = initiallyExpanded;
  if (initiallyExpanded) {
    wrapperEl.addClass("expanded");
    contentEl.style.display = "block";
    headerEl.setAttribute("aria-expanded", "true");
  } else {
    contentEl.style.display = "none";
    headerEl.setAttribute("aria-expanded", "false");
  }
  updateAriaLabel(initiallyExpanded);
  const toggleExpand = () => {
    state.isExpanded = !state.isExpanded;
    if (state.isExpanded) {
      wrapperEl.addClass("expanded");
      contentEl.style.display = "block";
      headerEl.setAttribute("aria-expanded", "true");
    } else {
      wrapperEl.removeClass("expanded");
      contentEl.style.display = "none";
      headerEl.setAttribute("aria-expanded", "false");
    }
    updateAriaLabel(state.isExpanded);
    onToggle == null ? void 0 : onToggle(state.isExpanded);
  };
  headerEl.addEventListener("click", toggleExpand);
  headerEl.addEventListener("keydown", (e2) => {
    if (e2.key === "Enter" || e2.key === " ") {
      e2.preventDefault();
      toggleExpand();
    }
  });
}
function collapseElement(wrapperEl, headerEl, contentEl, state) {
  state.isExpanded = false;
  wrapperEl.removeClass("expanded");
  contentEl.style.display = "none";
  headerEl.setAttribute("aria-expanded", "false");
}

// src/features/chat/rendering/ToolCallRenderer.ts
var import_obsidian5 = require("obsidian");

// src/shared/icons.ts
var MCP_ICON_SVG = `<svg fill="currentColor" fill-rule="evenodd" height="1em" viewBox="0 0 24 24" width="1em" xmlns="http://www.w3.org/2000/svg"><title>MCP</title><path d="M15.688 2.343a2.588 2.588 0 00-3.61 0l-9.626 9.44a.863.863 0 01-1.203 0 .823.823 0 010-1.18l9.626-9.44a4.313 4.313 0 016.016 0 4.116 4.116 0 011.204 3.54 4.3 4.3 0 013.609 1.18l.05.05a4.115 4.115 0 010 5.9l-8.706 8.537a.274.274 0 000 .393l1.788 1.754a.823.823 0 010 1.18.863.863 0 01-1.203 0l-1.788-1.753a1.92 1.92 0 010-2.754l8.706-8.538a2.47 2.47 0 000-3.54l-.05-.049a2.588 2.588 0 00-3.607-.003l-7.172 7.034-.002.002-.098.097a.863.863 0 01-1.204 0 .823.823 0 010-1.18l7.273-7.133a2.47 2.47 0 00-.003-3.537z"></path><path d="M14.485 4.703a.823.823 0 000-1.18.863.863 0 00-1.204 0l-7.119 6.982a4.115 4.115 0 000 5.9 4.314 4.314 0 006.016 0l7.12-6.982a.823.823 0 000-1.18.863.863 0 00-1.204 0l-7.119 6.982a2.588 2.588 0 01-3.61 0 2.47 2.47 0 010-3.54l7.12-6.982z"></path></svg>`;
var CHECK_ICON_SVG = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>`;

// src/features/chat/rendering/todoUtils.ts
var import_obsidian4 = require("obsidian");
function getTodoStatusIcon(status) {
  return status === "completed" ? "check" : "dot";
}
function getTodoDisplayText(todo) {
  return todo.status === "in_progress" ? todo.activeForm : todo.content;
}
function renderTodoItems(container, todos) {
  container.empty();
  for (const todo of todos) {
    const item = container.createDiv({ cls: `claudian-todo-item claudian-todo-${todo.status}` });
    const icon = item.createSpan({ cls: "claudian-todo-status-icon" });
    icon.setAttribute("aria-hidden", "true");
    (0, import_obsidian4.setIcon)(icon, getTodoStatusIcon(todo.status));
    const text = item.createSpan({ cls: "claudian-todo-text" });
    text.setText(getTodoDisplayText(todo));
  }
}

// src/features/chat/rendering/ToolCallRenderer.ts
function setToolIcon(el, name) {
  const icon = getToolIcon(name);
  if (icon === MCP_ICON_MARKER) {
    el.innerHTML = MCP_ICON_SVG;
  } else {
    (0, import_obsidian5.setIcon)(el, icon);
  }
}
function getToolLabel(name, input) {
  switch (name) {
    case TOOL_READ:
      return `Read: ${shortenPath(input.file_path) || "file"}`;
    case TOOL_WRITE:
      return `Write: ${shortenPath(input.file_path) || "file"}`;
    case TOOL_EDIT:
      return `Edit: ${shortenPath(input.file_path) || "file"}`;
    case TOOL_BASH: {
      const cmd = input.command || "command";
      return `Bash: ${cmd.length > 40 ? cmd.substring(0, 40) + "..." : cmd}`;
    }
    case TOOL_GLOB:
      return `Glob: ${input.pattern || "files"}`;
    case TOOL_GREP:
      return `Grep: ${input.pattern || "pattern"}`;
    case TOOL_WEB_SEARCH: {
      const query = input.query || "search";
      return `WebSearch: ${query.length > 40 ? query.substring(0, 40) + "..." : query}`;
    }
    case TOOL_WEB_FETCH: {
      const url = input.url || "url";
      return `WebFetch: ${url.length > 40 ? url.substring(0, 40) + "..." : url}`;
    }
    case TOOL_LS:
      return `LS: ${shortenPath(input.path) || "."}`;
    case TOOL_TODO_WRITE: {
      const todos = input.todos;
      if (todos && Array.isArray(todos)) {
        const completed = todos.filter((t2) => t2.status === "completed").length;
        return `Tasks (${completed}/${todos.length})`;
      }
      return "Tasks";
    }
    case TOOL_SKILL: {
      const skillName = input.skill || "skill";
      return `Skill: ${skillName}`;
    }
    default:
      return name;
  }
}
function shortenPath(filePath) {
  if (!filePath) return "";
  const normalized = filePath.replace(/\\/g, "/");
  const parts = normalized.split("/");
  if (parts.length <= 3) return normalized;
  return ".../" + parts.slice(-2).join("/");
}
function parseWebSearchResult(result) {
  const linksMatch = result.match(/Links:\s*(\[[\s\S]*\])/);
  if (!linksMatch) return null;
  try {
    const links = JSON.parse(linksMatch[1]);
    if (!Array.isArray(links) || links.length === 0) return null;
    return links;
  } catch (e2) {
    return null;
  }
}
function renderWebSearchResult(container, result, maxItems = 3) {
  const links = parseWebSearchResult(result);
  if (!links) return false;
  container.empty();
  const displayItems = links.slice(0, maxItems);
  displayItems.forEach((link) => {
    const item = container.createSpan({ cls: "claudian-tool-result-bullet" });
    item.setText(`\u2022 ${link.title}`);
  });
  if (links.length > maxItems) {
    const more = container.createSpan({ cls: "claudian-tool-result-item" });
    more.setText(`${links.length - maxItems} more results`);
  }
  return true;
}
function renderReadResult(container, result) {
  container.empty();
  const lines = result.split(/\r?\n/).filter((line) => line.trim() !== "");
  const item = container.createSpan({ cls: "claudian-tool-result-item" });
  item.setText(`${lines.length} lines read`);
}
function getTodos(input) {
  const todos = input.todos;
  if (!todos || !Array.isArray(todos)) return void 0;
  return todos;
}
function getCurrentTask(input) {
  const todos = getTodos(input);
  if (!todos) return void 0;
  return todos.find((t2) => t2.status === "in_progress");
}
function areAllTodosCompleted(input) {
  const todos = getTodos(input);
  if (!todos || todos.length === 0) return false;
  return todos.every((t2) => t2.status === "completed");
}
function resetStatusElement(statusEl, statusClass, ariaLabel) {
  statusEl.className = "claudian-tool-status";
  statusEl.empty();
  statusEl.addClass(statusClass);
  statusEl.setAttribute("aria-label", ariaLabel);
}
var STATUS_ICONS = {
  completed: "check",
  error: "x",
  blocked: "shield-off"
};
function setTodoWriteStatus(statusEl, input) {
  const isComplete = areAllTodosCompleted(input);
  const status = isComplete ? "completed" : "running";
  const ariaLabel = isComplete ? "Status: completed" : "Status: in progress";
  resetStatusElement(statusEl, `status-${status}`, ariaLabel);
  if (isComplete) (0, import_obsidian5.setIcon)(statusEl, "check");
}
function setToolStatus(statusEl, status) {
  resetStatusElement(statusEl, `status-${status}`, `Status: ${status}`);
  const icon = STATUS_ICONS[status];
  if (icon) (0, import_obsidian5.setIcon)(statusEl, icon);
}
function renderToolResultContent(container, toolName, result) {
  if (!result) {
    container.setText("No result");
    return;
  }
  if (toolName === TOOL_WEB_SEARCH) {
    if (!renderWebSearchResult(container, result, 3)) {
      renderResultLines(container, result, 3);
    }
  } else if (toolName === TOOL_READ) {
    renderReadResult(container, result);
  } else {
    renderResultLines(container, result, 3);
  }
}
function createCurrentTaskPreview(header, input) {
  const currentTaskEl = header.createSpan({ cls: "claudian-tool-current" });
  const currentTask = getCurrentTask(input);
  if (currentTask) {
    currentTaskEl.setText(currentTask.activeForm);
  }
  return currentTaskEl;
}
function createTodoToggleHandler(currentTaskEl, statusEl, onExpandChange) {
  return (expanded) => {
    if (onExpandChange) onExpandChange(expanded);
    if (currentTaskEl) {
      currentTaskEl.style.display = expanded ? "none" : "";
    }
    if (statusEl) {
      statusEl.style.display = expanded ? "none" : "";
    }
  };
}
function renderTodoWriteResult(container, input) {
  container.empty();
  container.addClass("claudian-todo-panel-content");
  container.addClass("claudian-todo-list-container");
  const todos = input.todos;
  if (!todos || !Array.isArray(todos)) {
    const item = container.createSpan({ cls: "claudian-tool-result-item" });
    item.setText("Tasks updated");
    return;
  }
  renderTodoItems(container, todos);
}
function renderResultLines(container, result, maxLines = 3) {
  container.empty();
  const lines = result.split(/\r?\n/);
  const displayLines = lines.slice(0, maxLines);
  displayLines.forEach((line) => {
    const stripped = line.replace(/^\s*\d+/, "");
    const item = container.createSpan({ cls: "claudian-tool-result-item" });
    item.setText(stripped);
  });
  if (lines.length > maxLines) {
    const more = container.createSpan({ cls: "claudian-tool-result-item" });
    more.setText(`${lines.length - maxLines} more lines`);
  }
}
function isBlockedToolResult(content, isError) {
  const lower = content.toLowerCase();
  if (lower.includes("blocked by blocklist")) return true;
  if (lower.includes("outside the vault")) return true;
  if (lower.includes("access denied")) return true;
  if (lower.includes("user denied")) return true;
  if (lower.includes("approval")) return true;
  if (isError && lower.includes("deny")) return true;
  return false;
}
function createToolElementStructure(parentEl, toolCall) {
  const toolEl = parentEl.createDiv({ cls: "claudian-tool-call" });
  const header = toolEl.createDiv({ cls: "claudian-tool-header" });
  header.setAttribute("tabindex", "0");
  header.setAttribute("role", "button");
  const iconEl = header.createSpan({ cls: "claudian-tool-icon" });
  iconEl.setAttribute("aria-hidden", "true");
  setToolIcon(iconEl, toolCall.name);
  const labelEl = header.createSpan({ cls: "claudian-tool-label" });
  labelEl.setText(getToolLabel(toolCall.name, toolCall.input));
  const currentTaskEl = toolCall.name === TOOL_TODO_WRITE ? createCurrentTaskPreview(header, toolCall.input) : null;
  const statusEl = header.createSpan({ cls: "claudian-tool-status" });
  const content = toolEl.createDiv({ cls: "claudian-tool-content" });
  return { toolEl, header, labelEl, statusEl, content, currentTaskEl };
}
function renderToolContent(content, toolCall, initialText) {
  if (toolCall.name === TOOL_TODO_WRITE) {
    content.addClass("claudian-tool-content-todo");
    renderTodoWriteResult(content, toolCall.input);
  } else {
    const resultRow = content.createDiv({ cls: "claudian-tool-result-row" });
    const resultText = resultRow.createSpan({ cls: "claudian-tool-result-text" });
    if (initialText) {
      resultText.setText(initialText);
    } else {
      renderToolResultContent(resultText, toolCall.name, toolCall.result);
    }
  }
}
function renderToolCall(parentEl, toolCall, toolCallElements) {
  const { toolEl, header, statusEl, content, currentTaskEl } = createToolElementStructure(parentEl, toolCall);
  toolEl.dataset.toolId = toolCall.id;
  toolCallElements.set(toolCall.id, toolEl);
  statusEl.addClass(`status-${toolCall.status}`);
  statusEl.setAttribute("aria-label", `Status: ${toolCall.status}`);
  renderToolContent(content, toolCall, "Running...");
  const state = { isExpanded: false };
  toolCall.isExpanded = false;
  const todoStatusEl = toolCall.name === TOOL_TODO_WRITE ? statusEl : null;
  setupCollapsible(toolEl, header, content, state, {
    initiallyExpanded: false,
    onToggle: createTodoToggleHandler(currentTaskEl, todoStatusEl, (expanded) => {
      toolCall.isExpanded = expanded;
    }),
    baseAriaLabel: getToolLabel(toolCall.name, toolCall.input)
  });
  return toolEl;
}
function updateToolCallResult(toolId, toolCall, toolCallElements) {
  const toolEl = toolCallElements.get(toolId);
  if (!toolEl) return;
  if (toolCall.name === TOOL_TODO_WRITE) {
    const statusEl2 = toolEl.querySelector(".claudian-tool-status");
    if (statusEl2) {
      setTodoWriteStatus(statusEl2, toolCall.input);
    }
    const content = toolEl.querySelector(".claudian-tool-content");
    if (content) {
      renderTodoWriteResult(content, toolCall.input);
    }
    const labelEl = toolEl.querySelector(".claudian-tool-label");
    if (labelEl) {
      labelEl.setText(getToolLabel(toolCall.name, toolCall.input));
    }
    const currentTaskEl = toolEl.querySelector(".claudian-tool-current");
    if (currentTaskEl) {
      const currentTask = getCurrentTask(toolCall.input);
      currentTaskEl.setText(currentTask ? currentTask.activeForm : "");
    }
    return;
  }
  const statusEl = toolEl.querySelector(".claudian-tool-status");
  if (statusEl) {
    setToolStatus(statusEl, toolCall.status);
  }
  const resultText = toolEl.querySelector(".claudian-tool-result-text");
  if (resultText) {
    renderToolResultContent(resultText, toolCall.name, toolCall.result);
  }
}
function renderStoredToolCall(parentEl, toolCall) {
  const { toolEl, header, statusEl, content, currentTaskEl } = createToolElementStructure(parentEl, toolCall);
  if (toolCall.name === TOOL_TODO_WRITE) {
    setTodoWriteStatus(statusEl, toolCall.input);
  } else {
    setToolStatus(statusEl, toolCall.status);
  }
  renderToolContent(content, toolCall);
  const state = { isExpanded: false };
  const todoStatusEl = toolCall.name === TOOL_TODO_WRITE ? statusEl : null;
  setupCollapsible(toolEl, header, content, state, {
    initiallyExpanded: false,
    onToggle: createTodoToggleHandler(currentTaskEl, todoStatusEl),
    baseAriaLabel: getToolLabel(toolCall.name, toolCall.input)
  });
  return toolEl;
}

// src/features/chat/rendering/SubagentRenderer.ts
function extractTaskDescription(input) {
  return input.description || "Subagent task";
}
function truncateDescription(description, maxLength = 40) {
  if (description.length <= maxLength) return description;
  return description.substring(0, maxLength) + "...";
}
function truncateResult(result) {
  const lines = result.split(/\r?\n/).filter((line) => line.trim());
  if (lines.length <= 2) {
    return lines.join("\n");
  }
  return lines.slice(0, 2).join("\n") + "...";
}
function createStatusRow(parentEl, text, options) {
  const rowEl = parentEl.createDiv({ cls: "claudian-subagent-done" });
  if (options == null ? void 0 : options.rowClass) rowEl.addClass(options.rowClass);
  const textEl = rowEl.createDiv({ cls: "claudian-subagent-done-text" });
  if (options == null ? void 0 : options.textClass) textEl.addClass(options.textClass);
  textEl.setText(text);
  return rowEl;
}
function createSubagentBlock(parentEl, taskToolId, taskInput) {
  const description = extractTaskDescription(taskInput);
  const info = {
    id: taskToolId,
    description,
    status: "running",
    toolCalls: [],
    isExpanded: false
    // Collapsed by default
  };
  const wrapperEl = parentEl.createDiv({ cls: "claudian-subagent-list" });
  wrapperEl.dataset.subagentId = taskToolId;
  const headerEl = wrapperEl.createDiv({ cls: "claudian-subagent-header" });
  headerEl.setAttribute("tabindex", "0");
  headerEl.setAttribute("role", "button");
  headerEl.setAttribute("aria-expanded", "false");
  headerEl.setAttribute("aria-label", `Subagent task: ${truncateDescription(description)} - click to expand`);
  const iconEl = headerEl.createDiv({ cls: "claudian-subagent-icon" });
  iconEl.setAttribute("aria-hidden", "true");
  (0, import_obsidian6.setIcon)(iconEl, getToolIcon(TOOL_TASK));
  const labelEl = headerEl.createDiv({ cls: "claudian-subagent-label" });
  labelEl.setText(truncateDescription(description));
  const countEl = headerEl.createDiv({ cls: "claudian-subagent-count" });
  countEl.setText("0 tool uses");
  const statusEl = headerEl.createDiv({ cls: "claudian-subagent-status status-running" });
  statusEl.setAttribute("aria-label", "Status: running");
  const contentEl = wrapperEl.createDiv({ cls: "claudian-subagent-content" });
  setupCollapsible(wrapperEl, headerEl, contentEl, info);
  return {
    wrapperEl,
    contentEl,
    headerEl,
    labelEl,
    countEl,
    statusEl,
    info,
    currentToolEl: null,
    currentResultEl: null
  };
}
function addSubagentToolCall(state, toolCall) {
  state.info.toolCalls.push(toolCall);
  const toolCount = state.info.toolCalls.length;
  state.countEl.setText(`${toolCount} tool uses`);
  state.contentEl.empty();
  state.currentResultEl = null;
  const itemEl = state.contentEl.createDiv({
    cls: `claudian-subagent-tool-item claudian-subagent-tool-${toolCall.status}`
  });
  itemEl.dataset.toolId = toolCall.id;
  state.currentToolEl = itemEl;
  const toolRowEl = itemEl.createDiv({ cls: "claudian-subagent-tool-row" });
  const labelEl = toolRowEl.createDiv({ cls: "claudian-subagent-tool-text" });
  labelEl.setText(getToolLabel(toolCall.name, toolCall.input));
}
function updateSubagentToolResult(state, toolId, toolCall) {
  const idx = state.info.toolCalls.findIndex((tc) => tc.id === toolId);
  if (idx !== -1) {
    state.info.toolCalls[idx] = toolCall;
  }
  if (state.currentToolEl && state.currentToolEl.dataset.toolId === toolId) {
    state.currentToolEl.className = `claudian-subagent-tool-item claudian-subagent-tool-${toolCall.status}`;
    if (toolCall.result) {
      if (!state.currentResultEl) {
        state.currentResultEl = state.currentToolEl.createDiv({ cls: "claudian-subagent-tool-result" });
        const bulletEl = state.currentResultEl.createDiv({ cls: "claudian-subagent-bullet" });
        bulletEl.setText("\u2022");
        const textEl = state.currentResultEl.createDiv({ cls: "claudian-subagent-result-text" });
        textEl.setText(truncateResult(toolCall.result));
      } else {
        const textEl = state.currentResultEl.querySelector(".claudian-subagent-result-text");
        if (textEl) {
          textEl.setText(truncateResult(toolCall.result));
        }
      }
    }
  }
}
function finalizeSubagentBlock(state, result, isError) {
  state.info.status = isError ? "error" : "completed";
  state.info.result = result;
  state.labelEl.setText(truncateDescription(state.info.description));
  const toolCount = state.info.toolCalls.length;
  state.countEl.setText(`${toolCount} tool uses`);
  state.statusEl.className = "claudian-subagent-status";
  state.statusEl.addClass(`status-${state.info.status}`);
  state.statusEl.empty();
  if (state.info.status === "completed") {
    (0, import_obsidian6.setIcon)(state.statusEl, "check");
  } else {
    (0, import_obsidian6.setIcon)(state.statusEl, "x");
  }
  if (state.info.status === "completed") {
    state.wrapperEl.addClass("done");
  } else if (state.info.status === "error") {
    state.wrapperEl.addClass("error");
  }
  state.contentEl.empty();
  state.currentToolEl = null;
  state.currentResultEl = null;
  createStatusRow(state.contentEl, isError ? "ERROR" : "DONE");
}
function renderStoredSubagent(parentEl, subagent) {
  const wrapperEl = parentEl.createDiv({ cls: "claudian-subagent-list" });
  if (subagent.status === "completed") {
    wrapperEl.addClass("done");
  } else if (subagent.status === "error") {
    wrapperEl.addClass("error");
  }
  wrapperEl.dataset.subagentId = subagent.id;
  const toolCount = subagent.toolCalls.length;
  const headerEl = wrapperEl.createDiv({ cls: "claudian-subagent-header" });
  headerEl.setAttribute("tabindex", "0");
  headerEl.setAttribute("role", "button");
  headerEl.setAttribute("aria-label", `Subagent task: ${truncateDescription(subagent.description)} - ${toolCount} tool uses - Status: ${subagent.status}`);
  const iconEl = headerEl.createDiv({ cls: "claudian-subagent-icon" });
  iconEl.setAttribute("aria-hidden", "true");
  (0, import_obsidian6.setIcon)(iconEl, getToolIcon(TOOL_TASK));
  const labelEl = headerEl.createDiv({ cls: "claudian-subagent-label" });
  labelEl.setText(truncateDescription(subagent.description));
  const countEl = headerEl.createDiv({ cls: "claudian-subagent-count" });
  countEl.setText(`${toolCount} tool uses`);
  const statusEl = headerEl.createDiv({ cls: `claudian-subagent-status status-${subagent.status}` });
  statusEl.setAttribute("aria-label", `Status: ${subagent.status}`);
  if (subagent.status === "completed") {
    (0, import_obsidian6.setIcon)(statusEl, "check");
  } else if (subagent.status === "error") {
    (0, import_obsidian6.setIcon)(statusEl, "x");
  }
  const contentEl = wrapperEl.createDiv({ cls: "claudian-subagent-content" });
  if (subagent.status === "completed" || subagent.status === "error") {
    createStatusRow(contentEl, subagent.status === "error" ? "ERROR" : "DONE");
  } else {
    const lastTool = subagent.toolCalls[subagent.toolCalls.length - 1];
    if (lastTool) {
      const itemEl = contentEl.createDiv({
        cls: `claudian-subagent-tool-item claudian-subagent-tool-${lastTool.status}`
      });
      const toolRowEl = itemEl.createDiv({ cls: "claudian-subagent-tool-row" });
      const toolLabelEl = toolRowEl.createDiv({ cls: "claudian-subagent-tool-text" });
      toolLabelEl.setText(getToolLabel(lastTool.name, lastTool.input));
      if (lastTool.result) {
        const resultEl = itemEl.createDiv({ cls: "claudian-subagent-tool-result" });
        const bulletEl = resultEl.createDiv({ cls: "claudian-subagent-bullet" });
        bulletEl.setText("\u2022");
        const textEl = resultEl.createDiv({ cls: "claudian-subagent-result-text" });
        textEl.setText(truncateResult(lastTool.result));
      }
    }
  }
  const state = { isExpanded: false };
  setupCollapsible(wrapperEl, headerEl, contentEl, state);
  return wrapperEl;
}
function setAsyncWrapperStatus(wrapperEl, status) {
  const classes = ["pending", "running", "awaiting", "completed", "error", "orphaned", "async"];
  classes.forEach((cls) => wrapperEl.removeClass(cls));
  wrapperEl.addClass("async");
  wrapperEl.addClass(status);
}
function getAsyncDisplayStatus(asyncStatus) {
  switch (asyncStatus) {
    case "completed":
      return "completed";
    case "error":
      return "error";
    case "orphaned":
      return "orphaned";
    default:
      return "running";
  }
}
function getAsyncStatusText(asyncStatus) {
  switch (asyncStatus) {
    case "pending":
      return "Initializing";
    case "completed":
      return "";
    // Just show tick icon, no text
    case "error":
      return "Error";
    case "orphaned":
      return "Orphaned";
    default:
      return "Running in background";
  }
}
function getAsyncStatusAriaLabel(asyncStatus) {
  switch (asyncStatus) {
    case "pending":
      return "Initializing";
    case "completed":
      return "Completed";
    case "error":
      return "Error";
    case "orphaned":
      return "Orphaned";
    default:
      return "Running in background";
  }
}
function updateAsyncLabel(state) {
  state.labelEl.setText(truncateDescription(state.info.description));
}
function truncatePrompt(prompt, maxLength = 200) {
  if (!prompt) return "";
  if (prompt.length <= maxLength) return prompt;
  return prompt.substring(0, maxLength) + "...";
}
function createAsyncSubagentBlock(parentEl, taskToolId, taskInput) {
  const description = taskInput.description || "Background task";
  const prompt = taskInput.prompt || "";
  const info = {
    id: taskToolId,
    description,
    prompt,
    mode: "async",
    status: "running",
    toolCalls: [],
    isExpanded: false,
    asyncStatus: "pending"
  };
  const wrapperEl = parentEl.createDiv({ cls: "claudian-subagent-list" });
  setAsyncWrapperStatus(wrapperEl, "pending");
  wrapperEl.dataset.asyncSubagentId = taskToolId;
  const headerEl = wrapperEl.createDiv({ cls: "claudian-subagent-header" });
  headerEl.setAttribute("tabindex", "0");
  headerEl.setAttribute("role", "button");
  headerEl.setAttribute("aria-expanded", "false");
  headerEl.setAttribute("aria-label", `Background task: ${description} - click to expand`);
  const iconEl = headerEl.createDiv({ cls: "claudian-subagent-icon" });
  iconEl.setAttribute("aria-hidden", "true");
  (0, import_obsidian6.setIcon)(iconEl, getToolIcon(TOOL_TASK));
  const labelEl = headerEl.createDiv({ cls: "claudian-subagent-label" });
  labelEl.setText(truncateDescription(description));
  const statusTextEl = headerEl.createDiv({ cls: "claudian-subagent-status-text" });
  statusTextEl.setText("Initializing");
  const statusEl = headerEl.createDiv({ cls: "claudian-subagent-status status-running" });
  statusEl.setAttribute("aria-label", "Status: running");
  const contentEl = wrapperEl.createDiv({ cls: "claudian-subagent-content" });
  createStatusRow(contentEl, truncatePrompt(prompt) || "Background task", { textClass: "claudian-async-prompt" });
  setupCollapsible(wrapperEl, headerEl, contentEl, info);
  return {
    wrapperEl,
    contentEl,
    headerEl,
    labelEl,
    statusTextEl,
    statusEl,
    info
  };
}
function updateAsyncSubagentRunning(state, agentId) {
  state.info.asyncStatus = "running";
  state.info.agentId = agentId;
  setAsyncWrapperStatus(state.wrapperEl, "running");
  updateAsyncLabel(state);
  state.statusTextEl.setText("Running in background");
  state.contentEl.empty();
  createStatusRow(state.contentEl, truncatePrompt(state.info.prompt || "") || "Background task", { textClass: "claudian-async-prompt" });
}
function finalizeAsyncSubagent(state, result, isError) {
  state.info.asyncStatus = isError ? "error" : "completed";
  state.info.status = isError ? "error" : "completed";
  state.info.result = result;
  setAsyncWrapperStatus(state.wrapperEl, isError ? "error" : "completed");
  updateAsyncLabel(state);
  state.statusTextEl.setText(isError ? "Error" : "");
  state.statusEl.className = "claudian-subagent-status";
  state.statusEl.addClass(`status-${isError ? "error" : "completed"}`);
  state.statusEl.empty();
  if (isError) {
    (0, import_obsidian6.setIcon)(state.statusEl, "x");
  } else {
    (0, import_obsidian6.setIcon)(state.statusEl, "check");
  }
  if (isError) {
    state.wrapperEl.addClass("error");
  } else {
    state.wrapperEl.addClass("done");
  }
  state.contentEl.empty();
  let displayText;
  if (isError && result) {
    const truncated = result.length > 80 ? result.substring(0, 80) + "..." : result;
    displayText = `ERROR: ${truncated}`;
  } else {
    displayText = isError ? "ERROR" : "DONE";
  }
  createStatusRow(state.contentEl, displayText);
}
function markAsyncSubagentOrphaned(state) {
  state.info.asyncStatus = "orphaned";
  state.info.status = "error";
  state.info.result = "Conversation ended before task completed";
  setAsyncWrapperStatus(state.wrapperEl, "orphaned");
  updateAsyncLabel(state);
  state.statusTextEl.setText("Orphaned");
  state.statusEl.className = "claudian-subagent-status status-error";
  state.statusEl.empty();
  (0, import_obsidian6.setIcon)(state.statusEl, "alert-circle");
  state.wrapperEl.addClass("error");
  state.wrapperEl.addClass("orphaned");
  state.contentEl.empty();
  createStatusRow(state.contentEl, "\u26A0\uFE0F Task orphaned", { rowClass: "claudian-async-orphaned" });
}
function renderStoredAsyncSubagent(parentEl, subagent) {
  const wrapperEl = parentEl.createDiv({ cls: "claudian-subagent-list" });
  const displayStatus = getAsyncDisplayStatus(subagent.asyncStatus);
  setAsyncWrapperStatus(wrapperEl, displayStatus);
  if (displayStatus === "completed") {
    wrapperEl.addClass("done");
  } else if (displayStatus === "error" || displayStatus === "orphaned") {
    wrapperEl.addClass("error");
  }
  wrapperEl.dataset.asyncSubagentId = subagent.id;
  const statusText = getAsyncStatusText(subagent.asyncStatus);
  const statusAriaLabel = getAsyncStatusAriaLabel(subagent.asyncStatus);
  const headerEl = wrapperEl.createDiv({ cls: "claudian-subagent-header" });
  headerEl.setAttribute("tabindex", "0");
  headerEl.setAttribute("role", "button");
  headerEl.setAttribute("aria-expanded", "false");
  headerEl.setAttribute("aria-label", `Background task: ${subagent.description} - ${statusAriaLabel} - click to expand`);
  const iconEl = headerEl.createDiv({ cls: "claudian-subagent-icon" });
  iconEl.setAttribute("aria-hidden", "true");
  (0, import_obsidian6.setIcon)(iconEl, getToolIcon(TOOL_TASK));
  const labelEl = headerEl.createDiv({ cls: "claudian-subagent-label" });
  labelEl.setText(truncateDescription(subagent.description));
  const statusTextEl = headerEl.createDiv({ cls: "claudian-subagent-status-text" });
  statusTextEl.setText(statusText);
  let statusIconClass;
  switch (displayStatus) {
    case "error":
    case "orphaned":
      statusIconClass = "status-error";
      break;
    case "completed":
      statusIconClass = "status-completed";
      break;
    default:
      statusIconClass = "status-running";
  }
  const statusEl = headerEl.createDiv({ cls: `claudian-subagent-status ${statusIconClass}` });
  statusEl.setAttribute("aria-label", `Status: ${statusAriaLabel}`);
  switch (displayStatus) {
    case "completed":
      (0, import_obsidian6.setIcon)(statusEl, "check");
      break;
    case "error":
      (0, import_obsidian6.setIcon)(statusEl, "x");
      break;
    case "orphaned":
      (0, import_obsidian6.setIcon)(statusEl, "alert-circle");
      break;
  }
  const contentEl = wrapperEl.createDiv({ cls: "claudian-subagent-content" });
  switch (displayStatus) {
    case "completed":
      createStatusRow(contentEl, "DONE");
      break;
    case "error":
      createStatusRow(contentEl, "ERROR");
      break;
    case "orphaned":
      createStatusRow(contentEl, "\u26A0\uFE0F Task orphaned");
      break;
    default:
      createStatusRow(contentEl, truncatePrompt(subagent.prompt || "") || "Background task", { textClass: "claudian-async-prompt" });
  }
  const state = { isExpanded: false };
  setupCollapsible(wrapperEl, headerEl, contentEl, state);
  return wrapperEl;
}

// src/features/chat/rendering/ThinkingBlockRenderer.ts
function createThinkingBlock(parentEl, renderContent) {
  const wrapperEl = parentEl.createDiv({ cls: "claudian-thinking-block" });
  const header = wrapperEl.createDiv({ cls: "claudian-thinking-header" });
  header.setAttribute("tabindex", "0");
  header.setAttribute("role", "button");
  header.setAttribute("aria-expanded", "false");
  header.setAttribute("aria-label", "Extended thinking - click to expand");
  const labelEl = header.createSpan({ cls: "claudian-thinking-label" });
  const startTime = Date.now();
  labelEl.setText("Thinking 0s...");
  const timerInterval = setInterval(() => {
    const elapsed = Math.floor((Date.now() - startTime) / 1e3);
    labelEl.setText(`Thinking ${elapsed}s...`);
  }, 1e3);
  const contentEl = wrapperEl.createDiv({ cls: "claudian-thinking-content" });
  const state = {
    wrapperEl,
    contentEl,
    labelEl,
    content: "",
    startTime,
    timerInterval,
    isExpanded: false
  };
  setupCollapsible(wrapperEl, header, contentEl, state);
  return state;
}
async function appendThinkingContent(state, content, renderContent) {
  state.content += content;
  await renderContent(state.contentEl, state.content);
}
function finalizeThinkingBlock(state) {
  if (state.timerInterval) {
    clearInterval(state.timerInterval);
    state.timerInterval = null;
  }
  const durationSeconds = Math.floor((Date.now() - state.startTime) / 1e3);
  state.labelEl.setText(`Thought for ${durationSeconds}s`);
  const header = state.wrapperEl.querySelector(".claudian-thinking-header");
  if (header) {
    collapseElement(state.wrapperEl, header, state.contentEl, state);
  }
  return durationSeconds;
}
function cleanupThinkingBlock(state) {
  if (state == null ? void 0 : state.timerInterval) {
    clearInterval(state.timerInterval);
  }
}
function renderStoredThinkingBlock(parentEl, content, durationSeconds, renderContent) {
  const wrapperEl = parentEl.createDiv({ cls: "claudian-thinking-block" });
  const header = wrapperEl.createDiv({ cls: "claudian-thinking-header" });
  header.setAttribute("tabindex", "0");
  header.setAttribute("role", "button");
  header.setAttribute("aria-label", "Extended thinking - click to expand");
  const labelEl = header.createSpan({ cls: "claudian-thinking-label" });
  const labelText = durationSeconds !== void 0 ? `Thought for ${durationSeconds}s` : "Thought";
  labelEl.setText(labelText);
  const contentEl = wrapperEl.createDiv({ cls: "claudian-thinking-content" });
  renderContent(contentEl, content);
  const state = { isExpanded: false };
  setupCollapsible(wrapperEl, header, contentEl, state);
  return wrapperEl;
}

// src/features/chat/rendering/WriteEditRenderer.ts
var import_obsidian7 = require("obsidian");

// src/features/chat/rendering/DiffRenderer.ts
function splitIntoHunks(diffLines, contextLines = 3) {
  if (diffLines.length === 0) return [];
  const changedIndices = [];
  for (let i2 = 0; i2 < diffLines.length; i2++) {
    if (diffLines[i2].type !== "equal") {
      changedIndices.push(i2);
    }
  }
  if (changedIndices.length === 0) return [];
  const ranges = [];
  for (const idx of changedIndices) {
    const start = Math.max(0, idx - contextLines);
    const end = Math.min(diffLines.length - 1, idx + contextLines);
    if (ranges.length > 0 && start <= ranges[ranges.length - 1].end + 1) {
      ranges[ranges.length - 1].end = end;
    } else {
      ranges.push({ start, end });
    }
  }
  const hunks = [];
  for (const range of ranges) {
    const lines = diffLines.slice(range.start, range.end + 1);
    let oldStart = 1;
    let newStart = 1;
    for (let i2 = 0; i2 < range.start; i2++) {
      const line = diffLines[i2];
      if (line.type === "equal" || line.type === "delete") oldStart++;
      if (line.type === "equal" || line.type === "insert") newStart++;
    }
    hunks.push({ lines, oldStart, newStart });
  }
  return hunks;
}
var NEW_FILE_DISPLAY_CAP = 20;
function renderDiffContent(containerEl, diffLines, contextLines = 3) {
  containerEl.empty();
  const allInserts = diffLines.length > 0 && diffLines.every((l3) => l3.type === "insert");
  if (allInserts && diffLines.length > NEW_FILE_DISPLAY_CAP) {
    const hunkEl = containerEl.createDiv({ cls: "claudian-diff-hunk" });
    for (const line of diffLines.slice(0, NEW_FILE_DISPLAY_CAP)) {
      const lineEl = hunkEl.createDiv({ cls: "claudian-diff-line claudian-diff-insert" });
      const prefixEl = lineEl.createSpan({ cls: "claudian-diff-prefix" });
      prefixEl.setText("+");
      const contentEl = lineEl.createSpan({ cls: "claudian-diff-text" });
      contentEl.setText(line.text || " ");
    }
    const remaining = diffLines.length - NEW_FILE_DISPLAY_CAP;
    const separator = containerEl.createDiv({ cls: "claudian-diff-separator" });
    separator.setText(`... ${remaining} more lines`);
    return;
  }
  const hunks = splitIntoHunks(diffLines, contextLines);
  if (hunks.length === 0) {
    const noChanges = containerEl.createDiv({ cls: "claudian-diff-no-changes" });
    noChanges.setText("No changes");
    return;
  }
  hunks.forEach((hunk, hunkIndex) => {
    if (hunkIndex > 0) {
      const separator = containerEl.createDiv({ cls: "claudian-diff-separator" });
      separator.setText("...");
    }
    const hunkEl = containerEl.createDiv({ cls: "claudian-diff-hunk" });
    for (const line of hunk.lines) {
      const lineEl = hunkEl.createDiv({ cls: `claudian-diff-line claudian-diff-${line.type}` });
      const prefix = line.type === "insert" ? "+" : line.type === "delete" ? "-" : " ";
      const prefixEl = lineEl.createSpan({ cls: "claudian-diff-prefix" });
      prefixEl.setText(prefix);
      const contentEl = lineEl.createSpan({ cls: "claudian-diff-text" });
      contentEl.setText(line.text || " ");
    }
  });
}

// src/features/chat/rendering/WriteEditRenderer.ts
function shortenPath2(filePath, maxLength = 40) {
  if (!filePath) return "file";
  const normalized = filePath.replace(/\\/g, "/");
  if (normalized.length <= maxLength) return normalized;
  const parts = normalized.split("/");
  if (parts.length <= 2) {
    return "..." + normalized.slice(-maxLength + 3);
  }
  const filename = parts[parts.length - 1];
  const firstDir = parts[0];
  const available = maxLength - firstDir.length - filename.length - 5;
  if (available < 0) {
    return "..." + filename.slice(-maxLength + 3);
  }
  return `${firstDir}/.../${filename}`;
}
function renderDiffStats(statsEl, stats) {
  if (stats.added > 0) {
    const addedEl = statsEl.createSpan({ cls: "added" });
    addedEl.setText(`+${stats.added}`);
  }
  if (stats.removed > 0) {
    if (stats.added > 0) {
      statsEl.createSpan({ text: " " });
    }
    const removedEl = statsEl.createSpan({ cls: "removed" });
    removedEl.setText(`-${stats.removed}`);
  }
}
function createWriteEditBlock(parentEl, toolCall) {
  const filePath = toolCall.input.file_path || "file";
  const toolName = toolCall.name;
  const wrapperEl = parentEl.createDiv({ cls: "claudian-write-edit-block" });
  wrapperEl.dataset.toolId = toolCall.id;
  const headerEl = wrapperEl.createDiv({ cls: "claudian-write-edit-header" });
  headerEl.setAttribute("tabindex", "0");
  headerEl.setAttribute("role", "button");
  headerEl.setAttribute("aria-label", `${toolName}: ${shortenPath2(filePath)} - click to expand`);
  const iconEl = headerEl.createDiv({ cls: "claudian-write-edit-icon" });
  iconEl.setAttribute("aria-hidden", "true");
  (0, import_obsidian7.setIcon)(iconEl, getToolIcon(toolName));
  const labelEl = headerEl.createDiv({ cls: "claudian-write-edit-label" });
  labelEl.setText(`${toolName}: ${shortenPath2(filePath)}`);
  const statsEl = headerEl.createDiv({ cls: "claudian-write-edit-stats" });
  const statusEl = headerEl.createDiv({ cls: "claudian-write-edit-status status-running" });
  statusEl.setAttribute("aria-label", "Status: running");
  const contentEl = wrapperEl.createDiv({ cls: "claudian-write-edit-content" });
  const loadingRow = contentEl.createDiv({ cls: "claudian-write-edit-diff-row" });
  const loadingEl = loadingRow.createDiv({ cls: "claudian-write-edit-loading" });
  loadingEl.setText("Writing...");
  const state = {
    wrapperEl,
    contentEl,
    headerEl,
    labelEl,
    statsEl,
    statusEl,
    toolCall,
    isExpanded: false
  };
  setupCollapsible(wrapperEl, headerEl, contentEl, state);
  return state;
}
function updateWriteEditWithDiff(state, diffData) {
  state.statsEl.empty();
  state.contentEl.empty();
  const { diffLines, stats } = diffData;
  state.diffLines = diffLines;
  renderDiffStats(state.statsEl, stats);
  const row = state.contentEl.createDiv({ cls: "claudian-write-edit-diff-row" });
  const diffEl = row.createDiv({ cls: "claudian-write-edit-diff" });
  renderDiffContent(diffEl, diffLines);
}
function finalizeWriteEditBlock(state, isError) {
  state.statusEl.className = "claudian-write-edit-status";
  state.statusEl.empty();
  if (isError) {
    state.statusEl.addClass("status-error");
    (0, import_obsidian7.setIcon)(state.statusEl, "x");
    state.statusEl.setAttribute("aria-label", "Status: error");
    if (!state.diffLines) {
      state.contentEl.empty();
      const row = state.contentEl.createDiv({ cls: "claudian-write-edit-diff-row" });
      const errorEl = row.createDiv({ cls: "claudian-write-edit-error" });
      errorEl.setText(state.toolCall.result || "Error");
    }
  } else if (!state.diffLines) {
    state.contentEl.empty();
    const row = state.contentEl.createDiv({ cls: "claudian-write-edit-diff-row" });
    const doneEl = row.createDiv({ cls: "claudian-write-edit-done-text" });
    doneEl.setText("DONE");
  }
  if (isError) {
    state.wrapperEl.addClass("error");
  } else {
    state.wrapperEl.addClass("done");
  }
}
function renderStoredWriteEdit(parentEl, toolCall) {
  const filePath = toolCall.input.file_path || "file";
  const toolName = toolCall.name;
  const isError = toolCall.status === "error" || toolCall.status === "blocked";
  const wrapperEl = parentEl.createDiv({ cls: "claudian-write-edit-block" });
  if (isError) {
    wrapperEl.addClass("error");
  } else if (toolCall.status === "completed") {
    wrapperEl.addClass("done");
  }
  wrapperEl.dataset.toolId = toolCall.id;
  const headerEl = wrapperEl.createDiv({ cls: "claudian-write-edit-header" });
  headerEl.setAttribute("tabindex", "0");
  headerEl.setAttribute("role", "button");
  const iconEl = headerEl.createDiv({ cls: "claudian-write-edit-icon" });
  iconEl.setAttribute("aria-hidden", "true");
  (0, import_obsidian7.setIcon)(iconEl, getToolIcon(toolName));
  const labelEl = headerEl.createDiv({ cls: "claudian-write-edit-label" });
  labelEl.setText(`${toolName}: ${shortenPath2(filePath)}`);
  const statsEl = headerEl.createDiv({ cls: "claudian-write-edit-stats" });
  if (toolCall.diffData) {
    renderDiffStats(statsEl, toolCall.diffData.stats);
  }
  const statusEl = headerEl.createDiv({ cls: "claudian-write-edit-status" });
  if (isError) {
    statusEl.addClass("status-error");
    (0, import_obsidian7.setIcon)(statusEl, "x");
  }
  const contentEl = wrapperEl.createDiv({ cls: "claudian-write-edit-content" });
  const row = contentEl.createDiv({ cls: "claudian-write-edit-diff-row" });
  if (toolCall.diffData && toolCall.diffData.diffLines.length > 0) {
    const diffEl = row.createDiv({ cls: "claudian-write-edit-diff" });
    renderDiffContent(diffEl, toolCall.diffData.diffLines);
  } else if (isError && toolCall.result) {
    const errorEl = row.createDiv({ cls: "claudian-write-edit-error" });
    errorEl.setText(toolCall.result);
  } else {
    const doneEl = row.createDiv({ cls: "claudian-write-edit-done-text" });
    doneEl.setText(isError ? "ERROR" : "DONE");
  }
  const state = { isExpanded: false };
  setupCollapsible(wrapperEl, headerEl, contentEl, state);
  return wrapperEl;
}

// src/features/chat/rendering/MessageRenderer.ts
var _MessageRenderer = class _MessageRenderer {
  constructor(plugin, component, messagesEl) {
    this.app = plugin.app;
    this.plugin = plugin;
    this.component = component;
    this.messagesEl = messagesEl;
    registerFileLinkHandler(this.app, this.messagesEl, this.component);
  }
  /** Sets the messages container element. */
  setMessagesEl(el) {
    this.messagesEl = el;
  }
  // ============================================
  // Streaming Message Rendering
  // ============================================
  /**
   * Adds a new message to the chat during streaming.
   * Returns the message element for content updates.
   */
  addMessage(msg) {
    var _a, _b;
    if (msg.role === "user" && msg.images && msg.images.length > 0) {
      this.renderMessageImages(this.messagesEl, msg.images);
    }
    if (msg.role === "user") {
      const textToShow = (_a = msg.displayContent) != null ? _a : msg.content;
      if (!textToShow) {
        this.scrollToBottom();
        const lastChild = this.messagesEl.lastElementChild;
        return lastChild != null ? lastChild : this.messagesEl;
      }
    }
    const msgEl = this.messagesEl.createDiv({
      cls: `claudian-message claudian-message-${msg.role}`
    });
    const contentEl = msgEl.createDiv({ cls: "claudian-message-content" });
    if (msg.role === "user") {
      const textToShow = (_b = msg.displayContent) != null ? _b : msg.content;
      if (textToShow) {
        const textEl = contentEl.createDiv({ cls: "claudian-text-block" });
        void this.renderContent(textEl, textToShow);
      }
    }
    this.scrollToBottom();
    return msgEl;
  }
  // ============================================
  // Stored Message Rendering (Batch/Replay)
  // ============================================
  /**
   * Renders all messages for conversation load/switch.
   * @param messages Array of messages to render
   * @param getGreeting Function to get greeting text
   * @returns The newly created welcome element
   */
  renderMessages(messages, getGreeting) {
    this.messagesEl.empty();
    const newWelcomeEl = this.messagesEl.createDiv({ cls: "claudian-welcome" });
    newWelcomeEl.createDiv({ cls: "claudian-welcome-greeting", text: getGreeting() });
    for (const msg of messages) {
      this.renderStoredMessage(msg);
    }
    this.scrollToBottom();
    return newWelcomeEl;
  }
  /**
   * Renders a persisted message from history.
   */
  renderStoredMessage(msg) {
    var _a, _b;
    if (msg.isInterrupt) {
      this.renderInterruptMessage();
      return;
    }
    if (msg.isRebuiltContext) {
      return;
    }
    if (msg.role === "user" && msg.images && msg.images.length > 0) {
      this.renderMessageImages(this.messagesEl, msg.images);
    }
    if (msg.role === "user") {
      const textToShow = (_a = msg.displayContent) != null ? _a : msg.content;
      if (!textToShow) {
        return;
      }
    }
    const msgEl = this.messagesEl.createDiv({
      cls: `claudian-message claudian-message-${msg.role}`
    });
    const contentEl = msgEl.createDiv({ cls: "claudian-message-content" });
    if (msg.role === "user") {
      const textToShow = (_b = msg.displayContent) != null ? _b : msg.content;
      if (textToShow) {
        const textEl = contentEl.createDiv({ cls: "claudian-text-block" });
        void this.renderContent(textEl, textToShow);
      }
    } else if (msg.role === "assistant") {
      this.renderAssistantContent(msg, contentEl);
    }
  }
  /**
   * Renders an interrupt indicator (stored interrupts from SDK history).
   * Uses the same styling as streaming interrupts.
   */
  renderInterruptMessage() {
    const msgEl = this.messagesEl.createDiv({ cls: "claudian-message claudian-message-assistant" });
    const contentEl = msgEl.createDiv({ cls: "claudian-message-content" });
    const textEl = contentEl.createDiv({ cls: "claudian-text-block" });
    textEl.innerHTML = '<span class="claudian-interrupted">Interrupted</span> <span class="claudian-interrupted-hint">\xB7 What should Claudian do instead?</span>';
  }
  /**
   * Renders assistant message content (content blocks or fallback).
   */
  renderAssistantContent(msg, contentEl) {
    var _a, _b;
    if (msg.contentBlocks && msg.contentBlocks.length > 0) {
      for (const block of msg.contentBlocks) {
        if (block.type === "thinking") {
          renderStoredThinkingBlock(
            contentEl,
            block.content,
            block.durationSeconds,
            (el, md) => this.renderContent(el, md)
          );
        } else if (block.type === "text") {
          if (!block.content || !block.content.trim()) {
            continue;
          }
          const textEl = contentEl.createDiv({ cls: "claudian-text-block" });
          void this.renderContent(textEl, block.content);
          this.addTextCopyButton(textEl, block.content);
        } else if (block.type === "tool_use") {
          const toolCall = (_a = msg.toolCalls) == null ? void 0 : _a.find((tc) => tc.id === block.toolId);
          if (toolCall) {
            this.renderToolCall(contentEl, toolCall);
          }
        } else if (block.type === "subagent") {
          const subagent = (_b = msg.subagents) == null ? void 0 : _b.find((s) => s.id === block.subagentId);
          if (subagent) {
            const mode = block.mode || subagent.mode || "sync";
            if (mode === "async") {
              renderStoredAsyncSubagent(contentEl, subagent);
            } else {
              renderStoredSubagent(contentEl, subagent);
            }
          }
        }
      }
    } else {
      if (msg.content) {
        const textEl = contentEl.createDiv({ cls: "claudian-text-block" });
        void this.renderContent(textEl, msg.content);
        this.addTextCopyButton(textEl, msg.content);
      }
      if (msg.toolCalls) {
        for (const toolCall of msg.toolCalls) {
          this.renderToolCall(contentEl, toolCall);
        }
      }
    }
    if (msg.durationSeconds && msg.durationSeconds > 0) {
      const flavorWord = msg.durationFlavorWord || "Baked";
      const footerEl = contentEl.createDiv({ cls: "claudian-response-footer" });
      footerEl.createSpan({
        text: `* ${flavorWord} for ${formatDurationMmSs(msg.durationSeconds)}`,
        cls: "claudian-baked-duration"
      });
    }
  }
  /**
   * Renders a tool call with special handling for Write/Edit and Task (subagent).
   * TaskOutput is hidden as it's an internal tool for async subagent communication.
   */
  renderToolCall(contentEl, toolCall) {
    var _a;
    if (toolCall.name === TOOL_AGENT_OUTPUT) {
      return;
    }
    if (isWriteEditTool(toolCall.name)) {
      renderStoredWriteEdit(contentEl, toolCall);
    } else if (toolCall.name === TOOL_TASK) {
      let status;
      switch (toolCall.status) {
        case "completed":
          status = "completed";
          break;
        case "error":
          status = "error";
          break;
        default:
          status = "running";
      }
      const subagentInfo = {
        id: toolCall.id,
        description: ((_a = toolCall.input) == null ? void 0 : _a.description) || "Subagent task",
        status,
        toolCalls: [],
        isExpanded: false,
        result: toolCall.result
      };
      renderStoredSubagent(contentEl, subagentInfo);
    } else {
      renderStoredToolCall(contentEl, toolCall);
    }
  }
  // ============================================
  // Image Rendering
  // ============================================
  /**
   * Renders image attachments above a message.
   */
  renderMessageImages(containerEl, images) {
    const imagesEl = containerEl.createDiv({ cls: "claudian-message-images" });
    for (const image of images) {
      const imageWrapper = imagesEl.createDiv({ cls: "claudian-message-image" });
      const imgEl = imageWrapper.createEl("img", {
        attr: {
          alt: image.name
        }
      });
      void this.setImageSrc(imgEl, image);
      imgEl.addEventListener("click", () => {
        void this.showFullImage(image);
      });
    }
  }
  /**
   * Shows full-size image in modal overlay.
   */
  showFullImage(image) {
    const dataUri = `data:${image.mediaType};base64,${image.data}`;
    const overlay = document.body.createDiv({ cls: "claudian-image-modal-overlay" });
    const modal = overlay.createDiv({ cls: "claudian-image-modal" });
    modal.createEl("img", {
      attr: {
        src: dataUri,
        alt: image.name
      }
    });
    const closeBtn = modal.createDiv({ cls: "claudian-image-modal-close" });
    closeBtn.setText("\xD7");
    const handleEsc = (e2) => {
      if (e2.key === "Escape") {
        close();
      }
    };
    const close = () => {
      document.removeEventListener("keydown", handleEsc);
      overlay.remove();
    };
    closeBtn.addEventListener("click", close);
    overlay.addEventListener("click", (e2) => {
      if (e2.target === overlay) close();
    });
    document.addEventListener("keydown", handleEsc);
  }
  /**
   * Sets image src from attachment data.
   */
  setImageSrc(imgEl, image) {
    const dataUri = `data:${image.mediaType};base64,${image.data}`;
    imgEl.setAttribute("src", dataUri);
  }
  // ============================================
  // Content Rendering
  // ============================================
  /**
   * Renders markdown content with code block enhancements.
   */
  async renderContent(el, markdown) {
    el.empty();
    try {
      const processedMarkdown = replaceImageEmbedsWithHtml(
        markdown,
        this.app,
        this.plugin.settings.mediaFolder
      );
      await import_obsidian8.MarkdownRenderer.renderMarkdown(processedMarkdown, el, "", this.component);
      el.querySelectorAll("pre").forEach((pre) => {
        var _a, _b;
        if ((_a = pre.parentElement) == null ? void 0 : _a.classList.contains("claudian-code-wrapper")) return;
        const wrapper = createEl("div", { cls: "claudian-code-wrapper" });
        (_b = pre.parentElement) == null ? void 0 : _b.insertBefore(wrapper, pre);
        wrapper.appendChild(pre);
        const code = pre.querySelector('code[class*="language-"]');
        if (code) {
          const match = code.className.match(/language-(\w+)/);
          if (match) {
            wrapper.classList.add("has-language");
            const label = createEl("span", {
              cls: "claudian-code-lang-label",
              text: match[1]
            });
            wrapper.appendChild(label);
            label.addEventListener("click", async () => {
              try {
                await navigator.clipboard.writeText(code.textContent || "");
                label.setText("copied!");
                setTimeout(() => label.setText(match[1]), 1500);
              } catch (e2) {
              }
            });
          }
        }
        const copyBtn = pre.querySelector(".copy-code-button");
        if (copyBtn) {
          wrapper.appendChild(copyBtn);
        }
      });
      processFileLinks(this.app, el);
    } catch (e2) {
      el.createDiv({
        cls: "claudian-render-error",
        text: "Failed to render message content."
      });
    }
  }
  /**
   * Adds a copy button to a text block.
   * Button shows clipboard icon on hover, changes to "copied!" on click.
   * @param textEl The rendered text element
   * @param markdown The original markdown content to copy
   */
  addTextCopyButton(textEl, markdown) {
    const copyBtn = textEl.createSpan({ cls: "claudian-text-copy-btn" });
    copyBtn.innerHTML = _MessageRenderer.COPY_ICON;
    let feedbackTimeout = null;
    copyBtn.addEventListener("click", async (e2) => {
      e2.stopPropagation();
      try {
        await navigator.clipboard.writeText(markdown);
      } catch (e3) {
        return;
      }
      if (feedbackTimeout) {
        clearTimeout(feedbackTimeout);
      }
      copyBtn.innerHTML = "";
      copyBtn.setText("copied!");
      copyBtn.classList.add("copied");
      feedbackTimeout = setTimeout(() => {
        copyBtn.innerHTML = _MessageRenderer.COPY_ICON;
        copyBtn.classList.remove("copied");
        feedbackTimeout = null;
      }, 1500);
    });
  }
  // ============================================
  // Utilities
  // ============================================
  /** Scrolls messages container to bottom. */
  scrollToBottom() {
    this.messagesEl.scrollTop = this.messagesEl.scrollHeight;
  }
  /** Scrolls to bottom if already near bottom (within threshold). */
  scrollToBottomIfNeeded(threshold = 100) {
    const { scrollTop, scrollHeight, clientHeight } = this.messagesEl;
    const isNearBottom = scrollHeight - scrollTop - clientHeight < threshold;
    if (isNearBottom) {
      requestAnimationFrame(() => {
        this.messagesEl.scrollTop = this.messagesEl.scrollHeight;
      });
    }
  }
};
// ============================================
// Copy Button
// ============================================
/** Clipboard icon SVG for copy button. */
_MessageRenderer.COPY_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>`;
var MessageRenderer = _MessageRenderer;

// src/features/chat/controllers/ConversationController.ts
var ConversationController = class {
  constructor(deps, callbacks = {}) {
    this.deps = deps;
    this.callbacks = callbacks;
  }
  getAgentService() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this.deps).getAgentService) == null ? void 0 : _b.call(_a)) != null ? _c : null;
  }
  // ============================================
  // Conversation Lifecycle
  // ============================================
  /**
   * Resets to entry point state (New Chat).
   *
   * Entry point is a blank UI state - no conversation is created until the
   * first message is sent. This prevents empty conversations cluttering history.
   */
  async createNew(options = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    const { plugin, state, subagentManager } = this.deps;
    const force = !!options.force;
    if (state.isStreaming && !force) return;
    if (state.isCreatingConversation) return;
    if (state.isSwitchingConversation) return;
    state.isCreatingConversation = true;
    try {
      if (force && state.isStreaming) {
        state.cancelRequested = true;
        state.bumpStreamGeneration();
        (_a = this.getAgentService()) == null ? void 0 : _a.cancel();
      }
      if (state.currentConversationId && state.messages.length > 0) {
        await this.save();
      }
      subagentManager.orphanAllActive();
      subagentManager.clear();
      cleanupThinkingBlock(state.currentThinkingState);
      state.currentContentEl = null;
      state.currentTextEl = null;
      state.currentTextContent = "";
      state.currentThinkingState = null;
      state.toolCallElements.clear();
      state.writeEditStates.clear();
      state.isStreaming = false;
      state.currentConversationId = null;
      state.clearMessages();
      state.usage = null;
      state.currentTodos = null;
      state.autoScrollEnabled = (_b = plugin.settings.enableAutoScroll) != null ? _b : true;
      (_c = this.getAgentService()) == null ? void 0 : _c.setSessionId(
        null,
        plugin.settings.persistentExternalContextPaths || []
      );
      const messagesEl = this.deps.getMessagesEl();
      messagesEl.empty();
      const welcomeEl = messagesEl.createDiv({ cls: "claudian-welcome" });
      welcomeEl.createDiv({ cls: "claudian-welcome-greeting", text: this.getGreeting() });
      this.deps.setWelcomeEl(welcomeEl);
      (_d = this.deps.getStatusPanel()) == null ? void 0 : _d.remount();
      (_e = this.deps.getStatusPanel()) == null ? void 0 : _e.clearSubagents();
      this.deps.getInputEl().value = "";
      const fileCtx = this.deps.getFileContextManager();
      fileCtx == null ? void 0 : fileCtx.resetForNewConversation();
      fileCtx == null ? void 0 : fileCtx.autoAttachActiveFile();
      (_f = this.deps.getImageContextManager()) == null ? void 0 : _f.clearImages();
      (_g = this.deps.getMcpServerSelector()) == null ? void 0 : _g.clearEnabled();
      (_h = this.deps.getExternalContextSelector()) == null ? void 0 : _h.clearExternalContexts(
        plugin.settings.persistentExternalContextPaths || []
      );
      this.deps.clearQueuedMessage();
      (_j = (_i = this.callbacks).onNewConversation) == null ? void 0 : _j.call(_i);
    } finally {
      state.isCreatingConversation = false;
    }
  }
  /**
   * Loads the current tab conversation, or starts at entry point if none.
   *
   * Entry point (no conversation) shows welcome screen without
   * creating a conversation. Conversation is created lazily on first message.
   */
  async loadActive() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
    const { plugin, state, renderer } = this.deps;
    const conversationId = state.currentConversationId;
    const conversation = conversationId ? await plugin.getConversationById(conversationId) : null;
    if (!conversation) {
      state.currentConversationId = null;
      state.clearMessages();
      state.usage = null;
      state.currentTodos = null;
      state.autoScrollEnabled = (_a = plugin.settings.enableAutoScroll) != null ? _a : true;
      (_b = this.getAgentService()) == null ? void 0 : _b.setSessionId(
        null,
        plugin.settings.persistentExternalContextPaths || []
      );
      const fileCtx2 = this.deps.getFileContextManager();
      fileCtx2 == null ? void 0 : fileCtx2.resetForNewConversation();
      fileCtx2 == null ? void 0 : fileCtx2.autoAttachActiveFile();
      (_c = this.deps.getExternalContextSelector()) == null ? void 0 : _c.clearExternalContexts(
        plugin.settings.persistentExternalContextPaths || []
      );
      (_d = this.deps.getMcpServerSelector()) == null ? void 0 : _d.clearEnabled();
      const welcomeEl2 = renderer.renderMessages(
        [],
        () => this.getGreeting()
      );
      this.deps.setWelcomeEl(welcomeEl2);
      this.updateWelcomeVisibility();
      (_f = (_e = this.callbacks).onConversationLoaded) == null ? void 0 : _f.call(_e);
      return;
    }
    state.currentConversationId = conversation.id;
    state.messages = [...conversation.messages];
    state.usage = (_g = conversation.usage) != null ? _g : null;
    state.autoScrollEnabled = (_h = plugin.settings.enableAutoScroll) != null ? _h : true;
    state.currentTodos = null;
    (_i = this.deps.getStatusPanel()) == null ? void 0 : _i.clearSubagents();
    const hasMessages = state.messages.length > 0;
    const externalContextPaths = hasMessages ? conversation.externalContextPaths || [] : plugin.settings.persistentExternalContextPaths || [];
    (_k = this.getAgentService()) == null ? void 0 : _k.setSessionId((_j = conversation.sessionId) != null ? _j : null, externalContextPaths);
    const fileCtx = this.deps.getFileContextManager();
    fileCtx == null ? void 0 : fileCtx.resetForLoadedConversation(hasMessages);
    if (conversation.currentNote) {
      fileCtx == null ? void 0 : fileCtx.setCurrentNote(conversation.currentNote);
    } else if (!hasMessages) {
      fileCtx == null ? void 0 : fileCtx.autoAttachActiveFile();
    }
    this.restoreExternalContextPaths(
      conversation.externalContextPaths,
      !hasMessages
    );
    const mcpServerSelector = this.deps.getMcpServerSelector();
    if (conversation.enabledMcpServers && conversation.enabledMcpServers.length > 0) {
      mcpServerSelector == null ? void 0 : mcpServerSelector.setEnabledServers(conversation.enabledMcpServers);
    } else {
      mcpServerSelector == null ? void 0 : mcpServerSelector.clearEnabled();
    }
    const welcomeEl = renderer.renderMessages(
      state.messages,
      () => this.getGreeting()
    );
    this.deps.setWelcomeEl(welcomeEl);
    this.updateWelcomeVisibility();
    (_m = (_l = this.callbacks).onConversationLoaded) == null ? void 0 : _m.call(_l);
  }
  /** Switches to a different conversation. */
  async switchTo(id) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const { plugin, state, renderer, subagentManager } = this.deps;
    if (id === state.currentConversationId) return;
    if (state.isStreaming) return;
    if (state.isSwitchingConversation) return;
    if (state.isCreatingConversation) return;
    state.isSwitchingConversation = true;
    try {
      await this.save();
      subagentManager.orphanAllActive();
      subagentManager.clear();
      const conversation = await plugin.switchConversation(id);
      if (!conversation) {
        return;
      }
      state.currentConversationId = conversation.id;
      state.messages = [...conversation.messages];
      state.usage = (_a = conversation.usage) != null ? _a : null;
      state.autoScrollEnabled = (_b = plugin.settings.enableAutoScroll) != null ? _b : true;
      state.currentTodos = null;
      (_c = this.deps.getStatusPanel()) == null ? void 0 : _c.clearSubagents();
      const hasMessages = state.messages.length > 0;
      const externalContextPaths = hasMessages ? conversation.externalContextPaths || [] : plugin.settings.persistentExternalContextPaths || [];
      (_e = this.getAgentService()) == null ? void 0 : _e.setSessionId((_d = conversation.sessionId) != null ? _d : null, externalContextPaths);
      this.deps.getInputEl().value = "";
      this.deps.clearQueuedMessage();
      const fileCtx = this.deps.getFileContextManager();
      fileCtx == null ? void 0 : fileCtx.resetForLoadedConversation(hasMessages);
      if (conversation.currentNote) {
        fileCtx == null ? void 0 : fileCtx.setCurrentNote(conversation.currentNote);
      }
      this.restoreExternalContextPaths(
        conversation.externalContextPaths,
        !hasMessages
      );
      const mcpServerSelector = this.deps.getMcpServerSelector();
      if (conversation.enabledMcpServers && conversation.enabledMcpServers.length > 0) {
        mcpServerSelector == null ? void 0 : mcpServerSelector.setEnabledServers(conversation.enabledMcpServers);
      } else {
        mcpServerSelector == null ? void 0 : mcpServerSelector.clearEnabled();
      }
      const welcomeEl = renderer.renderMessages(
        state.messages,
        () => this.getGreeting()
      );
      this.deps.setWelcomeEl(welcomeEl);
      (_f = this.deps.getHistoryDropdown()) == null ? void 0 : _f.removeClass("visible");
      this.updateWelcomeVisibility();
      (_h = (_g = this.callbacks).onConversationSwitched) == null ? void 0 : _h.call(_g);
    } finally {
      state.isSwitchingConversation = false;
    }
  }
  /**
   * Saves the current conversation.
   *
   * If we're at an entry point (no conversation yet) and have messages,
   * creates a new conversation first (lazy creation).
   *
   * For native sessions (new conversations with sessionId from SDK),
   * only metadata is saved - the SDK handles message persistence.
   */
  async save(updateLastResponse = false) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    const { plugin, state } = this.deps;
    if (!state.currentConversationId && state.messages.length === 0) {
      return;
    }
    const agentService = this.getAgentService();
    const sessionId = (_a = agentService == null ? void 0 : agentService.getSessionId()) != null ? _a : null;
    const sessionInvalidated = (_c = (_b = agentService == null ? void 0 : agentService.consumeSessionInvalidation) == null ? void 0 : _b.call(agentService)) != null ? _c : false;
    if (!state.currentConversationId && state.messages.length > 0) {
      const conversation2 = await plugin.createConversation(sessionId != null ? sessionId : void 0);
      state.currentConversationId = conversation2.id;
    }
    const fileCtx = this.deps.getFileContextManager();
    const currentNote = (fileCtx == null ? void 0 : fileCtx.getCurrentNotePath()) || void 0;
    const externalContextSelector = this.deps.getExternalContextSelector();
    const externalContextPaths = (_d = externalContextSelector == null ? void 0 : externalContextSelector.getExternalContexts()) != null ? _d : [];
    const mcpServerSelector = this.deps.getMcpServerSelector();
    const enabledMcpServers = mcpServerSelector ? Array.from(mcpServerSelector.getEnabledServers()) : [];
    const conversation = await plugin.getConversationById(state.currentConversationId);
    const wasNative = (_e = conversation == null ? void 0 : conversation.isNative) != null ? _e : false;
    const shouldPromote = !wasNative && !!sessionId;
    const isNative = wasNative || shouldPromote;
    const legacyMessages = (_f = conversation == null ? void 0 : conversation.messages) != null ? _f : [];
    const legacyCutoffAt = shouldPromote ? (_g = legacyMessages[legacyMessages.length - 1]) == null ? void 0 : _g.timestamp : conversation == null ? void 0 : conversation.legacyCutoffAt;
    const oldSdkSessionId = conversation == null ? void 0 : conversation.sdkSessionId;
    const sessionChanged = isNative && sessionId && oldSdkSessionId && sessionId !== oldSdkSessionId;
    const previousSdkSessionIds = sessionChanged ? [.../* @__PURE__ */ new Set([...(conversation == null ? void 0 : conversation.previousSdkSessionIds) || [], oldSdkSessionId])] : conversation == null ? void 0 : conversation.previousSdkSessionIds;
    const updates = {
      // For native sessions, don't persist messages (SDK handles that)
      // For legacy sessions, persist messages as before
      messages: isNative ? state.messages : state.getPersistedMessages(),
      // Preserve existing sessionId when SDK hasn't captured a new one yet
      sessionId: sessionInvalidated ? null : (_h = sessionId != null ? sessionId : conversation == null ? void 0 : conversation.sessionId) != null ? _h : null,
      sdkSessionId: isNative && sessionId ? sessionId : conversation == null ? void 0 : conversation.sdkSessionId,
      previousSdkSessionIds,
      isNative: isNative || void 0,
      legacyCutoffAt,
      sdkMessagesLoaded: isNative ? true : void 0,
      currentNote,
      externalContextPaths: externalContextPaths.length > 0 ? externalContextPaths : void 0,
      usage: (_i = state.usage) != null ? _i : void 0,
      enabledMcpServers: enabledMcpServers.length > 0 ? enabledMcpServers : void 0
    };
    if (updateLastResponse) {
      updates.lastResponseAt = Date.now();
    }
    await plugin.updateConversation(state.currentConversationId, updates);
  }
  /**
   * Restores external context paths based on session state.
   * New or empty sessions get current persistent paths from settings.
   * Sessions with messages restore exactly what was saved.
   */
  restoreExternalContextPaths(savedPaths, isEmptySession) {
    const { plugin } = this.deps;
    const externalContextSelector = this.deps.getExternalContextSelector();
    if (!externalContextSelector) {
      return;
    }
    if (isEmptySession) {
      externalContextSelector.clearExternalContexts(
        plugin.settings.persistentExternalContextPaths || []
      );
    } else {
      externalContextSelector.setExternalContexts(savedPaths || []);
    }
  }
  // ============================================
  // History Dropdown
  // ============================================
  toggleHistoryDropdown() {
    const dropdown = this.deps.getHistoryDropdown();
    if (!dropdown) return;
    const isVisible = dropdown.hasClass("visible");
    if (isVisible) {
      dropdown.removeClass("visible");
    } else {
      this.updateHistoryDropdown();
      dropdown.addClass("visible");
    }
  }
  updateHistoryDropdown() {
    const dropdown = this.deps.getHistoryDropdown();
    if (!dropdown) return;
    this.renderHistoryItems(dropdown, {
      onSelectConversation: (id) => this.switchTo(id),
      onRerender: () => this.updateHistoryDropdown()
    });
  }
  /**
   * Renders history dropdown items to a container.
   * Shared implementation for updateHistoryDropdown() and renderHistoryDropdown().
   */
  renderHistoryItems(container, options) {
    var _a;
    const { plugin, state } = this.deps;
    container.empty();
    const dropdownHeader = container.createDiv({ cls: "claudian-history-header" });
    dropdownHeader.createSpan({ text: "Conversations" });
    const list = container.createDiv({ cls: "claudian-history-list" });
    const allConversations = plugin.getConversationList();
    if (allConversations.length === 0) {
      list.createDiv({ cls: "claudian-history-empty", text: "No conversations" });
      return;
    }
    const conversations = [...allConversations].sort((a, b3) => {
      var _a2, _b;
      return ((_a2 = b3.lastResponseAt) != null ? _a2 : b3.createdAt) - ((_b = a.lastResponseAt) != null ? _b : a.createdAt);
    });
    for (const conv of conversations) {
      const isCurrent = conv.id === state.currentConversationId;
      const item = list.createDiv({
        cls: `claudian-history-item${isCurrent ? " active" : ""}`
      });
      const iconEl = item.createDiv({ cls: "claudian-history-item-icon" });
      (0, import_obsidian9.setIcon)(iconEl, isCurrent ? "message-square-dot" : "message-square");
      const content = item.createDiv({ cls: "claudian-history-item-content" });
      const titleEl = content.createDiv({ cls: "claudian-history-item-title", text: conv.title });
      titleEl.setAttribute("title", conv.title);
      content.createDiv({
        cls: "claudian-history-item-date",
        text: isCurrent ? "Current session" : this.formatDate((_a = conv.lastResponseAt) != null ? _a : conv.createdAt)
      });
      if (!isCurrent) {
        content.addEventListener("click", async (e2) => {
          e2.stopPropagation();
          try {
            await options.onSelectConversation(conv.id);
          } catch (e3) {
          }
        });
      }
      const actions = item.createDiv({ cls: "claudian-history-item-actions" });
      if (conv.titleGenerationStatus === "pending") {
        const loadingEl = actions.createEl("span", { cls: "claudian-action-btn claudian-action-loading" });
        (0, import_obsidian9.setIcon)(loadingEl, "loader-2");
        loadingEl.setAttribute("aria-label", "Generating title...");
      } else if (conv.titleGenerationStatus === "failed") {
        const regenerateBtn = actions.createEl("button", { cls: "claudian-action-btn" });
        (0, import_obsidian9.setIcon)(regenerateBtn, "refresh-cw");
        regenerateBtn.setAttribute("aria-label", "Regenerate title");
        regenerateBtn.addEventListener("click", async (e2) => {
          e2.stopPropagation();
          try {
            await this.regenerateTitle(conv.id);
          } catch (e3) {
          }
        });
      }
      const renameBtn = actions.createEl("button", { cls: "claudian-action-btn" });
      (0, import_obsidian9.setIcon)(renameBtn, "pencil");
      renameBtn.setAttribute("aria-label", "Rename");
      renameBtn.addEventListener("click", (e2) => {
        e2.stopPropagation();
        this.showRenameInput(item, conv.id, conv.title);
      });
      const deleteBtn = actions.createEl("button", { cls: "claudian-action-btn claudian-delete-btn" });
      (0, import_obsidian9.setIcon)(deleteBtn, "trash-2");
      deleteBtn.setAttribute("aria-label", "Delete");
      deleteBtn.addEventListener("click", async (e2) => {
        e2.stopPropagation();
        if (state.isStreaming) return;
        try {
          await plugin.deleteConversation(conv.id);
          options.onRerender();
          if (conv.id === state.currentConversationId) {
            await this.loadActive();
          }
        } catch (e3) {
        }
      });
    }
  }
  /** Shows inline rename input for a conversation. */
  showRenameInput(item, convId, currentTitle) {
    const titleEl = item.querySelector(".claudian-history-item-title");
    if (!titleEl) return;
    const input = document.createElement("input");
    input.type = "text";
    input.className = "claudian-rename-input";
    input.value = currentTitle;
    titleEl.replaceWith(input);
    input.focus();
    input.select();
    const finishRename = async () => {
      try {
        const newTitle = input.value.trim() || currentTitle;
        await this.deps.plugin.renameConversation(convId, newTitle);
        this.updateHistoryDropdown();
      } catch (e2) {
      }
    };
    input.addEventListener("blur", finishRename);
    input.addEventListener("keydown", async (e2) => {
      if (e2.key === "Enter" && !e2.isComposing) {
        input.blur();
      } else if (e2.key === "Escape" && !e2.isComposing) {
        input.value = currentTitle;
        input.blur();
      }
    });
  }
  // ============================================
  // Welcome & Greeting
  // ============================================
  /** Generates a dynamic greeting based on time/day. */
  getGreeting() {
    var _a;
    const now = /* @__PURE__ */ new Date();
    const hour = now.getHours();
    const day = now.getDay();
    const name = (_a = this.deps.plugin.settings.userName) == null ? void 0 : _a.trim();
    const personalize = (base, noNameFallback) => name ? `${base}, ${name}` : noNameFallback != null ? noNameFallback : base;
    const dayGreetings = {
      0: [personalize("Happy Sunday"), "Sunday session?", "Welcome to the weekend"],
      1: [personalize("Happy Monday"), personalize("Back at it", "Back at it!")],
      2: [personalize("Happy Tuesday")],
      3: [personalize("Happy Wednesday")],
      4: [personalize("Happy Thursday")],
      5: [personalize("Happy Friday"), personalize("That Friday feeling")],
      6: [personalize("Happy Saturday", "Happy Saturday!"), personalize("Welcome to the weekend")]
    };
    const getTimeGreetings = () => {
      if (hour >= 5 && hour < 12) {
        return [personalize("Good morning"), "Coffee and Claudian time?"];
      } else if (hour >= 12 && hour < 18) {
        return [personalize("Good afternoon"), personalize("Hey there"), personalize("How's it going") + "?"];
      } else if (hour >= 18 && hour < 22) {
        return [personalize("Good evening"), personalize("Evening"), personalize("How was your day") + "?"];
      } else {
        return ["Hello, night owl", personalize("Evening")];
      }
    };
    const generalGreetings = [
      personalize("Hey there"),
      name ? `Hi ${name}, how are you?` : "Hi, how are you?",
      personalize("How's it going") + "?",
      personalize("Welcome back") + "!",
      personalize("What's new") + "?",
      ...name ? [`${name} returns!`] : [],
      "You are absolutely right!"
    ];
    const allGreetings = [
      ...dayGreetings[day] || [],
      ...getTimeGreetings(),
      ...generalGreetings
    ];
    return allGreetings[Math.floor(Math.random() * allGreetings.length)];
  }
  /** Updates welcome element visibility based on message count. */
  updateWelcomeVisibility() {
    const welcomeEl = this.deps.getWelcomeEl();
    if (!welcomeEl) return;
    if (this.deps.state.messages.length === 0) {
      welcomeEl.style.display = "";
    } else {
      welcomeEl.style.display = "none";
    }
  }
  /**
   * Initializes the welcome greeting for a new tab without a conversation.
   * Called when a new tab is activated and has no conversation loaded.
   */
  initializeWelcome() {
    const welcomeEl = this.deps.getWelcomeEl();
    if (!welcomeEl) return;
    const fileCtx = this.deps.getFileContextManager();
    fileCtx == null ? void 0 : fileCtx.resetForNewConversation();
    fileCtx == null ? void 0 : fileCtx.autoAttachActiveFile();
    if (!welcomeEl.querySelector(".claudian-welcome-greeting")) {
      welcomeEl.createDiv({ cls: "claudian-welcome-greeting", text: this.getGreeting() });
    }
    this.updateWelcomeVisibility();
  }
  // ============================================
  // Utilities
  // ============================================
  /** Generates a fallback title from the first message (used when AI fails). */
  generateFallbackTitle(firstMessage) {
    const firstSentence = firstMessage.split(/[.!?\n]/)[0].trim();
    const autoTitle = firstSentence.substring(0, 50);
    const suffix = firstSentence.length > 50 ? "..." : "";
    return `${autoTitle}${suffix}`;
  }
  /** Regenerates AI title for a conversation. */
  async regenerateTitle(conversationId) {
    const { plugin } = this.deps;
    if (!plugin.settings.enableAutoTitleGeneration) return;
    const titleService = this.deps.getTitleGenerationService();
    if (!titleService) return;
    const fullConv = await plugin.getConversationById(conversationId);
    if (!fullConv || fullConv.messages.length < 1) return;
    const firstUserMsg = fullConv.messages.find((m) => m.role === "user");
    if (!firstUserMsg) return;
    const userContent = firstUserMsg.displayContent || firstUserMsg.content;
    const expectedTitle = fullConv.title;
    await plugin.updateConversation(conversationId, { titleGenerationStatus: "pending" });
    this.updateHistoryDropdown();
    await titleService.generateTitle(
      conversationId,
      userContent,
      async (convId, result) => {
        const currentConv = await plugin.getConversationById(convId);
        if (!currentConv) return;
        const userManuallyRenamed = currentConv.title !== expectedTitle;
        if (result.success && !userManuallyRenamed) {
          await plugin.renameConversation(convId, result.title);
          await plugin.updateConversation(convId, { titleGenerationStatus: "success" });
        } else if (!userManuallyRenamed) {
          await plugin.updateConversation(convId, { titleGenerationStatus: "failed" });
        } else {
          await plugin.updateConversation(convId, { titleGenerationStatus: void 0 });
        }
        this.updateHistoryDropdown();
      }
    );
  }
  /** Formats a timestamp for display. */
  formatDate(timestamp) {
    const date = new Date(timestamp);
    const now = /* @__PURE__ */ new Date();
    if (date.toDateString() === now.toDateString()) {
      return date.toLocaleTimeString(void 0, { hour: "2-digit", minute: "2-digit", hour12: false });
    }
    return date.toLocaleDateString(void 0, { month: "short", day: "numeric" });
  }
  // ============================================
  // History Dropdown Rendering (for ClaudianView)
  // ============================================
  /**
   * Renders the history dropdown content to a provided container.
   * Used by ClaudianView to render the dropdown with custom selection callback.
   */
  renderHistoryDropdown(container, options) {
    this.renderHistoryItems(container, {
      onSelectConversation: options.onSelectConversation,
      onRerender: () => this.renderHistoryDropdown(container, options)
    });
  }
};

// src/features/chat/controllers/InputController.ts
var import_obsidian12 = require("obsidian");

// src/shared/modals/ApprovalModal.ts
var import_obsidian10 = require("obsidian");
var ApprovalModal = class extends import_obsidian10.Modal {
  constructor(app, toolName, _input, description, resolve3, options = {}) {
    super(app);
    this.resolved = false;
    this.buttons = [];
    this.currentButtonIndex = 0;
    this.documentKeydownHandler = null;
    this.toolName = toolName;
    this.description = description;
    this.resolve = resolve3;
    this.options = options;
  }
  onOpen() {
    var _a, _b, _c;
    const { contentEl } = this;
    contentEl.addClass("claudian-approval-modal");
    this.setTitle((_a = this.options.title) != null ? _a : "Permission required");
    const infoEl = contentEl.createDiv({ cls: "claudian-approval-info" });
    const toolEl = infoEl.createDiv({ cls: "claudian-approval-tool" });
    const iconEl = toolEl.createSpan({ cls: "claudian-approval-icon" });
    iconEl.setAttribute("aria-hidden", "true");
    (0, import_obsidian10.setIcon)(iconEl, getToolIcon(this.toolName));
    toolEl.createSpan({ text: this.toolName, cls: "claudian-approval-tool-name" });
    const descEl = contentEl.createDiv({ cls: "claudian-approval-desc" });
    descEl.setText(this.description);
    const buttonsEl = contentEl.createDiv({ cls: "claudian-approval-buttons" });
    const denyBtn = buttonsEl.createEl("button", {
      text: "Deny",
      cls: "claudian-approval-btn claudian-deny-btn",
      attr: { "aria-label": `Deny ${this.toolName} action` }
    });
    denyBtn.addEventListener("click", () => this.handleDecision("deny"));
    let alwaysDenyBtn = null;
    if ((_b = this.options.showAlwaysDeny) != null ? _b : true) {
      alwaysDenyBtn = buttonsEl.createEl("button", {
        text: "Always deny",
        cls: "claudian-approval-btn claudian-always-deny-btn",
        attr: { "aria-label": `Always deny ${this.toolName} actions` }
      });
      alwaysDenyBtn.addEventListener("click", () => this.handleDecision("deny-always"));
    }
    const allowBtn = buttonsEl.createEl("button", {
      text: "Allow once",
      cls: "claudian-approval-btn claudian-allow-btn",
      attr: { "aria-label": `Allow ${this.toolName} action once` }
    });
    allowBtn.addEventListener("click", () => this.handleDecision("allow"));
    let alwaysAllowBtn = null;
    if ((_c = this.options.showAlwaysAllow) != null ? _c : true) {
      alwaysAllowBtn = buttonsEl.createEl("button", {
        text: "Always allow",
        cls: "claudian-approval-btn claudian-always-btn",
        attr: { "aria-label": `Always allow ${this.toolName} actions` }
      });
      alwaysAllowBtn.addEventListener("click", () => this.handleDecision("allow-always"));
    }
    this.buttons = [denyBtn];
    if (alwaysDenyBtn) {
      this.buttons.push(alwaysDenyBtn);
    }
    this.buttons.push(allowBtn);
    if (alwaysAllowBtn) {
      this.buttons.push(alwaysAllowBtn);
    }
    this.currentButtonIndex = 0;
    this.focusCurrentButton();
    this.attachDocumentHandler();
  }
  handleDecision(decision) {
    if (!this.resolved) {
      this.resolved = true;
      this.resolve(decision);
      this.close();
    }
  }
  attachDocumentHandler() {
    this.detachDocumentHandler();
    this.documentKeydownHandler = (e2) => {
      if (!this.isNavigationKey(e2)) {
        return;
      }
      e2.preventDefault();
      e2.stopPropagation();
      this.handleNavigationKey(e2);
    };
    document.addEventListener("keydown", this.documentKeydownHandler, true);
  }
  detachDocumentHandler() {
    if (this.documentKeydownHandler) {
      document.removeEventListener("keydown", this.documentKeydownHandler, true);
      this.documentKeydownHandler = null;
    }
  }
  isNavigationKey(e2) {
    return e2.key === "ArrowUp" || e2.key === "ArrowDown" || e2.key === "ArrowLeft" || e2.key === "ArrowRight" || e2.key === "Tab";
  }
  handleNavigationKey(e2) {
    if (!this.buttons.length) return;
    let direction = 0;
    switch (e2.key) {
      case "ArrowUp":
      case "ArrowLeft":
        direction = -1;
        break;
      case "ArrowDown":
      case "ArrowRight":
        direction = 1;
        break;
      case "Tab":
        direction = e2.shiftKey ? -1 : 1;
        break;
      default:
        return;
    }
    const total = this.buttons.length;
    this.currentButtonIndex = (this.currentButtonIndex + direction + total) % total;
    this.focusCurrentButton();
  }
  focusCurrentButton() {
    const button = this.buttons[this.currentButtonIndex];
    button == null ? void 0 : button.focus();
  }
  onClose() {
    this.detachDocumentHandler();
    if (!this.resolved) {
      this.resolved = true;
      this.resolve("cancel");
    }
    this.contentEl.empty();
  }
};

// src/shared/modals/InstructionConfirmModal.ts
var import_obsidian11 = require("obsidian");
var InstructionModal = class extends import_obsidian11.Modal {
  constructor(app, rawInstruction, callbacks) {
    super(app);
    this.state = "loading";
    this.resolved = false;
    // UI elements
    this.contentSectionEl = null;
    this.loadingEl = null;
    this.clarificationEl = null;
    this.confirmationEl = null;
    this.buttonsEl = null;
    // Clarification state
    this.clarificationTextEl = null;
    this.responseTextarea = null;
    this.isSubmitting = false;
    // Confirmation state
    this.refinedInstruction = "";
    this.editTextarea = null;
    this.isEditing = false;
    this.refinedDisplayEl = null;
    this.editContainerEl = null;
    this.editBtnEl = null;
    this.rawInstruction = rawInstruction;
    this.callbacks = callbacks;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("claudian-instruction-modal");
    this.setTitle("Add Custom Instruction");
    const inputSection = contentEl.createDiv({ cls: "claudian-instruction-section" });
    const inputLabel = inputSection.createDiv({ cls: "claudian-instruction-label" });
    inputLabel.setText("Your input:");
    const inputText = inputSection.createDiv({ cls: "claudian-instruction-original" });
    inputText.setText(this.rawInstruction);
    this.contentSectionEl = contentEl.createDiv({ cls: "claudian-instruction-content-section" });
    this.loadingEl = this.contentSectionEl.createDiv({ cls: "claudian-instruction-loading" });
    this.loadingEl.createDiv({ cls: "claudian-instruction-spinner" });
    this.loadingEl.createSpan({ text: "Processing your instruction..." });
    this.clarificationEl = this.contentSectionEl.createDiv({ cls: "claudian-instruction-clarification-section" });
    this.clarificationEl.style.display = "none";
    this.clarificationTextEl = this.clarificationEl.createDiv({ cls: "claudian-instruction-clarification" });
    const responseSection = this.clarificationEl.createDiv({ cls: "claudian-instruction-section" });
    const responseLabel = responseSection.createDiv({ cls: "claudian-instruction-label" });
    responseLabel.setText("Your response:");
    this.responseTextarea = new import_obsidian11.TextAreaComponent(responseSection);
    this.responseTextarea.inputEl.addClass("claudian-instruction-response-textarea");
    this.responseTextarea.inputEl.rows = 3;
    this.responseTextarea.inputEl.placeholder = "Provide more details...";
    this.responseTextarea.inputEl.addEventListener("keydown", (e2) => {
      if (e2.key === "Enter" && !e2.shiftKey && !e2.isComposing && !this.isSubmitting) {
        e2.preventDefault();
        this.submitClarification();
      }
    });
    this.confirmationEl = this.contentSectionEl.createDiv({ cls: "claudian-instruction-confirmation-section" });
    this.confirmationEl.style.display = "none";
    const refinedSection = this.confirmationEl.createDiv({ cls: "claudian-instruction-section" });
    const refinedLabel = refinedSection.createDiv({ cls: "claudian-instruction-label" });
    refinedLabel.setText("Refined snippet:");
    this.refinedDisplayEl = refinedSection.createDiv({ cls: "claudian-instruction-refined" });
    this.editContainerEl = refinedSection.createDiv({ cls: "claudian-instruction-edit-container" });
    this.editContainerEl.style.display = "none";
    this.editTextarea = new import_obsidian11.TextAreaComponent(this.editContainerEl);
    this.editTextarea.inputEl.addClass("claudian-instruction-edit-textarea");
    this.editTextarea.inputEl.rows = 4;
    this.buttonsEl = contentEl.createDiv({ cls: "claudian-instruction-buttons" });
    this.updateButtons();
    this.showState("loading");
  }
  showClarification(clarification) {
    var _a;
    if (this.clarificationTextEl) {
      this.clarificationTextEl.setText(clarification);
    }
    if (this.responseTextarea) {
      this.responseTextarea.setValue("");
    }
    this.isSubmitting = false;
    this.showState("clarification");
    (_a = this.responseTextarea) == null ? void 0 : _a.inputEl.focus();
  }
  showConfirmation(refinedInstruction) {
    this.refinedInstruction = refinedInstruction;
    if (this.refinedDisplayEl) {
      this.refinedDisplayEl.setText(refinedInstruction);
    }
    if (this.editTextarea) {
      this.editTextarea.setValue(refinedInstruction);
    }
    this.showState("confirmation");
  }
  showError(error) {
    this.resolved = true;
    this.close();
  }
  showClarificationLoading() {
    this.isSubmitting = true;
    if (this.loadingEl) {
      this.loadingEl.querySelector(".claudian-instruction-spinner");
      const text = this.loadingEl.querySelector("span");
      if (text) text.textContent = "Processing...";
    }
    this.showState("loading");
  }
  showState(state) {
    this.state = state;
    if (this.loadingEl) {
      this.loadingEl.style.display = state === "loading" ? "flex" : "none";
    }
    if (this.clarificationEl) {
      this.clarificationEl.style.display = state === "clarification" ? "block" : "none";
    }
    if (this.confirmationEl) {
      this.confirmationEl.style.display = state === "confirmation" ? "block" : "none";
    }
    this.updateButtons();
  }
  updateButtons() {
    if (!this.buttonsEl) return;
    this.buttonsEl.empty();
    const cancelBtn = this.buttonsEl.createEl("button", {
      text: "Cancel",
      cls: "claudian-instruction-btn claudian-instruction-reject-btn",
      attr: { "aria-label": "Cancel" }
    });
    cancelBtn.addEventListener("click", () => this.handleReject());
    if (this.state === "clarification") {
      const submitBtn = this.buttonsEl.createEl("button", {
        text: "Submit",
        cls: "claudian-instruction-btn claudian-instruction-accept-btn",
        attr: { "aria-label": "Submit response" }
      });
      submitBtn.addEventListener("click", () => this.submitClarification());
    } else if (this.state === "confirmation") {
      this.editBtnEl = this.buttonsEl.createEl("button", {
        text: "Edit",
        cls: "claudian-instruction-btn claudian-instruction-edit-btn",
        attr: { "aria-label": "Edit instruction" }
      });
      this.editBtnEl.addEventListener("click", () => this.toggleEdit());
      const acceptBtn = this.buttonsEl.createEl("button", {
        text: "Accept",
        cls: "claudian-instruction-btn claudian-instruction-accept-btn",
        attr: { "aria-label": "Accept instruction" }
      });
      acceptBtn.addEventListener("click", () => this.handleAccept());
      acceptBtn.focus();
    }
  }
  async submitClarification() {
    var _a;
    const response = (_a = this.responseTextarea) == null ? void 0 : _a.getValue().trim();
    if (!response || this.isSubmitting) return;
    this.showClarificationLoading();
    try {
      await this.callbacks.onClarificationSubmit(response);
    } catch (e2) {
      this.isSubmitting = false;
      this.showState("clarification");
    }
  }
  toggleEdit() {
    var _a, _b;
    this.isEditing = !this.isEditing;
    if (this.isEditing) {
      if (this.refinedDisplayEl) this.refinedDisplayEl.style.display = "none";
      if (this.editContainerEl) this.editContainerEl.style.display = "block";
      if (this.editBtnEl) this.editBtnEl.setText("Preview");
      (_a = this.editTextarea) == null ? void 0 : _a.inputEl.focus();
    } else {
      const edited = ((_b = this.editTextarea) == null ? void 0 : _b.getValue()) || this.refinedInstruction;
      this.refinedInstruction = edited;
      if (this.refinedDisplayEl) {
        this.refinedDisplayEl.setText(edited);
        this.refinedDisplayEl.style.display = "block";
      }
      if (this.editContainerEl) this.editContainerEl.style.display = "none";
      if (this.editBtnEl) this.editBtnEl.setText("Edit");
    }
  }
  handleAccept() {
    var _a;
    if (this.resolved) return;
    this.resolved = true;
    const finalInstruction = this.isEditing ? ((_a = this.editTextarea) == null ? void 0 : _a.getValue()) || this.refinedInstruction : this.refinedInstruction;
    this.callbacks.onAccept(finalInstruction);
    this.close();
  }
  handleReject() {
    if (this.resolved) return;
    this.resolved = true;
    this.callbacks.onReject();
    this.close();
  }
  onClose() {
    if (!this.resolved) {
      this.resolved = true;
      this.callbacks.onReject();
    }
    this.contentEl.empty();
  }
};

// src/utils/editor.ts
function getEditorView(editor) {
  return editor.cm;
}
function findNearestNonEmptyLine(getLine, lineCount, startLine, direction) {
  const step = direction === "before" ? -1 : 1;
  for (let i2 = startLine + step; i2 >= 0 && i2 < lineCount; i2 += step) {
    const content = getLine(i2);
    if (content.trim().length > 0) {
      return content;
    }
  }
  return "";
}
function buildCursorContext(getLine, lineCount, line, column) {
  const lineContent = getLine(line);
  const beforeCursor = lineContent.substring(0, column);
  const afterCursor = lineContent.substring(column);
  const lineIsEmpty = lineContent.trim().length === 0;
  const nothingBefore = beforeCursor.trim().length === 0;
  const nothingAfter = afterCursor.trim().length === 0;
  const isInbetween = lineIsEmpty || nothingBefore && nothingAfter;
  let contextBefore = beforeCursor;
  let contextAfter = afterCursor;
  if (isInbetween) {
    contextBefore = findNearestNonEmptyLine(getLine, lineCount, line, "before");
    contextAfter = findNearestNonEmptyLine(getLine, lineCount, line, "after");
  }
  return { beforeCursor: contextBefore, afterCursor: contextAfter, isInbetween, line, column };
}
function formatEditorContext(context) {
  if (context.mode === "selection" && context.selectedText) {
    const lineAttr = context.startLine && context.lineCount ? ` lines="${context.startLine}-${context.startLine + context.lineCount - 1}"` : "";
    return `<editor_selection path="${context.notePath}"${lineAttr}>
${context.selectedText}
</editor_selection>`;
  } else if (context.mode === "cursor" && context.cursorContext) {
    const ctx = context.cursorContext;
    let content;
    if (ctx.isInbetween) {
      const parts = [];
      if (ctx.beforeCursor) parts.push(ctx.beforeCursor);
      parts.push("| #inbetween");
      if (ctx.afterCursor) parts.push(ctx.afterCursor);
      content = parts.join("\n");
    } else {
      content = `${ctx.beforeCursor}|${ctx.afterCursor} #inline`;
    }
    return `<editor_cursor path="${context.notePath}">
${content}
</editor_cursor>`;
  }
  return "";
}
function appendEditorContext(prompt, context) {
  const formatted = formatEditorContext(context);
  return formatted ? `${prompt}

${formatted}` : prompt;
}

// src/utils/markdown.ts
function appendMarkdownSnippet(existingPrompt, snippet) {
  const trimmedSnippet = snippet.trim();
  if (!trimmedSnippet) {
    return existingPrompt;
  }
  if (!existingPrompt.trim()) {
    return trimmedSnippet;
  }
  const separator = existingPrompt.endsWith("\n\n") ? "" : existingPrompt.endsWith("\n") ? "\n" : "\n\n";
  return existingPrompt + separator + trimmedSnippet;
}

// src/features/chat/controllers/InputController.ts
var InputController = class {
  constructor(deps) {
    this.deps = deps;
  }
  getAgentService() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this.deps).getAgentService) == null ? void 0 : _b.call(_a)) != null ? _c : null;
  }
  // ============================================
  // Message Sending
  // ============================================
  async sendMessage(options) {
    var _a, _b, _c, _d;
    const { plugin, state, renderer, streamController, selectionController, conversationController } = this.deps;
    if (state.isCreatingConversation || state.isSwitchingConversation) return;
    const inputEl = this.deps.getInputEl();
    const imageContextManager = this.deps.getImageContextManager();
    const fileContextManager = this.deps.getFileContextManager();
    const mcpServerSelector = this.deps.getMcpServerSelector();
    const externalContextSelector = this.deps.getExternalContextSelector();
    const contentOverride = options == null ? void 0 : options.content;
    const shouldUseInput = contentOverride === void 0;
    const content = (contentOverride != null ? contentOverride : inputEl.value).trim();
    const hasImages = (_a = imageContextManager == null ? void 0 : imageContextManager.hasImages()) != null ? _a : false;
    if (!content && !hasImages) return;
    (_b = this.deps.getStatusPanel()) == null ? void 0 : _b.clearTerminalSubagents();
    const builtInCmd = detectBuiltInCommand(content);
    if (builtInCmd) {
      if (shouldUseInput) {
        inputEl.value = "";
        this.deps.resetInputHeight();
      }
      await this.executeBuiltInCommand(builtInCmd.command.action, builtInCmd.args);
      return;
    }
    if (state.isStreaming) {
      const images2 = hasImages ? [...(imageContextManager == null ? void 0 : imageContextManager.getAttachedImages()) || []] : void 0;
      const editorContext2 = selectionController.getContext();
      if (state.queuedMessage) {
        state.queuedMessage.content += "\n\n" + content;
        if (images2 && images2.length > 0) {
          state.queuedMessage.images = [...state.queuedMessage.images || [], ...images2];
        }
        state.queuedMessage.editorContext = editorContext2;
      } else {
        state.queuedMessage = {
          content,
          images: images2,
          editorContext: editorContext2
        };
      }
      if (shouldUseInput) {
        inputEl.value = "";
        this.deps.resetInputHeight();
      }
      imageContextManager == null ? void 0 : imageContextManager.clearImages();
      this.updateQueueIndicator();
      return;
    }
    if (shouldUseInput) {
      inputEl.value = "";
      this.deps.resetInputHeight();
    }
    state.isStreaming = true;
    state.cancelRequested = false;
    state.ignoreUsageUpdates = false;
    this.deps.getSubagentManager().resetSpawnedCount();
    state.autoScrollEnabled = (_c = plugin.settings.enableAutoScroll) != null ? _c : true;
    const streamGeneration = state.bumpStreamGeneration();
    const welcomeEl = this.deps.getWelcomeEl();
    if (welcomeEl) {
      welcomeEl.style.display = "none";
    }
    fileContextManager == null ? void 0 : fileContextManager.startSession();
    const displayContent = content;
    let queryOptions;
    const images = (imageContextManager == null ? void 0 : imageContextManager.getAttachedImages()) || [];
    const imagesForMessage = images.length > 0 ? [...images] : void 0;
    if (shouldUseInput) {
      imageContextManager == null ? void 0 : imageContextManager.clearImages();
    }
    const currentNotePath = (fileContextManager == null ? void 0 : fileContextManager.getCurrentNotePath()) || null;
    const shouldSendCurrentNote = (_d = fileContextManager == null ? void 0 : fileContextManager.shouldSendCurrentNote(currentNotePath)) != null ? _d : false;
    const editorContextOverride = options == null ? void 0 : options.editorContextOverride;
    const editorContext = editorContextOverride !== void 0 ? editorContextOverride : selectionController.getContext();
    const externalContextPaths = externalContextSelector == null ? void 0 : externalContextSelector.getExternalContexts();
    let promptToSend = content;
    let currentNoteForMessage;
    if (shouldSendCurrentNote && currentNotePath) {
      promptToSend = appendCurrentNote(promptToSend, currentNotePath);
      currentNoteForMessage = currentNotePath;
    }
    if (editorContext) {
      promptToSend = appendEditorContext(promptToSend, editorContext);
    }
    if (fileContextManager) {
      promptToSend = fileContextManager.transformContextMentions(promptToSend);
    }
    fileContextManager == null ? void 0 : fileContextManager.markCurrentNoteSent();
    const userMsg = {
      id: this.deps.generateId(),
      role: "user",
      content: promptToSend,
      // Full prompt with XML context (for history rebuild)
      displayContent,
      // Original user input (for UI display)
      timestamp: Date.now(),
      currentNote: currentNoteForMessage,
      images: imagesForMessage
    };
    state.addMessage(userMsg);
    renderer.addMessage(userMsg);
    await this.triggerTitleGeneration();
    const assistantMsg = {
      id: this.deps.generateId(),
      role: "assistant",
      content: "",
      timestamp: Date.now(),
      toolCalls: [],
      contentBlocks: []
    };
    state.addMessage(assistantMsg);
    const msgEl = renderer.addMessage(assistantMsg);
    const contentEl = msgEl.querySelector(".claudian-message-content");
    state.toolCallElements.clear();
    state.currentContentEl = contentEl;
    state.currentTextEl = null;
    state.currentTextContent = "";
    streamController.showThinkingIndicator();
    state.responseStartTime = performance.now();
    const mcpMentions = plugin.mcpService.extractMentions(promptToSend);
    promptToSend = plugin.mcpService.transformMentions(promptToSend);
    const enabledMcpServers = mcpServerSelector == null ? void 0 : mcpServerSelector.getEnabledServers();
    if (mcpMentions.size > 0 || enabledMcpServers && enabledMcpServers.size > 0) {
      queryOptions = {
        ...queryOptions,
        mcpMentions,
        enabledMcpServers
      };
    }
    if (externalContextPaths && externalContextPaths.length > 0) {
      queryOptions = {
        ...queryOptions,
        externalContextPaths
      };
    }
    let wasInterrupted = false;
    let wasInvalidated = false;
    if (this.deps.ensureServiceInitialized) {
      const ready = await this.deps.ensureServiceInitialized();
      if (!ready) {
        new import_obsidian12.Notice("Failed to initialize agent service. Please try again.");
        streamController.hideThinkingIndicator();
        state.isStreaming = false;
        return;
      }
    }
    const agentService = this.getAgentService();
    if (!agentService) {
      new import_obsidian12.Notice("Agent service not available. Please reload the plugin.");
      return;
    }
    try {
      const previousMessages = state.messages.slice(0, -2);
      for await (const chunk of agentService.query(promptToSend, imagesForMessage, previousMessages, queryOptions)) {
        if (state.streamGeneration !== streamGeneration) {
          wasInvalidated = true;
          break;
        }
        if (state.cancelRequested) {
          wasInterrupted = true;
          break;
        }
        await streamController.handleStreamChunk(chunk, assistantMsg);
      }
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : "Unknown error";
      await streamController.appendText(`

**Error:** ${errorMsg}`);
    } finally {
      state.clearFlavorTimerInterval();
      if (!wasInvalidated && state.streamGeneration === streamGeneration) {
        if (wasInterrupted) {
          await streamController.appendText('\n\n<span class="claudian-interrupted">Interrupted</span> <span class="claudian-interrupted-hint">\xB7 What should Claudian do instead?</span>');
        }
        streamController.hideThinkingIndicator();
        state.isStreaming = false;
        state.cancelRequested = false;
        if (!wasInterrupted) {
          const durationSeconds = state.responseStartTime ? Math.floor((performance.now() - state.responseStartTime) / 1e3) : 0;
          if (durationSeconds > 0) {
            const flavorWord = COMPLETION_FLAVOR_WORDS[Math.floor(Math.random() * COMPLETION_FLAVOR_WORDS.length)];
            assistantMsg.durationSeconds = durationSeconds;
            assistantMsg.durationFlavorWord = flavorWord;
            if (contentEl) {
              const footerEl = contentEl.createDiv({ cls: "claudian-response-footer" });
              footerEl.createSpan({
                text: `* ${flavorWord} for ${formatDurationMmSs(durationSeconds)}`,
                cls: "claudian-baked-duration"
              });
            }
          }
        }
        state.currentContentEl = null;
        streamController.finalizeCurrentThinkingBlock(assistantMsg);
        streamController.finalizeCurrentTextBlock(assistantMsg);
        this.deps.getSubagentManager().resetStreamingState();
        if (state.currentTodos && state.currentTodos.every((t2) => t2.status === "completed")) {
          state.currentTodos = null;
        }
        const statusPanel = this.deps.getStatusPanel();
        if (statusPanel == null ? void 0 : statusPanel.areAllSubagentsCompleted()) {
          statusPanel.clearTerminalSubagents();
        }
        await conversationController.save(true);
        this.processQueuedMessage();
      }
    }
  }
  // ============================================
  // Queue Management
  // ============================================
  updateQueueIndicator() {
    var _a, _b;
    const { state } = this.deps;
    if (!state.queueIndicatorEl) return;
    if (state.queuedMessage) {
      const rawContent = state.queuedMessage.content.trim();
      const preview = rawContent.length > 40 ? rawContent.slice(0, 40) + "..." : rawContent;
      const hasImages = ((_b = (_a = state.queuedMessage.images) == null ? void 0 : _a.length) != null ? _b : 0) > 0;
      let display = preview;
      if (hasImages) {
        display = display ? `${display} [images]` : "[images]";
      }
      state.queueIndicatorEl.setText(`\u2319 Queued: ${display}`);
      state.queueIndicatorEl.style.display = "block";
    } else {
      state.queueIndicatorEl.style.display = "none";
    }
  }
  clearQueuedMessage() {
    const { state } = this.deps;
    state.queuedMessage = null;
    this.updateQueueIndicator();
  }
  restoreQueuedMessageToInput() {
    var _a;
    const { state } = this.deps;
    if (!state.queuedMessage) return;
    const { content, images } = state.queuedMessage;
    state.queuedMessage = null;
    this.updateQueueIndicator();
    const inputEl = this.deps.getInputEl();
    inputEl.value = content;
    if (images && images.length > 0) {
      (_a = this.deps.getImageContextManager()) == null ? void 0 : _a.setImages(images);
    }
  }
  processQueuedMessage() {
    var _a;
    const { state } = this.deps;
    if (!state.queuedMessage) return;
    const { content, images, editorContext } = state.queuedMessage;
    state.queuedMessage = null;
    this.updateQueueIndicator();
    const inputEl = this.deps.getInputEl();
    inputEl.value = content;
    if (images && images.length > 0) {
      (_a = this.deps.getImageContextManager()) == null ? void 0 : _a.setImages(images);
    }
    setTimeout(() => this.sendMessage({ editorContextOverride: editorContext }), 0);
  }
  // ============================================
  // Title Generation
  // ============================================
  /**
   * Triggers AI title generation after first user message.
   * Handles setting fallback title, firing async generation, and updating UI.
   */
  async triggerTitleGeneration() {
    var _a, _b;
    const { plugin, state, conversationController } = this.deps;
    if (state.messages.length !== 1) {
      return;
    }
    if (!state.currentConversationId) {
      const sessionId = (_b = (_a = this.getAgentService()) == null ? void 0 : _a.getSessionId()) != null ? _b : void 0;
      const conversation = await plugin.createConversation(sessionId);
      state.currentConversationId = conversation.id;
    }
    const firstUserMsg = state.messages.find((m) => m.role === "user");
    if (!firstUserMsg) {
      return;
    }
    const userContent = firstUserMsg.displayContent || firstUserMsg.content;
    const fallbackTitle = conversationController.generateFallbackTitle(userContent);
    await plugin.renameConversation(state.currentConversationId, fallbackTitle);
    if (!plugin.settings.enableAutoTitleGeneration) {
      return;
    }
    const titleService = this.deps.getTitleGenerationService();
    if (!titleService) {
      return;
    }
    await plugin.updateConversation(state.currentConversationId, { titleGenerationStatus: "pending" });
    conversationController.updateHistoryDropdown();
    const convId = state.currentConversationId;
    const expectedTitle = fallbackTitle;
    titleService.generateTitle(
      convId,
      userContent,
      async (conversationId, result) => {
        const currentConv = await plugin.getConversationById(conversationId);
        if (!currentConv) return;
        const userManuallyRenamed = currentConv.title !== expectedTitle;
        if (result.success && !userManuallyRenamed) {
          await plugin.renameConversation(conversationId, result.title);
          await plugin.updateConversation(conversationId, { titleGenerationStatus: "success" });
        } else if (!userManuallyRenamed) {
          await plugin.updateConversation(conversationId, { titleGenerationStatus: "failed" });
        } else {
          await plugin.updateConversation(conversationId, { titleGenerationStatus: void 0 });
        }
        conversationController.updateHistoryDropdown();
      }
    ).catch(() => {
    });
  }
  // ============================================
  // Streaming Control
  // ============================================
  cancelStreaming() {
    var _a;
    const { state, streamController } = this.deps;
    if (!state.isStreaming) return;
    state.cancelRequested = true;
    this.restoreQueuedMessageToInput();
    (_a = this.getAgentService()) == null ? void 0 : _a.cancel();
    streamController.hideThinkingIndicator();
  }
  // ============================================
  // Instruction Mode
  // ============================================
  async handleInstructionSubmit(rawInstruction) {
    const { plugin } = this.deps;
    const instructionRefineService = this.deps.getInstructionRefineService();
    const instructionModeManager = this.deps.getInstructionModeManager();
    if (!instructionRefineService) return;
    const existingPrompt = plugin.settings.systemPrompt;
    let modal = null;
    let wasCancelled = false;
    try {
      modal = new InstructionModal(
        plugin.app,
        rawInstruction,
        {
          onAccept: async (finalInstruction) => {
            const currentPrompt = plugin.settings.systemPrompt;
            plugin.settings.systemPrompt = appendMarkdownSnippet(currentPrompt, finalInstruction);
            await plugin.saveSettings();
            new import_obsidian12.Notice("Instruction added to custom system prompt");
            instructionModeManager == null ? void 0 : instructionModeManager.clear();
          },
          onReject: () => {
            wasCancelled = true;
            instructionRefineService.cancel();
            instructionModeManager == null ? void 0 : instructionModeManager.clear();
          },
          onClarificationSubmit: async (response) => {
            const result2 = await instructionRefineService.continueConversation(response);
            if (wasCancelled) {
              return;
            }
            if (!result2.success) {
              if (result2.error === "Cancelled") {
                return;
              }
              new import_obsidian12.Notice(result2.error || "Failed to process response");
              modal == null ? void 0 : modal.showError(result2.error || "Failed to process response");
              return;
            }
            if (result2.clarification) {
              modal == null ? void 0 : modal.showClarification(result2.clarification);
            } else if (result2.refinedInstruction) {
              modal == null ? void 0 : modal.showConfirmation(result2.refinedInstruction);
            }
          }
        }
      );
      modal.open();
      instructionRefineService.resetConversation();
      const result = await instructionRefineService.refineInstruction(
        rawInstruction,
        existingPrompt
      );
      if (wasCancelled) {
        return;
      }
      if (!result.success) {
        if (result.error === "Cancelled") {
          instructionModeManager == null ? void 0 : instructionModeManager.clear();
          return;
        }
        new import_obsidian12.Notice(result.error || "Failed to refine instruction");
        modal.showError(result.error || "Failed to refine instruction");
        instructionModeManager == null ? void 0 : instructionModeManager.clear();
        return;
      }
      if (result.clarification) {
        modal.showClarification(result.clarification);
      } else if (result.refinedInstruction) {
        modal.showConfirmation(result.refinedInstruction);
      } else {
        new import_obsidian12.Notice("No instruction received");
        modal.showError("No instruction received");
        instructionModeManager == null ? void 0 : instructionModeManager.clear();
      }
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : "Unknown error";
      new import_obsidian12.Notice(`Error: ${errorMsg}`);
      modal == null ? void 0 : modal.showError(errorMsg);
      instructionModeManager == null ? void 0 : instructionModeManager.clear();
    }
  }
  // ============================================
  // Approval Dialogs
  // ============================================
  async handleApprovalRequest(toolName, input, description) {
    const { plugin } = this.deps;
    return new Promise((resolve3) => {
      const modal = new ApprovalModal(plugin.app, toolName, input, description, resolve3);
      modal.open();
    });
  }
  // ============================================
  // Built-in Commands
  // ============================================
  async executeBuiltInCommand(action, args) {
    const { conversationController } = this.deps;
    switch (action) {
      case "clear":
        await conversationController.createNew();
        break;
      case "add-dir": {
        const externalContextSelector = this.deps.getExternalContextSelector();
        if (!externalContextSelector) {
          new import_obsidian12.Notice("External context selector not available.");
          return;
        }
        const result = externalContextSelector.addExternalContext(args);
        if (result.success) {
          new import_obsidian12.Notice(`Added external context: ${result.normalizedPath}`);
        } else {
          new import_obsidian12.Notice(result.error);
        }
        break;
      }
      default:
        new import_obsidian12.Notice(`Unknown command: ${action}`);
    }
  }
};

// src/features/chat/controllers/NavigationController.ts
var SCROLL_SPEED = 8;
var NavigationController = class {
  constructor(deps) {
    this.scrollDirection = null;
    this.animationFrameId = null;
    this.initialized = false;
    this.disposed = false;
    this.scrollLoop = () => {
      if (this.scrollDirection === null || this.disposed) return;
      const messagesEl = this.deps.getMessagesEl();
      if (!messagesEl) {
        this.stopScrolling();
        return;
      }
      const scrollAmount = this.scrollDirection === "up" ? -SCROLL_SPEED : SCROLL_SPEED;
      messagesEl.scrollTop += scrollAmount;
      this.animationFrameId = requestAnimationFrame(this.scrollLoop);
    };
    this.deps = deps;
    this.boundMessagesKeydown = this.handleMessagesKeydown.bind(this);
    this.boundKeyup = this.handleKeyup.bind(this);
    this.boundInputKeydown = this.handleInputKeydown.bind(this);
  }
  initialize() {
    if (this.initialized || this.disposed) return;
    const messagesEl = this.deps.getMessagesEl();
    const inputEl = this.deps.getInputEl();
    if (!messagesEl || !inputEl) return;
    messagesEl.setAttribute("tabindex", "0");
    messagesEl.addClass("claudian-messages-focusable");
    messagesEl.addEventListener("keydown", this.boundMessagesKeydown);
    document.addEventListener("keyup", this.boundKeyup);
    inputEl.addEventListener("keydown", this.boundInputKeydown, { capture: true });
    this.initialized = true;
  }
  /** Cleans up event listeners and animation frames. */
  dispose() {
    if (this.disposed) return;
    this.disposed = true;
    this.stopScrolling();
    document.removeEventListener("keyup", this.boundKeyup);
    const messagesEl = this.deps.getMessagesEl();
    messagesEl == null ? void 0 : messagesEl.removeEventListener("keydown", this.boundMessagesKeydown);
    messagesEl == null ? void 0 : messagesEl.removeClass("claudian-messages-focusable");
    const inputEl = this.deps.getInputEl();
    inputEl == null ? void 0 : inputEl.removeEventListener("keydown", this.boundInputKeydown, { capture: true });
  }
  // ============================================
  // Messages Panel Keyboard Handling
  // ============================================
  handleMessagesKeydown(e2) {
    if (e2.ctrlKey || e2.metaKey || e2.altKey || e2.shiftKey) return;
    const settings11 = this.deps.getSettings();
    const key = e2.key.toLowerCase();
    if (key === settings11.scrollUpKey.toLowerCase()) {
      e2.preventDefault();
      this.startScrolling("up");
      return;
    }
    if (key === settings11.scrollDownKey.toLowerCase()) {
      e2.preventDefault();
      this.startScrolling("down");
      return;
    }
    if (key === settings11.focusInputKey.toLowerCase()) {
      e2.preventDefault();
      this.deps.getInputEl().focus();
      return;
    }
  }
  handleKeyup(e2) {
    const settings11 = this.deps.getSettings();
    const key = e2.key.toLowerCase();
    if (key === settings11.scrollUpKey.toLowerCase() || key === settings11.scrollDownKey.toLowerCase()) {
      this.stopScrolling();
    }
  }
  // ============================================
  // Input Keyboard Handling (Escape)
  // ============================================
  handleInputKeydown(e2) {
    var _a, _b;
    if (e2.key !== "Escape") return;
    if (e2.isComposing) return;
    if (this.deps.isStreaming()) {
      return;
    }
    if ((_b = (_a = this.deps).shouldSkipEscapeHandling) == null ? void 0 : _b.call(_a)) {
      return;
    }
    e2.preventDefault();
    e2.stopPropagation();
    this.deps.getInputEl().blur();
    this.deps.getMessagesEl().focus();
  }
  // ============================================
  // Continuous Scrolling with requestAnimationFrame
  // ============================================
  startScrolling(direction) {
    if (this.scrollDirection === direction) {
      return;
    }
    this.scrollDirection = direction;
    this.scrollLoop();
  }
  stopScrolling() {
    this.scrollDirection = null;
    if (this.animationFrameId !== null) {
      cancelAnimationFrame(this.animationFrameId);
      this.animationFrameId = null;
    }
  }
  // ============================================
  // Public API
  // ============================================
  /** Focuses the messages panel. */
  focusMessages() {
    this.deps.getMessagesEl().focus();
  }
  /** Focuses the input. */
  focusInput() {
    this.deps.getInputEl().focus();
  }
};

// src/features/chat/controllers/SelectionController.ts
var import_obsidian13 = require("obsidian");

// src/shared/components/SelectionHighlight.ts
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");
function createSelectionHighlighter() {
  const showHighlight = import_state.StateEffect.define();
  const hideHighlight = import_state.StateEffect.define();
  const selectionHighlightField = import_state.StateField.define({
    create: () => import_view.Decoration.none,
    update: (deco, tr) => {
      for (const e2 of tr.effects) {
        if (e2.is(showHighlight)) {
          const builder = new import_state.RangeSetBuilder();
          builder.add(e2.value.from, e2.value.to, import_view.Decoration.mark({
            class: "claudian-selection-highlight"
          }));
          return builder.finish();
        } else if (e2.is(hideHighlight)) {
          return import_view.Decoration.none;
        }
      }
      return deco.map(tr.changes);
    },
    provide: (f3) => import_view.EditorView.decorations.from(f3)
  });
  const installedEditors2 = /* @__PURE__ */ new WeakSet();
  function ensureHighlightField(editorView) {
    if (!installedEditors2.has(editorView)) {
      editorView.dispatch({
        effects: import_state.StateEffect.appendConfig.of(selectionHighlightField)
      });
      installedEditors2.add(editorView);
    }
  }
  function show(editorView, from, to) {
    ensureHighlightField(editorView);
    editorView.dispatch({
      effects: showHighlight.of({ from, to })
    });
  }
  function hide(editorView) {
    if (installedEditors2.has(editorView)) {
      editorView.dispatch({
        effects: hideHighlight.of(null)
      });
    }
  }
  return { show, hide };
}
var defaultHighlighter = createSelectionHighlighter();
function showSelectionHighlight(editorView, from, to) {
  defaultHighlighter.show(editorView, from, to);
}
function hideSelectionHighlight(editorView) {
  defaultHighlighter.hide(editorView);
}

// src/features/chat/controllers/SelectionController.ts
var SELECTION_POLL_INTERVAL = 250;
var SelectionController = class {
  constructor(app, indicatorEl, inputEl, contextRowEl, onVisibilityChange) {
    this.storedSelection = null;
    this.pollInterval = null;
    this.app = app;
    this.indicatorEl = indicatorEl;
    this.inputEl = inputEl;
    this.contextRowEl = contextRowEl;
    this.onVisibilityChange = onVisibilityChange != null ? onVisibilityChange : null;
  }
  start() {
    if (this.pollInterval) return;
    this.pollInterval = setInterval(() => this.poll(), SELECTION_POLL_INTERVAL);
  }
  stop() {
    if (this.pollInterval) {
      clearInterval(this.pollInterval);
      this.pollInterval = null;
    }
    this.clear();
  }
  dispose() {
    this.stop();
  }
  // ============================================
  // Selection Polling
  // ============================================
  poll() {
    var _a, _b, _c, _d;
    const view = this.app.workspace.getActiveViewOfType(import_obsidian13.MarkdownView);
    if (!view) return;
    const editor = view.editor;
    const editorView = getEditorView(editor);
    if (!editorView) return;
    const selectedText = editor.getSelection();
    if (selectedText.trim()) {
      const fromPos = editor.getCursor("from");
      const toPos = editor.getCursor("to");
      const from = editor.posToOffset(fromPos);
      const to = editor.posToOffset(toPos);
      const startLine = fromPos.line + 1;
      const notePath = ((_a = view.file) == null ? void 0 : _a.path) || "unknown";
      const lineCount = selectedText.split(/\r?\n/).length;
      const sameRange = this.storedSelection && this.storedSelection.editorView === editorView && this.storedSelection.from === from && this.storedSelection.to === to && this.storedSelection.notePath === notePath;
      const sameText = sameRange && ((_b = this.storedSelection) == null ? void 0 : _b.selectedText) === selectedText;
      const sameLineCount = sameRange && ((_c = this.storedSelection) == null ? void 0 : _c.lineCount) === lineCount;
      const sameStartLine = sameRange && ((_d = this.storedSelection) == null ? void 0 : _d.startLine) === startLine;
      if (!sameRange || !sameText || !sameLineCount || !sameStartLine) {
        if (this.storedSelection && !sameRange) {
          this.clearHighlight();
        }
        this.storedSelection = { notePath, selectedText, lineCount, startLine, from, to, editorView };
        this.updateIndicator();
      }
    } else if (document.activeElement !== this.inputEl) {
      this.clearHighlight();
      this.storedSelection = null;
      this.updateIndicator();
    }
  }
  // ============================================
  // Highlight Management
  // ============================================
  showHighlight() {
    if (!this.storedSelection) return;
    const { from, to, editorView } = this.storedSelection;
    showSelectionHighlight(editorView, from, to);
  }
  clearHighlight() {
    if (!this.storedSelection) return;
    hideSelectionHighlight(this.storedSelection.editorView);
  }
  // ============================================
  // Indicator
  // ============================================
  updateIndicator() {
    if (!this.indicatorEl) return;
    if (this.storedSelection) {
      const lineText = this.storedSelection.lineCount === 1 ? "line" : "lines";
      this.indicatorEl.textContent = `${this.storedSelection.lineCount} ${lineText} selected`;
      this.indicatorEl.style.display = "block";
    } else {
      this.indicatorEl.style.display = "none";
    }
    this.updateContextRowVisibility();
  }
  updateContextRowVisibility() {
    var _a;
    if (!this.contextRowEl) return;
    const hasSelection = this.storedSelection !== null;
    const fileIndicator = this.contextRowEl.querySelector(".claudian-file-indicator");
    const imagePreview = this.contextRowEl.querySelector(".claudian-image-preview");
    const hasFileChips = (fileIndicator == null ? void 0 : fileIndicator.style.display) === "flex";
    const hasImageChips = (imagePreview == null ? void 0 : imagePreview.style.display) === "flex";
    this.contextRowEl.classList.toggle("has-content", hasSelection || hasFileChips || hasImageChips);
    (_a = this.onVisibilityChange) == null ? void 0 : _a.call(this);
  }
  // ============================================
  // Context Access
  // ============================================
  getContext() {
    if (!this.storedSelection) return null;
    return {
      notePath: this.storedSelection.notePath,
      mode: "selection",
      selectedText: this.storedSelection.selectedText,
      lineCount: this.storedSelection.lineCount,
      startLine: this.storedSelection.startLine
    };
  }
  hasSelection() {
    return this.storedSelection !== null;
  }
  // ============================================
  // Clear
  // ============================================
  clear() {
    this.clearHighlight();
    this.storedSelection = null;
    this.updateIndicator();
  }
};

// src/utils/diff.ts
function structuredPatchToDiffLines(hunks) {
  const result = [];
  for (const hunk of hunks) {
    let oldLineNum = hunk.oldStart;
    let newLineNum = hunk.newStart;
    for (const line of hunk.lines) {
      const prefix = line[0];
      const text = line.slice(1);
      if (prefix === "+") {
        result.push({ type: "insert", text, newLineNum: newLineNum++ });
      } else if (prefix === "-") {
        result.push({ type: "delete", text, oldLineNum: oldLineNum++ });
      } else {
        result.push({ type: "equal", text, oldLineNum: oldLineNum++, newLineNum: newLineNum++ });
      }
    }
  }
  return result;
}
function countLineChanges(diffLines) {
  let added = 0;
  let removed = 0;
  for (const line of diffLines) {
    if (line.type === "insert") added++;
    else if (line.type === "delete") removed++;
  }
  return { added, removed };
}
function extractDiffData(toolUseResult, toolCall) {
  const filePath = toolCall.input.file_path || "file";
  if (toolUseResult && typeof toolUseResult === "object") {
    const result = toolUseResult;
    if (Array.isArray(result.structuredPatch) && result.structuredPatch.length > 0) {
      const resultFilePath = (typeof result.filePath === "string" ? result.filePath : null) || filePath;
      const hunks = result.structuredPatch;
      const diffLines = structuredPatchToDiffLines(hunks);
      const stats = countLineChanges(diffLines);
      return { filePath: resultFilePath, diffLines, stats };
    }
  }
  return diffFromToolInput(toolCall, filePath);
}
function diffFromToolInput(toolCall, filePath) {
  if (toolCall.name === "Edit") {
    const oldStr = toolCall.input.old_string;
    const newStr = toolCall.input.new_string;
    if (typeof oldStr === "string" && typeof newStr === "string") {
      const diffLines = [];
      const oldLines = oldStr.split("\n");
      const newLines = newStr.split("\n");
      let oldLineNum = 1;
      for (const line of oldLines) {
        diffLines.push({ type: "delete", text: line, oldLineNum: oldLineNum++ });
      }
      let newLineNum = 1;
      for (const line of newLines) {
        diffLines.push({ type: "insert", text: line, newLineNum: newLineNum++ });
      }
      return { filePath, diffLines, stats: countLineChanges(diffLines) };
    }
  }
  if (toolCall.name === "Write") {
    const content = toolCall.input.content;
    if (typeof content === "string") {
      const newLines = content.split("\n");
      const diffLines = newLines.map((text, i2) => ({
        type: "insert",
        text,
        newLineNum: i2 + 1
      }));
      return { filePath, diffLines, stats: { added: newLines.length, removed: 0 } };
    }
  }
  return void 0;
}

// src/features/chat/controllers/StreamController.ts
var _StreamController = class _StreamController {
  constructor(deps) {
    this.deps = deps;
  }
  // ============================================
  // Stream Chunk Handling
  // ============================================
  async handleStreamChunk(chunk, msg) {
    var _a, _b, _c, _d, _e;
    const { state } = this.deps;
    if ("parentToolUseId" in chunk && chunk.parentToolUseId) {
      await this.handleSubagentChunk(chunk, msg);
      this.scrollToBottom();
      return;
    }
    switch (chunk.type) {
      case "thinking":
        this.flushPendingTools();
        if (state.currentTextEl) {
          this.finalizeCurrentTextBlock(msg);
        }
        await this.appendThinking(chunk.content, msg);
        break;
      case "text":
        this.flushPendingTools();
        if (state.currentThinkingState) {
          this.finalizeCurrentThinkingBlock(msg);
        }
        msg.content += chunk.content;
        await this.appendText(chunk.content);
        break;
      case "tool_use": {
        if (state.currentThinkingState) {
          this.finalizeCurrentThinkingBlock(msg);
        }
        this.finalizeCurrentTextBlock(msg);
        if (chunk.name === TOOL_TASK) {
          this.flushPendingTools();
          this.handleTaskToolUseViaManager(chunk, msg);
          break;
        }
        if (chunk.name === TOOL_AGENT_OUTPUT) {
          this.handleAgentOutputToolUse(chunk, msg);
          break;
        }
        this.handleRegularToolUse(chunk, msg);
        break;
      }
      case "tool_result": {
        this.handleToolResult(chunk, msg);
        break;
      }
      case "blocked":
        this.flushPendingTools();
        await this.appendText(`

\u26A0\uFE0F **Blocked:** ${chunk.content}`);
        break;
      case "error":
        this.flushPendingTools();
        await this.appendText(`

\u274C **Error:** ${chunk.content}`);
        break;
      case "done":
        this.flushPendingTools();
        break;
      case "usage": {
        const currentSessionId = (_d = (_c = (_b = (_a = this.deps).getAgentService) == null ? void 0 : _b.call(_a)) == null ? void 0 : _c.getSessionId()) != null ? _d : null;
        const chunkSessionId = (_e = chunk.sessionId) != null ? _e : null;
        if (chunkSessionId && currentSessionId && chunkSessionId !== currentSessionId || chunkSessionId && !currentSessionId) {
          break;
        }
        if (this.deps.subagentManager.subagentsSpawnedThisStream > 0) {
          break;
        }
        if (!state.ignoreUsageUpdates) {
          state.usage = chunk.usage;
        }
        break;
      }
    }
    this.scrollToBottom();
  }
  // ============================================
  // Tool Use Handling
  // ============================================
  /**
   * Handles regular tool_use chunks by buffering them.
   * Tools are rendered when flushPendingTools is called (on next content type or tool_result).
   */
  handleRegularToolUse(chunk, msg) {
    var _a, _b;
    const { state } = this.deps;
    const existingToolCall = (_a = msg.toolCalls) == null ? void 0 : _a.find((tc) => tc.id === chunk.id);
    if (existingToolCall) {
      const newInput = chunk.input || {};
      if (Object.keys(newInput).length > 0) {
        existingToolCall.input = { ...existingToolCall.input, ...newInput };
        if (existingToolCall.name === TOOL_TODO_WRITE) {
          const todos = parseTodoInput(existingToolCall.input);
          if (todos) {
            this.deps.state.currentTodos = todos;
          }
        }
        const toolEl = state.toolCallElements.get(chunk.id);
        if (toolEl) {
          const labelEl = (_b = toolEl.querySelector(".claudian-tool-label")) != null ? _b : toolEl.querySelector(".claudian-write-edit-label");
          if (labelEl) {
            labelEl.setText(getToolLabel(existingToolCall.name, existingToolCall.input));
          }
        }
      }
      return;
    }
    const toolCall = {
      id: chunk.id,
      name: chunk.name,
      input: chunk.input,
      status: "running",
      isExpanded: false
    };
    msg.toolCalls = msg.toolCalls || [];
    msg.toolCalls.push(toolCall);
    msg.contentBlocks = msg.contentBlocks || [];
    msg.contentBlocks.push({ type: "tool_use", toolId: chunk.id });
    if (chunk.name === TOOL_TODO_WRITE) {
      const todos = parseTodoInput(chunk.input);
      if (todos) {
        this.deps.state.currentTodos = todos;
      }
    }
    if (state.currentContentEl) {
      state.pendingTools.set(chunk.id, {
        toolCall,
        parentEl: state.currentContentEl
      });
      this.showThinkingIndicator();
    }
  }
  /**
   * Flushes all pending tool calls by rendering them.
   * Called when a different content type arrives or stream ends.
   */
  flushPendingTools() {
    const { state } = this.deps;
    if (state.pendingTools.size === 0) {
      return;
    }
    for (const toolId of state.pendingTools.keys()) {
      this.renderPendingTool(toolId);
    }
    state.pendingTools.clear();
  }
  /**
   * Renders a single pending tool call and moves it from pending to rendered state.
   */
  renderPendingTool(toolId) {
    const { state } = this.deps;
    const pending = state.pendingTools.get(toolId);
    if (!pending) return;
    const { toolCall, parentEl } = pending;
    if (!parentEl) return;
    if (isWriteEditTool(toolCall.name)) {
      const writeEditState = createWriteEditBlock(parentEl, toolCall);
      state.writeEditStates.set(toolId, writeEditState);
      state.toolCallElements.set(toolId, writeEditState.wrapperEl);
    } else {
      renderToolCall(parentEl, toolCall, state.toolCallElements);
    }
    state.pendingTools.delete(toolId);
  }
  handleToolResult(chunk, msg) {
    var _a;
    const { state, subagentManager } = this.deps;
    if (subagentManager.hasPendingTask(chunk.id)) {
      this.renderPendingTaskViaManager(chunk.id, msg);
    }
    const subagentState = subagentManager.getSyncSubagent(chunk.id);
    if (subagentState) {
      this.finalizeSubagent(chunk, msg);
      return;
    }
    if (this.handleAsyncTaskToolResult(chunk)) {
      this.showThinkingIndicator();
      return;
    }
    if (this.handleAgentOutputToolResult(chunk)) {
      this.showThinkingIndicator();
      return;
    }
    if (state.pendingTools.has(chunk.id)) {
      this.renderPendingTool(chunk.id);
    }
    const existingToolCall = (_a = msg.toolCalls) == null ? void 0 : _a.find((tc) => tc.id === chunk.id);
    const isBlocked = isBlockedToolResult(chunk.content, chunk.isError);
    if (existingToolCall) {
      existingToolCall.status = isBlocked ? "blocked" : chunk.isError ? "error" : "completed";
      existingToolCall.result = chunk.content;
      const writeEditState = state.writeEditStates.get(chunk.id);
      if (writeEditState && isWriteEditTool(existingToolCall.name)) {
        if (!chunk.isError && !isBlocked) {
          const diffData = extractDiffData(chunk.toolUseResult, existingToolCall);
          if (diffData) {
            existingToolCall.diffData = diffData;
            updateWriteEditWithDiff(writeEditState, diffData);
          }
        }
        finalizeWriteEditBlock(writeEditState, chunk.isError || isBlocked);
      } else {
        updateToolCallResult(chunk.id, existingToolCall, state.toolCallElements);
      }
    }
    this.showThinkingIndicator();
  }
  // ============================================
  // Text Block Management
  // ============================================
  async appendText(text) {
    const { state, renderer } = this.deps;
    if (!state.currentContentEl) return;
    this.hideThinkingIndicator();
    if (!state.currentTextEl) {
      state.currentTextEl = state.currentContentEl.createDiv({ cls: "claudian-text-block" });
      state.currentTextContent = "";
    }
    state.currentTextContent += text;
    await renderer.renderContent(state.currentTextEl, state.currentTextContent);
  }
  finalizeCurrentTextBlock(msg) {
    const { state, renderer } = this.deps;
    if (msg && state.currentTextContent) {
      msg.contentBlocks = msg.contentBlocks || [];
      msg.contentBlocks.push({ type: "text", content: state.currentTextContent });
      if (state.currentTextEl) {
        renderer.addTextCopyButton(state.currentTextEl, state.currentTextContent);
      }
    }
    state.currentTextEl = null;
    state.currentTextContent = "";
  }
  // ============================================
  // Thinking Block Management
  // ============================================
  async appendThinking(content, msg) {
    const { state, renderer } = this.deps;
    if (!state.currentContentEl) return;
    this.hideThinkingIndicator();
    if (!state.currentThinkingState) {
      state.currentThinkingState = createThinkingBlock(
        state.currentContentEl,
        (el, md) => renderer.renderContent(el, md)
      );
    }
    await appendThinkingContent(state.currentThinkingState, content, (el, md) => renderer.renderContent(el, md));
  }
  finalizeCurrentThinkingBlock(msg) {
    const { state } = this.deps;
    if (!state.currentThinkingState) return;
    const durationSeconds = finalizeThinkingBlock(state.currentThinkingState);
    if (msg && state.currentThinkingState.content) {
      msg.contentBlocks = msg.contentBlocks || [];
      msg.contentBlocks.push({
        type: "thinking",
        content: state.currentThinkingState.content,
        durationSeconds
      });
    }
    state.currentThinkingState = null;
  }
  // ============================================
  // Task Tool Handling (via SubagentManager)
  // ============================================
  /** Delegates Task tool_use to SubagentManager and updates message based on result. */
  handleTaskToolUseViaManager(chunk, msg) {
    const { state, subagentManager } = this.deps;
    const result = subagentManager.handleTaskToolUse(chunk.id, chunk.input, state.currentContentEl);
    switch (result.action) {
      case "created_sync":
        this.recordSubagentInMessage(msg, result.subagentState.info, chunk.id);
        this.showThinkingIndicator();
        break;
      case "created_async":
        this.recordSubagentInMessage(msg, result.info, chunk.id, "async");
        this.showThinkingIndicator();
        break;
      case "buffered":
        this.showThinkingIndicator();
        break;
      case "label_updated":
        break;
    }
  }
  /** Renders a pending Task via SubagentManager and updates message. */
  renderPendingTaskViaManager(toolId, msg) {
    const result = this.deps.subagentManager.renderPendingTask(toolId, this.deps.state.currentContentEl);
    if (!result) return;
    if (result.mode === "sync") {
      this.recordSubagentInMessage(msg, result.subagentState.info, toolId);
    } else {
      this.recordSubagentInMessage(msg, result.info, toolId, "async");
    }
  }
  recordSubagentInMessage(msg, info, toolId, mode) {
    msg.subagents = msg.subagents || [];
    msg.subagents.push(info);
    msg.contentBlocks = msg.contentBlocks || [];
    msg.contentBlocks.push(
      mode ? { type: "subagent", subagentId: toolId, mode } : { type: "subagent", subagentId: toolId }
    );
  }
  async handleSubagentChunk(chunk, msg) {
    if (!("parentToolUseId" in chunk) || !chunk.parentToolUseId) {
      return;
    }
    const parentToolUseId = chunk.parentToolUseId;
    const { subagentManager } = this.deps;
    if (subagentManager.hasPendingTask(parentToolUseId)) {
      this.renderPendingTaskViaManager(parentToolUseId, msg);
    }
    const subagentState = subagentManager.getSyncSubagent(parentToolUseId);
    if (!subagentState) {
      return;
    }
    switch (chunk.type) {
      case "tool_use": {
        const toolCall = {
          id: chunk.id,
          name: chunk.name,
          input: chunk.input,
          status: "running",
          isExpanded: false
        };
        subagentManager.addSyncToolCall(parentToolUseId, toolCall);
        this.showThinkingIndicator();
        break;
      }
      case "tool_result": {
        const toolCall = subagentState.info.toolCalls.find((tc) => tc.id === chunk.id);
        if (toolCall) {
          const isBlocked = isBlockedToolResult(chunk.content, chunk.isError);
          toolCall.status = isBlocked ? "blocked" : chunk.isError ? "error" : "completed";
          toolCall.result = chunk.content;
          subagentManager.updateSyncToolResult(parentToolUseId, chunk.id, toolCall);
        }
        break;
      }
      case "text":
      case "thinking":
        break;
    }
  }
  /** Finalizes a sync subagent when its Task tool_result is received. */
  finalizeSubagent(chunk, msg) {
    var _a;
    const isError = chunk.isError || false;
    this.deps.subagentManager.finalizeSyncSubagent(chunk.id, chunk.content, isError);
    const subagentInfo = (_a = msg.subagents) == null ? void 0 : _a.find((s) => s.id === chunk.id);
    if (subagentInfo) {
      subagentInfo.status = isError ? "error" : "completed";
      subagentInfo.result = chunk.content;
    }
    this.showThinkingIndicator();
  }
  // ============================================
  // Async Subagent Handling
  // ============================================
  /** Handles TaskOutput tool_use (invisible, links to async subagent). */
  handleAgentOutputToolUse(chunk, _msg) {
    const toolCall = {
      id: chunk.id,
      name: chunk.name,
      input: chunk.input,
      status: "running",
      isExpanded: false
    };
    this.deps.subagentManager.handleAgentOutputToolUse(toolCall);
    this.showThinkingIndicator();
  }
  handleAsyncTaskToolResult(chunk) {
    const { subagentManager } = this.deps;
    if (!subagentManager.isPendingAsyncTask(chunk.id)) {
      return false;
    }
    subagentManager.handleTaskToolResult(chunk.id, chunk.content, chunk.isError);
    return true;
  }
  /** Handles TaskOutput result to finalize async subagent. */
  handleAgentOutputToolResult(chunk) {
    const { subagentManager } = this.deps;
    const isLinked = subagentManager.isLinkedAgentOutputTool(chunk.id);
    const handled = subagentManager.handleAgentOutputToolResult(
      chunk.id,
      chunk.content,
      chunk.isError || false
    );
    return isLinked || handled !== void 0;
  }
  /** Callback from SubagentManager when async state changes. Updates messages only (DOM handled by manager). */
  onAsyncSubagentStateChange(subagent) {
    this.updateSubagentInMessages(subagent);
    this.scrollToBottom();
  }
  updateSubagentInMessages(subagent) {
    const { state } = this.deps;
    for (let i2 = state.messages.length - 1; i2 >= 0; i2--) {
      const msg = state.messages[i2];
      if (msg.role === "assistant" && msg.subagents) {
        const idx = msg.subagents.findIndex((s) => s.id === subagent.id);
        if (idx !== -1) {
          msg.subagents[idx] = subagent;
          return;
        }
      }
    }
  }
  /**
   * Schedules showing the thinking indicator after a delay.
   * If content arrives before the delay, the indicator won't show.
   * This prevents the indicator from appearing during active streaming.
   * Note: Flavor text is hidden when model thinking block is active (thinking takes priority).
   */
  showThinkingIndicator() {
    const { state } = this.deps;
    if (!state.currentContentEl) return;
    if (state.thinkingIndicatorTimeout) {
      clearTimeout(state.thinkingIndicatorTimeout);
      state.thinkingIndicatorTimeout = null;
    }
    if (state.currentThinkingState) {
      return;
    }
    if (state.thinkingEl) {
      state.currentContentEl.appendChild(state.thinkingEl);
      this.deps.updateQueueIndicator();
      return;
    }
    state.thinkingIndicatorTimeout = setTimeout(() => {
      state.thinkingIndicatorTimeout = null;
      if (!state.currentContentEl || state.thinkingEl || state.currentThinkingState) return;
      state.thinkingEl = state.currentContentEl.createDiv({ cls: "claudian-thinking" });
      const randomText = FLAVOR_TEXTS[Math.floor(Math.random() * FLAVOR_TEXTS.length)];
      state.thinkingEl.createSpan({ text: randomText });
      const timerSpan = state.thinkingEl.createSpan({ cls: "claudian-thinking-hint" });
      const updateTimer = () => {
        if (!state.responseStartTime) return;
        if (!timerSpan.isConnected) {
          if (state.flavorTimerInterval) {
            clearInterval(state.flavorTimerInterval);
            state.flavorTimerInterval = null;
          }
          return;
        }
        const elapsedSeconds = Math.floor((performance.now() - state.responseStartTime) / 1e3);
        timerSpan.setText(` (esc to interrupt \xB7 ${formatDurationMmSs(elapsedSeconds)})`);
      };
      updateTimer();
      if (state.flavorTimerInterval) {
        clearInterval(state.flavorTimerInterval);
      }
      state.flavorTimerInterval = setInterval(updateTimer, 1e3);
      state.queueIndicatorEl = state.thinkingEl.createDiv({ cls: "claudian-queue-indicator" });
      this.deps.updateQueueIndicator();
    }, _StreamController.THINKING_INDICATOR_DELAY);
  }
  /** Hides the thinking indicator and cancels any pending show timeout. */
  hideThinkingIndicator() {
    const { state } = this.deps;
    if (state.thinkingIndicatorTimeout) {
      clearTimeout(state.thinkingIndicatorTimeout);
      state.thinkingIndicatorTimeout = null;
    }
    state.clearFlavorTimerInterval();
    if (state.thinkingEl) {
      state.thinkingEl.remove();
      state.thinkingEl = null;
    }
    state.queueIndicatorEl = null;
  }
  // ============================================
  // Utilities
  // ============================================
  /** Scrolls messages to bottom if auto-scroll is enabled. */
  scrollToBottom() {
    var _a;
    const { state, plugin } = this.deps;
    if (!((_a = plugin.settings.enableAutoScroll) != null ? _a : true)) return;
    if (!state.autoScrollEnabled) return;
    const messagesEl = this.deps.getMessagesEl();
    messagesEl.scrollTop = messagesEl.scrollHeight;
  }
  resetStreamingState() {
    const { state } = this.deps;
    this.hideThinkingIndicator();
    state.currentContentEl = null;
    state.currentTextEl = null;
    state.currentTextContent = "";
    state.currentThinkingState = null;
    this.deps.subagentManager.resetStreamingState();
    state.pendingTools.clear();
    state.responseStartTime = null;
  }
};
// ============================================
// Thinking Indicator
// ============================================
/** Debounce delay before showing thinking indicator (ms). */
_StreamController.THINKING_INDICATOR_DELAY = 400;
var StreamController = _StreamController;

// src/core/prompts/instructionRefine.ts
function buildRefineSystemPrompt(existingInstructions) {
  const existingSection = existingInstructions.trim() ? `

EXISTING INSTRUCTIONS (already in the user's system prompt):
\`\`\`
${existingInstructions.trim()}
\`\`\`

When refining the new instruction:
- Consider how it fits with existing instructions
- Avoid duplicating existing instructions
- If the new instruction conflicts with an existing one, refine it to be complementary or note the conflict
- Match the format of existing instructions (section, heading, bullet points, style, etc.)` : "";
  return `You are an expert Prompt Engineer. You help users craft precise, effective system instructions for their AI assistant.

**Your Goal**: Transform vague or simple user requests into **high-quality, actionable, and non-conflicting** system prompt instructions.

**Process**:
1.  **Analyze Intent**: What behavior does the user want to enforce or change?
2.  **Check Context**: Does this conflict with existing instructions?
    - *No Conflict*: Add as new.
    - *Conflict*: Propose a **merged instruction** that resolves the contradiction (or ask if unsure).
3.  **Refine**: Draft a clear, positive instruction (e.g., "Do X" instead of "Don't do Y").
4.  **Format**: Return *only* the Markdown snippet wrapped in \`<instruction>\` tags.

**Guidelines**:
- **Clarity**: Use precise language. Avoid ambiguity.
- **Scope**: Keep it focused. Don't add unrelated rules.
- **Format**: Valid Markdown (bullets \`-\` or sections \`##\`).
- **No Header**: Do NOT include a top-level header like \`# Custom Instructions\`.
- **Conflict Handling**: If the new rule directly contradicts an existing one, rewrite the *new* one to override specific cases or ask for clarification.

**Output Format**:
- **Success**: \`<instruction>...markdown content...</instruction>\`
- **Ambiguity**: Plain text question.

${existingSection}

**Examples**:

Input: "typescript for code"
Output: <instruction>- **Code Language**: Always use TypeScript for code examples. Include proper type annotations and interfaces.</instruction>

Input: "be concise"
Output: <instruction>- **Conciseness**: Provide brief, direct responses. Omit conversational filler and unnecessary explanations.</instruction>

Input: "organize coding style rules"
Output: <instruction>## Coding Standards

- **Language**: Use TypeScript.
- **Style**: Prefer functional patterns.
- **Review**: Keep diffs small.</instruction>

Input: "use that thing from before"
Output: I'm not sure what you're referring to. Could you please clarify?`;
}

// src/features/chat/services/InstructionRefineService.ts
var InstructionRefineService = class {
  constructor(plugin) {
    this.abortController = null;
    this.sessionId = null;
    this.existingInstructions = "";
    this.plugin = plugin;
  }
  /** Resets conversation state for a new refinement session. */
  resetConversation() {
    this.sessionId = null;
  }
  /** Refines a raw instruction from user input. */
  async refineInstruction(rawInstruction, existingInstructions, onProgress) {
    this.sessionId = null;
    this.existingInstructions = existingInstructions;
    const prompt = `Please refine this instruction: "${rawInstruction}"`;
    return this.sendMessage(prompt, onProgress);
  }
  /** Continues conversation with a follow-up message (for clarifications). */
  async continueConversation(message, onProgress) {
    if (!this.sessionId) {
      return { success: false, error: "No active conversation to continue" };
    }
    return this.sendMessage(message, onProgress);
  }
  /** Cancels any ongoing query. */
  cancel() {
    if (this.abortController) {
      this.abortController.abort();
      this.abortController = null;
    }
  }
  async sendMessage(prompt, onProgress) {
    var _a;
    const vaultPath = getVaultPath(this.plugin.app);
    if (!vaultPath) {
      return { success: false, error: "Could not determine vault path" };
    }
    const resolvedClaudePath = this.plugin.getResolvedClaudeCliPath();
    if (!resolvedClaudePath) {
      return { success: false, error: "Claude CLI not found. Please install Claude Code CLI." };
    }
    this.abortController = new AbortController();
    const customEnv = parseEnvironmentVariables(this.plugin.getActiveEnvironmentVariables());
    const enhancedPath = getEnhancedPath(customEnv.PATH, resolvedClaudePath);
    const missingNodeError = getMissingNodeError(resolvedClaudePath, enhancedPath);
    if (missingNodeError) {
      return { success: false, error: missingNodeError };
    }
    const options = {
      cwd: vaultPath,
      systemPrompt: buildRefineSystemPrompt(this.existingInstructions),
      model: this.plugin.settings.model,
      abortController: this.abortController,
      pathToClaudeCodeExecutable: resolvedClaudePath,
      env: {
        ...process.env,
        ...customEnv,
        PATH: enhancedPath
      },
      tools: [],
      // No tools needed for instruction refinement
      permissionMode: "bypassPermissions",
      allowDangerouslySkipPermissions: true,
      settingSources: this.plugin.settings.loadUserClaudeSettings ? ["user", "project"] : ["project"]
    };
    if (this.sessionId) {
      options.resume = this.sessionId;
    }
    const budgetSetting = this.plugin.settings.thinkingBudget;
    const budgetConfig = THINKING_BUDGETS.find((b3) => b3.value === budgetSetting);
    if (budgetConfig && budgetConfig.tokens > 0) {
      options.maxThinkingTokens = budgetConfig.tokens;
    }
    try {
      const response = u_({ prompt, options });
      let responseText = "";
      for await (const message of response) {
        if ((_a = this.abortController) == null ? void 0 : _a.signal.aborted) {
          await response.interrupt();
          return { success: false, error: "Cancelled" };
        }
        if (message.type === "system" && message.subtype === "init" && message.session_id) {
          this.sessionId = message.session_id;
        }
        const text = this.extractTextFromMessage(message);
        if (text) {
          responseText += text;
          if (onProgress) {
            const partialResult = this.parseResponse(responseText);
            onProgress(partialResult);
          }
        }
      }
      return this.parseResponse(responseText);
    } catch (error) {
      const msg = error instanceof Error ? error.message : "Unknown error";
      return { success: false, error: msg };
    } finally {
      this.abortController = null;
    }
  }
  /** Parses response text for <instruction> tag. */
  parseResponse(responseText) {
    const instructionMatch = responseText.match(/<instruction>([\s\S]*?)<\/instruction>/);
    if (instructionMatch) {
      return { success: true, refinedInstruction: instructionMatch[1].trim() };
    }
    const trimmed = responseText.trim();
    if (trimmed) {
      return { success: true, clarification: trimmed };
    }
    return { success: false, error: "Empty response" };
  }
  /** Extracts text content from SDK message. */
  extractTextFromMessage(message) {
    var _a;
    if (message.type !== "assistant" || !((_a = message.message) == null ? void 0 : _a.content)) {
      return "";
    }
    return message.message.content.filter((block) => block.type === "text" && !!block.text).map((block) => block.text).join("");
  }
};

// src/features/chat/services/SubagentManager.ts
var SubagentManager = class {
  constructor(onStateChange) {
    this.syncSubagents = /* @__PURE__ */ new Map();
    this.pendingTasks = /* @__PURE__ */ new Map();
    this._spawnedThisStream = 0;
    this.activeAsyncSubagents = /* @__PURE__ */ new Map();
    this.pendingAsyncSubagents = /* @__PURE__ */ new Map();
    this.taskIdToAgentId = /* @__PURE__ */ new Map();
    this.outputToolIdToAgentId = /* @__PURE__ */ new Map();
    this.asyncDomStates = /* @__PURE__ */ new Map();
    this.onStateChange = onStateChange;
  }
  setCallback(callback) {
    this.onStateChange = callback;
  }
  // ============================================
  // Unified Task Entry Point
  // ============================================
  /**
   * Handles a Task tool_use chunk with minimal buffering to determine sync vs async.
   * Returns a typed result so StreamController can update messages accordingly.
   */
  handleTaskToolUse(taskToolId, taskInput, currentContentEl) {
    const existingSyncState = this.syncSubagents.get(taskToolId);
    if (existingSyncState) {
      this.updateSubagentLabel(existingSyncState.wrapperEl, existingSyncState.info, taskInput);
      return { action: "label_updated" };
    }
    const existingAsyncState = this.asyncDomStates.get(taskToolId);
    if (existingAsyncState) {
      this.updateSubagentLabel(existingAsyncState.wrapperEl, existingAsyncState.info, taskInput);
      const canonical = this.getByTaskId(taskToolId);
      if (canonical && canonical !== existingAsyncState.info) {
        if (taskInput.description) canonical.description = taskInput.description;
        if (taskInput.prompt) canonical.prompt = taskInput.prompt;
      }
      return { action: "label_updated" };
    }
    const pending = this.pendingTasks.get(taskToolId);
    if (pending) {
      const newInput = taskInput || {};
      if (Object.keys(newInput).length > 0) {
        pending.toolCall.input = { ...pending.toolCall.input, ...newInput };
      }
      if (currentContentEl) {
        pending.parentEl = currentContentEl;
      }
      const runInBackground2 = pending.toolCall.input.run_in_background;
      if (runInBackground2 !== void 0) {
        const result = this.renderPendingTask(taskToolId, currentContentEl);
        if (result) {
          return result.mode === "sync" ? { action: "created_sync", subagentState: result.subagentState } : { action: "created_async", info: result.info, domState: result.domState };
        }
      }
      return { action: "buffered" };
    }
    if (!currentContentEl) {
      const toolCall2 = {
        id: taskToolId,
        name: "Task",
        input: taskInput || {},
        status: "running",
        isExpanded: false
      };
      this.pendingTasks.set(taskToolId, { toolCall: toolCall2, parentEl: null });
      return { action: "buffered" };
    }
    const runInBackground = taskInput == null ? void 0 : taskInput.run_in_background;
    if (runInBackground !== void 0) {
      this._spawnedThisStream++;
      if (runInBackground === true) {
        return this.createAsyncTask(taskToolId, taskInput, currentContentEl);
      } else {
        return this.createSyncTask(taskToolId, taskInput, currentContentEl);
      }
    }
    const toolCall = {
      id: taskToolId,
      name: "Task",
      input: taskInput || {},
      status: "running",
      isExpanded: false
    };
    this.pendingTasks.set(taskToolId, {
      toolCall,
      parentEl: currentContentEl
    });
    return { action: "buffered" };
  }
  // ============================================
  // Pending Task Resolution
  // ============================================
  hasPendingTask(toolId) {
    return this.pendingTasks.has(toolId);
  }
  /**
   * Renders a buffered pending task. Called when a child chunk or tool_result
   * confirms the task is sync, or when run_in_background becomes known.
   * Uses the optional parentEl override, falling back to the stored parentEl.
   */
  renderPendingTask(toolId, parentElOverride) {
    const pending = this.pendingTasks.get(toolId);
    if (!pending) return null;
    const input = pending.toolCall.input;
    const targetEl = parentElOverride != null ? parentElOverride : pending.parentEl;
    if (!targetEl) return null;
    this.pendingTasks.delete(toolId);
    try {
      if (input.run_in_background === true) {
        const result = this.createAsyncTask(pending.toolCall.id, input, targetEl);
        if (result.action === "created_async") {
          this._spawnedThisStream++;
          return { mode: "async", info: result.info, domState: result.domState };
        }
      } else {
        const result = this.createSyncTask(pending.toolCall.id, input, targetEl);
        if (result.action === "created_sync") {
          this._spawnedThisStream++;
          return { mode: "sync", subagentState: result.subagentState };
        }
      }
    } catch (e2) {
    }
    return null;
  }
  // ============================================
  // Sync Subagent Operations
  // ============================================
  getSyncSubagent(toolId) {
    return this.syncSubagents.get(toolId);
  }
  addSyncToolCall(parentToolUseId, toolCall) {
    const subagentState = this.syncSubagents.get(parentToolUseId);
    if (!subagentState) return;
    addSubagentToolCall(subagentState, toolCall);
  }
  updateSyncToolResult(parentToolUseId, toolId, toolCall) {
    const subagentState = this.syncSubagents.get(parentToolUseId);
    if (!subagentState) return;
    updateSubagentToolResult(subagentState, toolId, toolCall);
  }
  finalizeSyncSubagent(toolId, result, isError) {
    const subagentState = this.syncSubagents.get(toolId);
    if (!subagentState) return null;
    finalizeSubagentBlock(subagentState, result, isError);
    this.syncSubagents.delete(toolId);
    return subagentState.info;
  }
  // ============================================
  // Async Subagent Lifecycle
  // ============================================
  isAsyncTask(taskInput) {
    return taskInput.run_in_background === true;
  }
  handleTaskToolResult(taskToolId, result, isError) {
    const subagent = this.pendingAsyncSubagents.get(taskToolId);
    if (!subagent) return;
    if (isError) {
      this.transitionToError(subagent, taskToolId, result || "Task failed to start");
      return;
    }
    const agentId = this.parseAgentId(result);
    if (!agentId) {
      const truncatedResult = result.length > 100 ? result.substring(0, 100) + "..." : result;
      this.transitionToError(subagent, taskToolId, `Failed to parse agent_id. Result: ${truncatedResult}`);
      return;
    }
    subagent.asyncStatus = "running";
    subagent.agentId = agentId;
    subagent.startedAt = Date.now();
    this.pendingAsyncSubagents.delete(taskToolId);
    this.activeAsyncSubagents.set(agentId, subagent);
    this.taskIdToAgentId.set(taskToolId, agentId);
    this.updateAsyncDomState(subagent);
    this.onStateChange(subagent);
  }
  handleAgentOutputToolUse(toolCall) {
    const agentId = this.extractAgentIdFromInput(toolCall.input);
    if (!agentId) return;
    const subagent = this.activeAsyncSubagents.get(agentId);
    if (!subagent) return;
    subagent.outputToolId = toolCall.id;
    this.outputToolIdToAgentId.set(toolCall.id, agentId);
  }
  handleAgentOutputToolResult(toolId, result, isError) {
    let agentId = this.outputToolIdToAgentId.get(toolId);
    let subagent = agentId ? this.activeAsyncSubagents.get(agentId) : void 0;
    if (!subagent) {
      const inferredAgentId = this.inferAgentIdFromResult(result);
      if (inferredAgentId) {
        agentId = inferredAgentId;
        subagent = this.activeAsyncSubagents.get(inferredAgentId);
      }
    }
    if (!subagent) return void 0;
    if (agentId) {
      subagent.agentId = subagent.agentId || agentId;
      this.outputToolIdToAgentId.set(toolId, agentId);
    }
    if (subagent.asyncStatus !== "running") {
      return void 0;
    }
    const stillRunning = this.isStillRunningResult(result, isError);
    if (stillRunning) {
      this.outputToolIdToAgentId.delete(toolId);
      return subagent;
    }
    const extractedResult = this.extractAgentResult(result, agentId != null ? agentId : "");
    subagent.asyncStatus = isError ? "error" : "completed";
    subagent.status = isError ? "error" : "completed";
    subagent.result = extractedResult;
    subagent.completedAt = Date.now();
    if (agentId) this.activeAsyncSubagents.delete(agentId);
    this.outputToolIdToAgentId.delete(toolId);
    this.updateAsyncDomState(subagent);
    this.onStateChange(subagent);
    return subagent;
  }
  isPendingAsyncTask(taskToolId) {
    return this.pendingAsyncSubagents.has(taskToolId);
  }
  isLinkedAgentOutputTool(toolId) {
    return this.outputToolIdToAgentId.has(toolId);
  }
  getByAgentId(agentId) {
    return this.activeAsyncSubagents.get(agentId);
  }
  getByTaskId(taskToolId) {
    const pending = this.pendingAsyncSubagents.get(taskToolId);
    if (pending) return pending;
    const agentId = this.taskIdToAgentId.get(taskToolId);
    if (agentId) {
      return this.activeAsyncSubagents.get(agentId);
    }
    return void 0;
  }
  getAsyncDomState(taskToolId) {
    return this.asyncDomStates.get(taskToolId);
  }
  // ============================================
  // Lifecycle
  // ============================================
  get subagentsSpawnedThisStream() {
    return this._spawnedThisStream;
  }
  resetSpawnedCount() {
    this._spawnedThisStream = 0;
  }
  resetStreamingState() {
    this.syncSubagents.clear();
    this.pendingTasks.clear();
  }
  orphanAllActive() {
    const orphaned = [];
    for (const subagent of this.pendingAsyncSubagents.values()) {
      this.markOrphaned(subagent);
      orphaned.push(subagent);
    }
    for (const subagent of this.activeAsyncSubagents.values()) {
      if (subagent.asyncStatus === "running") {
        this.markOrphaned(subagent);
        orphaned.push(subagent);
      }
    }
    this.pendingAsyncSubagents.clear();
    this.activeAsyncSubagents.clear();
    this.taskIdToAgentId.clear();
    this.outputToolIdToAgentId.clear();
    return orphaned;
  }
  clear() {
    this.syncSubagents.clear();
    this.pendingTasks.clear();
    this.pendingAsyncSubagents.clear();
    this.activeAsyncSubagents.clear();
    this.taskIdToAgentId.clear();
    this.outputToolIdToAgentId.clear();
    this.asyncDomStates.clear();
  }
  getAllActive() {
    return [
      ...this.pendingAsyncSubagents.values(),
      ...this.activeAsyncSubagents.values()
    ];
  }
  hasActiveAsync() {
    return this.pendingAsyncSubagents.size > 0 || this.activeAsyncSubagents.size > 0;
  }
  // ============================================
  // Private: State Transitions
  // ============================================
  markOrphaned(subagent) {
    subagent.asyncStatus = "orphaned";
    subagent.status = "error";
    subagent.result = "Conversation ended before task completed";
    subagent.completedAt = Date.now();
    this.updateAsyncDomState(subagent);
    this.onStateChange(subagent);
  }
  transitionToError(subagent, taskToolId, errorResult) {
    subagent.asyncStatus = "error";
    subagent.status = "error";
    subagent.result = errorResult;
    subagent.completedAt = Date.now();
    this.pendingAsyncSubagents.delete(taskToolId);
    this.updateAsyncDomState(subagent);
    this.onStateChange(subagent);
  }
  // ============================================
  // Private: Task Creation
  // ============================================
  createSyncTask(taskToolId, taskInput, parentEl) {
    const subagentState = createSubagentBlock(parentEl, taskToolId, taskInput);
    this.syncSubagents.set(taskToolId, subagentState);
    return { action: "created_sync", subagentState };
  }
  createAsyncTask(taskToolId, taskInput, parentEl) {
    const description = taskInput.description || "Background task";
    const prompt = taskInput.prompt || "";
    const info = {
      id: taskToolId,
      description,
      prompt,
      mode: "async",
      isExpanded: false,
      status: "running",
      toolCalls: [],
      asyncStatus: "pending"
    };
    this.pendingAsyncSubagents.set(taskToolId, info);
    const domState = createAsyncSubagentBlock(parentEl, taskToolId, taskInput);
    this.asyncDomStates.set(taskToolId, domState);
    return { action: "created_async", info, domState };
  }
  // ============================================
  // Private: Label Update
  // ============================================
  updateSubagentLabel(wrapperEl, info, newInput) {
    if (!newInput || Object.keys(newInput).length === 0) return;
    const description = newInput.description || "";
    if (description) {
      info.description = description;
      const labelEl = wrapperEl.querySelector(".claudian-subagent-label");
      if (labelEl) {
        const truncated = description.length > 40 ? description.substring(0, 40) + "..." : description;
        labelEl.setText(truncated);
      }
    }
    const prompt = newInput.prompt || "";
    if (prompt) {
      info.prompt = prompt;
    }
  }
  // ============================================
  // Private: Async DOM State Updates
  // ============================================
  updateAsyncDomState(subagent) {
    let asyncState = this.asyncDomStates.get(subagent.id);
    if (!asyncState) {
      for (const s of this.asyncDomStates.values()) {
        if (s.info.agentId === subagent.agentId) {
          asyncState = s;
          break;
        }
      }
      if (!asyncState) return;
    }
    asyncState.info = subagent;
    switch (subagent.asyncStatus) {
      case "running":
        updateAsyncSubagentRunning(asyncState, subagent.agentId || "");
        break;
      case "completed":
      case "error":
        finalizeAsyncSubagent(asyncState, subagent.result || "", subagent.asyncStatus === "error");
        break;
      case "orphaned":
        markAsyncSubagentOrphaned(asyncState);
        break;
    }
  }
  // ============================================
  // Private: Async Parsing Logic
  // ============================================
  isStillRunningResult(result, isError) {
    const trimmed = (result == null ? void 0 : result.trim()) || "";
    const payload = this.unwrapTextPayload(trimmed);
    if (isError) return false;
    if (!trimmed) return false;
    try {
      const parsed = JSON.parse(payload);
      const status = parsed.retrieval_status || parsed.status;
      const hasAgents = parsed.agents && Object.keys(parsed.agents).length > 0;
      if (status === "not_ready" || status === "running" || status === "pending") {
        return true;
      }
      if (hasAgents) {
        const agentStatuses = Object.values(parsed.agents).map((a) => a && typeof a.status === "string" ? a.status.toLowerCase() : "");
        const anyRunning = agentStatuses.some(
          (s) => s === "running" || s === "pending" || s === "not_ready"
        );
        if (anyRunning) return true;
        return false;
      }
      if (status === "success" || status === "completed") {
        return false;
      }
      return false;
    } catch (e2) {
    }
    const lowerResult = payload.toLowerCase();
    if (lowerResult.includes("not_ready") || lowerResult.includes("not ready")) {
      return true;
    }
    const xmlStatusMatch = lowerResult.match(/<status>([^<]+)<\/status>/);
    if (xmlStatusMatch) {
      const status = xmlStatusMatch[1].trim();
      if (status === "running" || status === "pending" || status === "not_ready") {
        return true;
      }
    }
    return false;
  }
  extractAgentResult(result, agentId) {
    const payload = this.unwrapTextPayload(result);
    try {
      const parsed = JSON.parse(payload);
      if (parsed.agents && agentId && parsed.agents[agentId]) {
        const agentData = parsed.agents[agentId];
        if (agentData.result) {
          return agentData.result;
        }
        return JSON.stringify(agentData, null, 2);
      }
      if (parsed.agents) {
        const agentIds = Object.keys(parsed.agents);
        if (agentIds.length > 0) {
          const firstAgent = parsed.agents[agentIds[0]];
          if (firstAgent.result) {
            return firstAgent.result;
          }
          return JSON.stringify(firstAgent, null, 2);
        }
      }
    } catch (e2) {
    }
    return payload;
  }
  parseAgentId(result) {
    var _a;
    const regexPatterns = [
      /"agent_id"\s*:\s*"([^"]+)"/,
      /"agentId"\s*:\s*"([^"]+)"/,
      /agent_id[=:]\s*"?([a-zA-Z0-9_-]+)"?/i,
      /agentId[=:]\s*"?([a-zA-Z0-9_-]+)"?/i,
      /\b([a-f0-9]{8})\b/
    ];
    for (const pattern of regexPatterns) {
      const match = result.match(pattern);
      if (match && match[1]) {
        return match[1];
      }
    }
    try {
      const parsed = JSON.parse(result);
      const agentId = parsed.agent_id || parsed.agentId;
      if (typeof agentId === "string" && agentId.length > 0) {
        return agentId;
      }
      if ((_a = parsed.data) == null ? void 0 : _a.agent_id) {
        return parsed.data.agent_id;
      }
      if (parsed.id && typeof parsed.id === "string") {
        return parsed.id;
      }
    } catch (e2) {
    }
    return null;
  }
  inferAgentIdFromResult(result) {
    try {
      const parsed = JSON.parse(result);
      if (parsed.agents && typeof parsed.agents === "object") {
        const keys = Object.keys(parsed.agents);
        if (keys.length > 0) {
          return keys[0];
        }
      }
    } catch (e2) {
    }
    return null;
  }
  unwrapTextPayload(raw) {
    try {
      const parsed = JSON.parse(raw);
      if (Array.isArray(parsed)) {
        const textBlock = parsed.find((b3) => b3 && typeof b3.text === "string");
        if (textBlock == null ? void 0 : textBlock.text) return textBlock.text;
      } else if (parsed && typeof parsed === "object" && typeof parsed.text === "string") {
        return parsed.text;
      }
    } catch (e2) {
    }
    return raw;
  }
  extractAgentIdFromInput(input) {
    const agentId = input.task_id || input.agentId || input.agent_id;
    return agentId || null;
  }
};

// src/core/prompts/titleGeneration.ts
var TITLE_GENERATION_SYSTEM_PROMPT = `You are a specialist in summarizing user intent.

**Task**: Generate a **concise, descriptive title** (max 50 chars) summarizing the user's task/request.

**Rules**:
1.  **Format**: Sentence case. No periods/quotes.
2.  **Structure**: Start with a **strong verb** (e.g., Create, Fix, Debug, Explain, Analyze).
3.  **Forbidden**: "Conversation with...", "Help me...", "Question about...", "I need...".
4.  **Tech Context**: Detect and include the primary language/framework if code is present (e.g., "Debug Python script", "Refactor React hook").

**Output**: Return ONLY the raw title text.`;

// src/features/chat/services/TitleGenerationService.ts
var TitleGenerationService = class {
  constructor(plugin) {
    this.activeGenerations = /* @__PURE__ */ new Map();
    this.plugin = plugin;
  }
  /**
   * Generates a title for a conversation based on the first user message.
   * Non-blocking: calls callback when complete.
   */
  async generateTitle(conversationId, userMessage, callback) {
    const vaultPath = getVaultPath(this.plugin.app);
    if (!vaultPath) {
      await this.safeCallback(callback, conversationId, {
        success: false,
        error: "Could not determine vault path"
      });
      return;
    }
    const envVars = parseEnvironmentVariables(
      this.plugin.getActiveEnvironmentVariables()
    );
    const resolvedClaudePath = this.plugin.getResolvedClaudeCliPath();
    if (!resolvedClaudePath) {
      await this.safeCallback(callback, conversationId, {
        success: false,
        error: "Claude CLI not found"
      });
      return;
    }
    const enhancedPath = getEnhancedPath(envVars.PATH, resolvedClaudePath);
    const missingNodeError = getMissingNodeError(resolvedClaudePath, enhancedPath);
    if (missingNodeError) {
      await this.safeCallback(callback, conversationId, {
        success: false,
        error: missingNodeError
      });
      return;
    }
    const titleModel = this.plugin.settings.titleGenerationModel || envVars.ANTHROPIC_DEFAULT_HAIKU_MODEL || "claude-haiku-4-5";
    const existingController = this.activeGenerations.get(conversationId);
    if (existingController) {
      existingController.abort();
    }
    const abortController = new AbortController();
    this.activeGenerations.set(conversationId, abortController);
    const truncatedUser = this.truncateText(userMessage, 500);
    const prompt = `User's request:
"""
${truncatedUser}
"""

Generate a title for this conversation:`;
    const options = {
      cwd: vaultPath,
      systemPrompt: TITLE_GENERATION_SYSTEM_PROMPT,
      model: titleModel,
      abortController,
      pathToClaudeCodeExecutable: resolvedClaudePath,
      env: {
        ...process.env,
        ...envVars,
        PATH: enhancedPath
      },
      tools: [],
      // No tools needed for title generation
      permissionMode: "bypassPermissions",
      allowDangerouslySkipPermissions: true,
      settingSources: this.plugin.settings.loadUserClaudeSettings ? ["user", "project"] : ["project"],
      persistSession: false
      // Don't save title generation queries to session history
    };
    try {
      const response = u_({ prompt, options });
      let responseText = "";
      for await (const message of response) {
        if (abortController.signal.aborted) {
          await this.safeCallback(callback, conversationId, {
            success: false,
            error: "Cancelled"
          });
          return;
        }
        const text = this.extractTextFromMessage(message);
        if (text) {
          responseText += text;
        }
      }
      const title = this.parseTitle(responseText);
      if (title) {
        await this.safeCallback(callback, conversationId, { success: true, title });
      } else {
        await this.safeCallback(callback, conversationId, {
          success: false,
          error: "Failed to parse title from response"
        });
      }
    } catch (error) {
      const msg = error instanceof Error ? error.message : "Unknown error";
      await this.safeCallback(callback, conversationId, { success: false, error: msg });
    } finally {
      this.activeGenerations.delete(conversationId);
    }
  }
  /** Cancels all ongoing title generations. */
  cancel() {
    for (const controller of this.activeGenerations.values()) {
      controller.abort();
    }
    this.activeGenerations.clear();
  }
  /** Truncates text to a maximum length with ellipsis. */
  truncateText(text, maxLength) {
    if (text.length <= maxLength) return text;
    return text.substring(0, maxLength) + "...";
  }
  /** Extracts text content from SDK message. */
  extractTextFromMessage(message) {
    var _a;
    if (message.type !== "assistant" || !((_a = message.message) == null ? void 0 : _a.content)) {
      return "";
    }
    return message.message.content.filter(
      (block) => block.type === "text" && !!block.text
    ).map((block) => block.text).join("");
  }
  /** Parses and cleans the title from response. */
  parseTitle(responseText) {
    const trimmed = responseText.trim();
    if (!trimmed) return null;
    let title = trimmed;
    if (title.startsWith('"') && title.endsWith('"') || title.startsWith("'") && title.endsWith("'")) {
      title = title.slice(1, -1);
    }
    title = title.replace(/[.!?:;,]+$/, "");
    if (title.length > 50) {
      title = title.substring(0, 47) + "...";
    }
    return title || null;
  }
  /** Safely invokes callback with try-catch to prevent unhandled errors. */
  async safeCallback(callback, conversationId, result) {
    try {
      await callback(conversationId, result);
    } catch (e2) {
    }
  }
};

// src/features/chat/state/ChatState.ts
function createInitialState() {
  return {
    messages: [],
    isStreaming: false,
    cancelRequested: false,
    streamGeneration: 0,
    isCreatingConversation: false,
    isSwitchingConversation: false,
    currentConversationId: null,
    queuedMessage: null,
    currentContentEl: null,
    currentTextEl: null,
    currentTextContent: "",
    currentThinkingState: null,
    thinkingEl: null,
    queueIndicatorEl: null,
    thinkingIndicatorTimeout: null,
    toolCallElements: /* @__PURE__ */ new Map(),
    writeEditStates: /* @__PURE__ */ new Map(),
    pendingTools: /* @__PURE__ */ new Map(),
    usage: null,
    ignoreUsageUpdates: false,
    currentTodos: null,
    needsAttention: false,
    autoScrollEnabled: true,
    // Default; controllers will override based on settings
    responseStartTime: null,
    flavorTimerInterval: null
  };
}
var ChatState = class {
  constructor(callbacks = {}) {
    this.state = createInitialState();
    this._callbacks = callbacks;
  }
  get callbacks() {
    return this._callbacks;
  }
  set callbacks(value) {
    this._callbacks = value;
  }
  // ============================================
  // Messages
  // ============================================
  get messages() {
    return [...this.state.messages];
  }
  set messages(value) {
    var _a, _b;
    this.state.messages = value;
    (_b = (_a = this._callbacks).onMessagesChanged) == null ? void 0 : _b.call(_a);
  }
  addMessage(msg) {
    var _a, _b;
    this.state.messages.push(msg);
    (_b = (_a = this._callbacks).onMessagesChanged) == null ? void 0 : _b.call(_a);
  }
  clearMessages() {
    var _a, _b;
    this.state.messages = [];
    (_b = (_a = this._callbacks).onMessagesChanged) == null ? void 0 : _b.call(_a);
  }
  // ============================================
  // Streaming Control
  // ============================================
  get isStreaming() {
    return this.state.isStreaming;
  }
  set isStreaming(value) {
    var _a, _b;
    this.state.isStreaming = value;
    (_b = (_a = this._callbacks).onStreamingStateChanged) == null ? void 0 : _b.call(_a, value);
  }
  get cancelRequested() {
    return this.state.cancelRequested;
  }
  set cancelRequested(value) {
    this.state.cancelRequested = value;
  }
  get streamGeneration() {
    return this.state.streamGeneration;
  }
  bumpStreamGeneration() {
    this.state.streamGeneration += 1;
    return this.state.streamGeneration;
  }
  get isCreatingConversation() {
    return this.state.isCreatingConversation;
  }
  set isCreatingConversation(value) {
    this.state.isCreatingConversation = value;
  }
  get isSwitchingConversation() {
    return this.state.isSwitchingConversation;
  }
  set isSwitchingConversation(value) {
    this.state.isSwitchingConversation = value;
  }
  // ============================================
  // Conversation
  // ============================================
  get currentConversationId() {
    return this.state.currentConversationId;
  }
  set currentConversationId(value) {
    var _a, _b;
    this.state.currentConversationId = value;
    (_b = (_a = this._callbacks).onConversationChanged) == null ? void 0 : _b.call(_a, value);
  }
  // ============================================
  // Queued Message
  // ============================================
  get queuedMessage() {
    return this.state.queuedMessage;
  }
  set queuedMessage(value) {
    this.state.queuedMessage = value;
  }
  // ============================================
  // Streaming DOM State
  // ============================================
  get currentContentEl() {
    return this.state.currentContentEl;
  }
  set currentContentEl(value) {
    this.state.currentContentEl = value;
  }
  get currentTextEl() {
    return this.state.currentTextEl;
  }
  set currentTextEl(value) {
    this.state.currentTextEl = value;
  }
  get currentTextContent() {
    return this.state.currentTextContent;
  }
  set currentTextContent(value) {
    this.state.currentTextContent = value;
  }
  get currentThinkingState() {
    return this.state.currentThinkingState;
  }
  set currentThinkingState(value) {
    this.state.currentThinkingState = value;
  }
  get thinkingEl() {
    return this.state.thinkingEl;
  }
  set thinkingEl(value) {
    this.state.thinkingEl = value;
  }
  get queueIndicatorEl() {
    return this.state.queueIndicatorEl;
  }
  set queueIndicatorEl(value) {
    this.state.queueIndicatorEl = value;
  }
  get thinkingIndicatorTimeout() {
    return this.state.thinkingIndicatorTimeout;
  }
  set thinkingIndicatorTimeout(value) {
    this.state.thinkingIndicatorTimeout = value;
  }
  // ============================================
  // Tool Tracking Maps (mutable references)
  // ============================================
  get toolCallElements() {
    return this.state.toolCallElements;
  }
  get writeEditStates() {
    return this.state.writeEditStates;
  }
  get pendingTools() {
    return this.state.pendingTools;
  }
  // ============================================
  // Usage State
  // ============================================
  get usage() {
    return this.state.usage;
  }
  set usage(value) {
    var _a, _b;
    this.state.usage = value;
    (_b = (_a = this._callbacks).onUsageChanged) == null ? void 0 : _b.call(_a, value);
  }
  get ignoreUsageUpdates() {
    return this.state.ignoreUsageUpdates;
  }
  set ignoreUsageUpdates(value) {
    this.state.ignoreUsageUpdates = value;
  }
  // ============================================
  // Current Todos (for persistent bottom panel)
  // ============================================
  get currentTodos() {
    return this.state.currentTodos ? [...this.state.currentTodos] : null;
  }
  set currentTodos(value) {
    var _a, _b;
    const normalizedValue = value && value.length > 0 ? value : null;
    this.state.currentTodos = normalizedValue;
    (_b = (_a = this._callbacks).onTodosChanged) == null ? void 0 : _b.call(_a, normalizedValue);
  }
  // ============================================
  // Attention State (approval pending, error, etc.)
  // ============================================
  get needsAttention() {
    return this.state.needsAttention;
  }
  set needsAttention(value) {
    var _a, _b;
    this.state.needsAttention = value;
    (_b = (_a = this._callbacks).onAttentionChanged) == null ? void 0 : _b.call(_a, value);
  }
  // ============================================
  // Auto-Scroll Control
  // ============================================
  get autoScrollEnabled() {
    return this.state.autoScrollEnabled;
  }
  set autoScrollEnabled(value) {
    var _a, _b;
    const changed = this.state.autoScrollEnabled !== value;
    this.state.autoScrollEnabled = value;
    if (changed) {
      (_b = (_a = this._callbacks).onAutoScrollChanged) == null ? void 0 : _b.call(_a, value);
    }
  }
  // ============================================
  // Response Timer State
  // ============================================
  get responseStartTime() {
    return this.state.responseStartTime;
  }
  set responseStartTime(value) {
    this.state.responseStartTime = value;
  }
  get flavorTimerInterval() {
    return this.state.flavorTimerInterval;
  }
  set flavorTimerInterval(value) {
    this.state.flavorTimerInterval = value;
  }
  // ============================================
  // Reset Methods
  // ============================================
  clearFlavorTimerInterval() {
    if (this.state.flavorTimerInterval) {
      clearInterval(this.state.flavorTimerInterval);
      this.state.flavorTimerInterval = null;
    }
  }
  resetStreamingState() {
    this.state.currentContentEl = null;
    this.state.currentTextEl = null;
    this.state.currentTextContent = "";
    this.state.currentThinkingState = null;
    this.state.isStreaming = false;
    this.state.cancelRequested = false;
    if (this.state.thinkingIndicatorTimeout) {
      clearTimeout(this.state.thinkingIndicatorTimeout);
      this.state.thinkingIndicatorTimeout = null;
    }
    this.clearFlavorTimerInterval();
    this.state.responseStartTime = null;
  }
  clearMaps() {
    this.state.toolCallElements.clear();
    this.state.writeEditStates.clear();
    this.state.pendingTools.clear();
  }
  resetForNewConversation() {
    this.clearMessages();
    this.resetStreamingState();
    this.clearMaps();
    this.state.queuedMessage = null;
    this.usage = null;
    this.currentTodos = null;
    this.autoScrollEnabled = true;
  }
  getPersistedMessages() {
    return this.state.messages;
  }
};

// src/features/chat/ui/FileContext.ts
var import_obsidian16 = require("obsidian");

// src/shared/mention/MentionDropdownController.ts
var import_obsidian14 = require("obsidian");

// src/utils/externalContext.ts
var fs5 = __toESM(require("fs"));
function normalizePathForComparison2(p2) {
  return normalizePathForComparison(p2);
}
function normalizePathForDisplay(p2) {
  if (!p2) return "";
  return p2.replace(/\\/g, "/").replace(/\/+$/, "");
}
function findConflictingPath(newPath, existingPaths) {
  const normalizedNew = normalizePathForComparison2(newPath);
  for (const existing of existingPaths) {
    const normalizedExisting = normalizePathForComparison2(existing);
    if (normalizedNew.startsWith(normalizedExisting + "/")) {
      return { path: existing, type: "parent" };
    }
    if (normalizedExisting.startsWith(normalizedNew + "/")) {
      return { path: existing, type: "child" };
    }
  }
  return null;
}
function getFolderName(p2) {
  const normalized = normalizePathForDisplay(p2);
  const segments = normalized.split("/");
  return segments[segments.length - 1] || normalized;
}
function validateDirectoryPath(p2) {
  try {
    const stats = fs5.statSync(p2);
    if (!stats.isDirectory()) {
      return { valid: false, error: "Path exists but is not a directory" };
    }
    return { valid: true };
  } catch (err) {
    const error = err;
    if (error.code === "ENOENT") {
      return { valid: false, error: "Path does not exist" };
    }
    if (error.code === "EACCES") {
      return { valid: false, error: "Permission denied" };
    }
    return { valid: false, error: `Cannot access path: ${error.message}` };
  }
}
function isValidDirectoryPath(p2) {
  return validateDirectoryPath(p2).valid;
}
function filterValidPaths(paths) {
  return paths.filter(isValidDirectoryPath);
}
function isDuplicatePath(newPath, existingPaths) {
  const normalizedNew = normalizePathForComparison2(newPath);
  return existingPaths.some((existing) => normalizePathForComparison2(existing) === normalizedNew);
}

// src/utils/externalContextScanner.ts
var fs6 = __toESM(require("fs"));
var path6 = __toESM(require("path"));
var CACHE_TTL_MS = 3e4;
var MAX_FILES_PER_PATH = 1e3;
var MAX_DEPTH = 10;
var SKIP_DIRECTORIES = /* @__PURE__ */ new Set([
  "node_modules",
  "__pycache__",
  "venv",
  ".venv",
  ".git",
  ".svn",
  ".hg",
  "dist",
  "build",
  "out",
  ".next",
  ".nuxt",
  "target",
  "vendor",
  "Pods"
]);
var ExternalContextScanner = class {
  constructor() {
    this.cache = /* @__PURE__ */ new Map();
  }
  scanPaths(externalContextPaths) {
    const allFiles = [];
    const now = Date.now();
    for (const contextPath of externalContextPaths) {
      const expandedPath = normalizePathForFilesystem(contextPath);
      const cached = this.cache.get(expandedPath);
      if (cached && now - cached.timestamp < CACHE_TTL_MS) {
        allFiles.push(...cached.files);
        continue;
      }
      const files = this.scanDirectory(expandedPath, expandedPath, 0);
      this.cache.set(expandedPath, { files, timestamp: now });
      allFiles.push(...files);
    }
    return allFiles;
  }
  scanDirectory(dir, contextRoot, depth) {
    if (depth > MAX_DEPTH) return [];
    const files = [];
    try {
      if (!fs6.existsSync(dir)) return [];
      const stat = fs6.statSync(dir);
      if (!stat.isDirectory()) return [];
      const entries = fs6.readdirSync(dir, { withFileTypes: true });
      for (const entry of entries) {
        if (entry.name.startsWith(".")) continue;
        if (SKIP_DIRECTORIES.has(entry.name)) continue;
        if (entry.isSymbolicLink()) continue;
        const fullPath = path6.join(dir, entry.name);
        if (entry.isDirectory()) {
          const subFiles = this.scanDirectory(fullPath, contextRoot, depth + 1);
          files.push(...subFiles);
        } else if (entry.isFile()) {
          try {
            const fileStat = fs6.statSync(fullPath);
            files.push({
              path: fullPath,
              name: entry.name,
              relativePath: path6.relative(contextRoot, fullPath),
              contextRoot,
              mtime: fileStat.mtimeMs
            });
          } catch (e2) {
          }
        }
        if (files.length >= MAX_FILES_PER_PATH) break;
      }
    } catch (e2) {
    }
    return files;
  }
  invalidateCache() {
    this.cache.clear();
  }
  invalidatePath(contextPath) {
    const expandedPath = normalizePathForFilesystem(contextPath);
    this.cache.delete(expandedPath);
  }
};
var externalContextScanner = new ExternalContextScanner();

// src/shared/components/SelectableDropdown.ts
var SelectableDropdown = class {
  constructor(containerEl, options) {
    this.dropdownEl = null;
    this.items = [];
    this.itemEls = [];
    this.selectedIndex = 0;
    this.containerEl = containerEl;
    this.options = options;
  }
  isVisible() {
    var _a, _b;
    return (_b = (_a = this.dropdownEl) == null ? void 0 : _a.hasClass("visible")) != null ? _b : false;
  }
  getElement() {
    return this.dropdownEl;
  }
  getSelectedIndex() {
    return this.selectedIndex;
  }
  getSelectedItem() {
    var _a;
    return (_a = this.items[this.selectedIndex]) != null ? _a : null;
  }
  getItems() {
    return this.items;
  }
  hide() {
    if (this.dropdownEl) {
      this.dropdownEl.removeClass("visible");
    }
  }
  destroy() {
    if (this.dropdownEl) {
      this.dropdownEl.remove();
      this.dropdownEl = null;
    }
  }
  render(options) {
    var _a;
    this.items = options.items;
    this.selectedIndex = options.selectedIndex;
    if (!this.dropdownEl) {
      this.dropdownEl = this.createDropdownElement();
    }
    this.dropdownEl.empty();
    this.itemEls = [];
    if (options.items.length === 0) {
      const emptyEl = this.dropdownEl.createDiv({ cls: this.options.emptyClassName });
      emptyEl.setText(options.emptyText);
    } else {
      for (let i2 = 0; i2 < options.items.length; i2++) {
        const item = options.items[i2];
        const itemEl = this.dropdownEl.createDiv({ cls: this.options.itemClassName });
        const extraClass = (_a = options.getItemClass) == null ? void 0 : _a.call(options, item);
        if (Array.isArray(extraClass)) {
          extraClass.forEach((cls) => itemEl.addClass(cls));
        } else if (extraClass) {
          itemEl.addClass(extraClass);
        }
        if (i2 === this.selectedIndex) {
          itemEl.addClass("selected");
        }
        options.renderItem(item, itemEl);
        itemEl.addEventListener("click", (e2) => {
          var _a2;
          this.selectedIndex = i2;
          this.updateSelection();
          (_a2 = options.onItemClick) == null ? void 0 : _a2.call(options, item, i2, e2);
        });
        itemEl.addEventListener("mouseenter", () => {
          var _a2;
          this.selectedIndex = i2;
          this.updateSelection();
          (_a2 = options.onItemHover) == null ? void 0 : _a2.call(options, item, i2);
        });
        this.itemEls.push(itemEl);
      }
    }
    this.dropdownEl.addClass("visible");
  }
  updateSelection() {
    this.itemEls.forEach((itemEl, index) => {
      if (index === this.selectedIndex) {
        itemEl.addClass("selected");
        itemEl.scrollIntoView({ block: "nearest" });
      } else {
        itemEl.removeClass("selected");
      }
    });
  }
  moveSelection(delta) {
    const maxIndex = this.items.length - 1;
    this.selectedIndex = Math.max(0, Math.min(maxIndex, this.selectedIndex + delta));
    this.updateSelection();
  }
  createDropdownElement() {
    const className = this.options.fixed && this.options.fixedClassName ? `${this.options.listClassName} ${this.options.fixedClassName}` : this.options.listClassName;
    return this.containerEl.createDiv({ cls: className });
  }
};

// src/shared/mention/types.ts
function createExternalContextEntry(contextRoot, folderName, displayName) {
  return {
    contextRoot,
    folderName,
    displayName,
    displayNameLower: displayName.toLowerCase()
  };
}

// src/shared/mention/MentionDropdownController.ts
var MentionDropdownController = class {
  constructor(containerEl, inputEl, callbacks, options = {}) {
    this.mentionStartIndex = -1;
    this.selectedMentionIndex = 0;
    this.filteredMentionItems = [];
    this.filteredContextFiles = [];
    this.activeContextFilter = null;
    this.activeAgentFilter = false;
    this.mcpService = null;
    this.agentService = null;
    var _a;
    this.containerEl = containerEl;
    this.inputEl = inputEl;
    this.callbacks = callbacks;
    this.fixed = (_a = options.fixed) != null ? _a : false;
    this.dropdown = new SelectableDropdown(this.containerEl, {
      listClassName: "claudian-mention-dropdown",
      itemClassName: "claudian-mention-item",
      emptyClassName: "claudian-mention-empty",
      fixed: this.fixed,
      fixedClassName: "claudian-mention-dropdown-fixed"
    });
  }
  setMcpService(service) {
    this.mcpService = service;
  }
  setAgentService(service) {
    this.agentService = service;
  }
  preScanExternalContexts() {
    const externalContexts = this.callbacks.getExternalContexts() || [];
    if (externalContexts.length === 0) return;
    setTimeout(() => {
      try {
        externalContextScanner.scanPaths(externalContexts);
      } catch (e2) {
      }
    }, 0);
  }
  isVisible() {
    return this.dropdown.isVisible();
  }
  hide() {
    this.dropdown.hide();
    this.mentionStartIndex = -1;
  }
  containsElement(el) {
    var _a, _b;
    return (_b = (_a = this.dropdown.getElement()) == null ? void 0 : _a.contains(el)) != null ? _b : false;
  }
  destroy() {
    this.dropdown.destroy();
  }
  updateMcpMentionsFromText(text) {
    var _a, _b;
    if (!this.mcpService) return;
    const validNames = new Set(
      this.mcpService.getContextSavingServers().map((s) => s.name)
    );
    const newMentions = extractMcpMentions(text, validNames);
    const changed = this.callbacks.setMentionedMcpServers(newMentions);
    if (changed) {
      (_b = (_a = this.callbacks).onMcpMentionChange) == null ? void 0 : _b.call(_a, newMentions);
    }
  }
  handleInputChange() {
    const text = this.inputEl.value;
    this.updateMcpMentionsFromText(text);
    const cursorPos = this.inputEl.selectionStart || 0;
    const textBeforeCursor = text.substring(0, cursorPos);
    const lastAtIndex = textBeforeCursor.lastIndexOf("@");
    if (lastAtIndex === -1) {
      this.hide();
      return;
    }
    const charBeforeAt = lastAtIndex > 0 ? textBeforeCursor[lastAtIndex - 1] : " ";
    if (!/\s/.test(charBeforeAt) && lastAtIndex !== 0) {
      this.hide();
      return;
    }
    const searchText = textBeforeCursor.substring(lastAtIndex + 1);
    if (/\s/.test(searchText)) {
      this.hide();
      return;
    }
    this.mentionStartIndex = lastAtIndex;
    this.showMentionDropdown(searchText);
  }
  handleKeydown(e2) {
    if (!this.dropdown.isVisible()) return false;
    if (e2.key === "ArrowDown") {
      e2.preventDefault();
      this.dropdown.moveSelection(1);
      this.selectedMentionIndex = this.dropdown.getSelectedIndex();
      return true;
    }
    if (e2.key === "ArrowUp") {
      e2.preventDefault();
      this.dropdown.moveSelection(-1);
      this.selectedMentionIndex = this.dropdown.getSelectedIndex();
      return true;
    }
    if ((e2.key === "Enter" || e2.key === "Tab") && !e2.isComposing) {
      e2.preventDefault();
      this.selectMentionItem();
      return true;
    }
    if (e2.key === "Escape" && !e2.isComposing) {
      e2.preventDefault();
      if (this.activeContextFilter || this.activeAgentFilter) {
        this.returnToFirstLevel();
        return true;
      }
      this.hide();
      return true;
    }
    return false;
  }
  buildExternalContextEntries(externalContexts) {
    var _a;
    const counts = /* @__PURE__ */ new Map();
    const normalizedPaths = /* @__PURE__ */ new Map();
    for (const contextPath of externalContexts) {
      const normalized = normalizePathForComparison2(contextPath);
      normalizedPaths.set(contextPath, normalized);
      const folderName = getFolderName(normalized);
      counts.set(folderName, ((_a = counts.get(folderName)) != null ? _a : 0) + 1);
    }
    return externalContexts.map((contextRoot) => {
      var _a2, _b;
      const normalized = (_a2 = normalizedPaths.get(contextRoot)) != null ? _a2 : normalizePathForComparison2(contextRoot);
      const folderName = getFolderName(contextRoot);
      const needsDisambiguation = ((_b = counts.get(folderName)) != null ? _b : 0) > 1;
      const displayName = this.getContextDisplayName(normalized, folderName, needsDisambiguation);
      return createExternalContextEntry(contextRoot, folderName, displayName);
    });
  }
  getContextDisplayName(normalizedPath, folderName, needsDisambiguation) {
    if (!needsDisambiguation) return folderName;
    const segments = normalizedPath.split("/").filter(Boolean);
    if (segments.length < 2) return folderName;
    const parent = segments[segments.length - 2];
    if (!parent) return folderName;
    return `${parent}/${folderName}`;
  }
  showMentionDropdown(searchText) {
    const searchLower = searchText.toLowerCase();
    this.filteredMentionItems = [];
    this.filteredContextFiles = [];
    const externalContexts = this.callbacks.getExternalContexts() || [];
    const contextEntries = this.buildExternalContextEntries(externalContexts);
    const isFilterSearch = searchText.includes("/");
    let fileSearchText = searchLower;
    if (isFilterSearch && searchLower.startsWith("agents/")) {
      this.activeAgentFilter = true;
      this.activeContextFilter = null;
      const agentSearchText = searchText.substring("agents/".length).toLowerCase();
      if (this.agentService) {
        const matchingAgents = this.agentService.searchAgents(agentSearchText);
        for (const agent of matchingAgents) {
          this.filteredMentionItems.push({
            type: "agent",
            id: agent.id,
            name: agent.name,
            description: agent.description,
            source: agent.source
          });
        }
      }
      this.selectedMentionIndex = 0;
      this.renderMentionDropdown();
      return;
    }
    if (isFilterSearch) {
      const matchingContext = contextEntries.filter((entry) => searchLower.startsWith(`${entry.displayNameLower}/`)).sort((a, b3) => b3.displayNameLower.length - a.displayNameLower.length)[0];
      if (matchingContext) {
        const prefixLength = matchingContext.displayName.length + 1;
        fileSearchText = searchText.substring(prefixLength).toLowerCase();
        this.activeContextFilter = {
          folderName: matchingContext.displayName,
          contextRoot: matchingContext.contextRoot
        };
      } else {
        this.activeContextFilter = null;
      }
    }
    if (this.activeContextFilter && isFilterSearch) {
      const contextFiles = externalContextScanner.scanPaths([this.activeContextFilter.contextRoot]);
      this.filteredContextFiles = contextFiles.filter((file) => {
        const relativePath = file.relativePath.replace(/\\/g, "/");
        const pathLower = relativePath.toLowerCase();
        const nameLower = file.name.toLowerCase();
        return pathLower.includes(fileSearchText) || nameLower.includes(fileSearchText);
      }).sort((a, b3) => {
        const aNameMatch = a.name.toLowerCase().startsWith(fileSearchText);
        const bNameMatch = b3.name.toLowerCase().startsWith(fileSearchText);
        if (aNameMatch && !bNameMatch) return -1;
        if (!aNameMatch && bNameMatch) return 1;
        return b3.mtime - a.mtime;
      });
      for (const file of this.filteredContextFiles) {
        const relativePath = file.relativePath.replace(/\\/g, "/");
        this.filteredMentionItems.push({
          type: "context-file",
          name: relativePath,
          absolutePath: file.path,
          contextRoot: file.contextRoot,
          folderName: this.activeContextFilter.folderName
        });
      }
      this.selectedMentionIndex = 0;
      this.renderMentionDropdown();
      return;
    }
    this.activeContextFilter = null;
    this.activeAgentFilter = false;
    if (this.mcpService) {
      const mcpServers = this.mcpService.getContextSavingServers();
      for (const server of mcpServers) {
        if (server.name.toLowerCase().includes(searchLower)) {
          this.filteredMentionItems.push({
            type: "mcp-server",
            name: server.name
          });
        }
      }
    }
    if (this.agentService) {
      const hasAgents = this.agentService.searchAgents("").length > 0;
      if (hasAgents && "agents".includes(searchLower)) {
        this.filteredMentionItems.push({
          type: "agent-folder",
          name: "Agents"
        });
      }
    }
    if (contextEntries.length > 0) {
      const matchingFolders = /* @__PURE__ */ new Set();
      for (const entry of contextEntries) {
        if (entry.displayNameLower.includes(searchLower) && !matchingFolders.has(entry.displayName)) {
          matchingFolders.add(entry.displayName);
          this.filteredMentionItems.push({
            type: "context-folder",
            name: entry.displayName,
            contextRoot: entry.contextRoot,
            folderName: entry.displayName
          });
        }
      }
    }
    const firstVaultFileIndex = this.filteredMentionItems.length;
    const allFiles = this.callbacks.getCachedMarkdownFiles();
    const vaultFiles = allFiles.filter((file) => {
      const pathLower = file.path.toLowerCase();
      const nameLower = file.name.toLowerCase();
      return pathLower.includes(searchLower) || nameLower.includes(searchLower);
    }).sort((a, b3) => {
      const aNameMatch = a.name.toLowerCase().startsWith(searchLower);
      const bNameMatch = b3.name.toLowerCase().startsWith(searchLower);
      if (aNameMatch && !bNameMatch) return -1;
      if (!aNameMatch && bNameMatch) return 1;
      return b3.stat.mtime - a.stat.mtime;
    });
    for (const file of vaultFiles) {
      this.filteredMentionItems.push({
        type: "file",
        name: file.name,
        path: file.path,
        file
      });
    }
    if (vaultFiles.length > 0) {
      this.selectedMentionIndex = firstVaultFileIndex;
    } else {
      this.selectedMentionIndex = 0;
    }
    this.renderMentionDropdown();
  }
  renderMentionDropdown() {
    this.dropdown.render({
      items: this.filteredMentionItems,
      selectedIndex: this.selectedMentionIndex,
      emptyText: "No matches",
      getItemClass: (item) => {
        if (item.type === "mcp-server") return "mcp-server";
        if (item.type === "agent") return "agent";
        if (item.type === "agent-folder") return "agent-folder";
        if (item.type === "context-file") return "context-file";
        if (item.type === "context-folder") return "context-folder";
        return void 0;
      },
      renderItem: (item, itemEl) => {
        const iconEl = itemEl.createSpan({ cls: "claudian-mention-icon" });
        if (item.type === "mcp-server") {
          iconEl.innerHTML = MCP_ICON_SVG;
        } else if (item.type === "agent" || item.type === "agent-folder") {
          (0, import_obsidian14.setIcon)(iconEl, "bot");
        } else if (item.type === "context-file") {
          (0, import_obsidian14.setIcon)(iconEl, "folder-open");
        } else if (item.type === "context-folder") {
          (0, import_obsidian14.setIcon)(iconEl, "folder");
        } else {
          (0, import_obsidian14.setIcon)(iconEl, "file-text");
        }
        const textEl = itemEl.createSpan({ cls: "claudian-mention-text" });
        if (item.type === "mcp-server") {
          const nameEl = textEl.createSpan({ cls: "claudian-mention-name" });
          nameEl.setText(`@${item.name}`);
        } else if (item.type === "agent-folder") {
          const nameEl = textEl.createSpan({
            cls: "claudian-mention-name claudian-mention-name-agent-folder"
          });
          nameEl.setText(`@${item.name}/`);
        } else if (item.type === "agent") {
          const nameEl = textEl.createSpan({ cls: "claudian-mention-name claudian-mention-name-agent" });
          nameEl.setText(`@${item.id}`);
          if (item.description) {
            const descEl = textEl.createSpan({ cls: "claudian-mention-agent-desc" });
            descEl.setText(item.description);
          }
        } else if (item.type === "context-folder") {
          const nameEl = textEl.createSpan({
            cls: "claudian-mention-name claudian-mention-name-folder"
          });
          nameEl.setText(`@${item.name}/`);
        } else if (item.type === "context-file") {
          const nameEl = textEl.createSpan({
            cls: "claudian-mention-name claudian-mention-name-context"
          });
          nameEl.setText(item.name);
        } else {
          const pathEl = textEl.createSpan({ cls: "claudian-mention-path" });
          pathEl.setText(item.path || item.name);
        }
      },
      onItemClick: (item, index, e2) => {
        if (item.type === "context-folder" || item.type === "agent-folder") {
          e2.stopPropagation();
        }
        this.selectedMentionIndex = index;
        this.selectMentionItem();
      },
      onItemHover: (_item, index) => {
        this.selectedMentionIndex = index;
      }
    });
    if (this.fixed) {
      this.positionFixed();
    }
  }
  positionFixed() {
    const dropdownEl = this.dropdown.getElement();
    if (!dropdownEl) return;
    const inputRect = this.inputEl.getBoundingClientRect();
    dropdownEl.style.position = "fixed";
    dropdownEl.style.bottom = `${window.innerHeight - inputRect.top + 4}px`;
    dropdownEl.style.left = `${inputRect.left}px`;
    dropdownEl.style.right = "auto";
    dropdownEl.style.width = `${Math.max(inputRect.width, 280)}px`;
    dropdownEl.style.zIndex = "10001";
  }
  returnToFirstLevel() {
    const text = this.inputEl.value;
    const beforeAt = text.substring(0, this.mentionStartIndex);
    const cursorPos = this.inputEl.selectionStart || 0;
    const afterCursor = text.substring(cursorPos);
    this.inputEl.value = beforeAt + "@" + afterCursor;
    this.inputEl.selectionStart = this.inputEl.selectionEnd = beforeAt.length + 1;
    this.activeContextFilter = null;
    this.activeAgentFilter = false;
    this.showMentionDropdown("");
  }
  selectMentionItem() {
    var _a, _b, _c, _d, _e;
    if (this.filteredMentionItems.length === 0) return;
    const selectedIndex = this.dropdown.getSelectedIndex();
    this.selectedMentionIndex = selectedIndex;
    const selectedItem = this.filteredMentionItems[selectedIndex];
    if (!selectedItem) return;
    const text = this.inputEl.value;
    const beforeAt = text.substring(0, this.mentionStartIndex);
    const cursorPos = this.inputEl.selectionStart || 0;
    const afterCursor = text.substring(cursorPos);
    if (selectedItem.type === "mcp-server") {
      const replacement = `@${selectedItem.name} `;
      this.inputEl.value = beforeAt + replacement + afterCursor;
      this.inputEl.selectionStart = this.inputEl.selectionEnd = beforeAt.length + replacement.length;
      this.callbacks.addMentionedMcpServer(selectedItem.name);
      (_b = (_a = this.callbacks).onMcpMentionChange) == null ? void 0 : _b.call(_a, this.callbacks.getMentionedMcpServers());
    } else if (selectedItem.type === "agent-folder") {
      this.activeAgentFilter = true;
      this.inputEl.focus();
      this.showMentionDropdown("Agents/");
      return;
    } else if (selectedItem.type === "agent") {
      const replacement = `@${selectedItem.id} (agent) `;
      this.inputEl.value = beforeAt + replacement + afterCursor;
      this.inputEl.selectionStart = this.inputEl.selectionEnd = beforeAt.length + replacement.length;
      (_d = (_c = this.callbacks).onAgentMentionSelect) == null ? void 0 : _d.call(_c, selectedItem.id);
    } else if (selectedItem.type === "context-folder") {
      const replacement = `@${selectedItem.name}/`;
      this.inputEl.value = beforeAt + replacement + afterCursor;
      this.inputEl.selectionStart = this.inputEl.selectionEnd = beforeAt.length + replacement.length;
      this.inputEl.focus();
      this.handleInputChange();
      return;
    } else if (selectedItem.type === "context-file") {
      const displayName = selectedItem.folderName ? `@${selectedItem.folderName}/${selectedItem.name}` : `@${selectedItem.name}`;
      if (selectedItem.absolutePath) {
        if (this.callbacks.onAttachContextFile) {
          this.callbacks.onAttachContextFile(displayName, selectedItem.absolutePath);
        } else {
          this.callbacks.onAttachFile(selectedItem.absolutePath);
        }
      }
      const replacement = `${displayName} `;
      this.inputEl.value = beforeAt + replacement + afterCursor;
      this.inputEl.selectionStart = this.inputEl.selectionEnd = beforeAt.length + replacement.length;
    } else {
      const file = selectedItem.file;
      const rawPath = (_e = file == null ? void 0 : file.path) != null ? _e : selectedItem.path;
      const normalizedPath = this.callbacks.normalizePathForVault(rawPath);
      if (normalizedPath) {
        this.callbacks.onAttachFile(normalizedPath);
      }
      const replacement = `@${normalizedPath != null ? normalizedPath : selectedItem.name} `;
      this.inputEl.value = beforeAt + replacement + afterCursor;
      this.inputEl.selectionStart = this.inputEl.selectionEnd = beforeAt.length + replacement.length;
    }
    this.hide();
    this.inputEl.focus();
  }
};

// src/features/chat/ui/file-context/state/FileContextState.ts
function escapeRegExp2(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
var FileContextState = class {
  constructor() {
    this.attachedFiles = /* @__PURE__ */ new Set();
    this.sessionStarted = false;
    this.mentionedMcpServers = /* @__PURE__ */ new Set();
    this.currentNoteSent = false;
    /** Maps display name to absolute path for external context files only. */
    this.contextFileMap = /* @__PURE__ */ new Map();
  }
  getAttachedFiles() {
    return new Set(this.attachedFiles);
  }
  hasSentCurrentNote() {
    return this.currentNoteSent;
  }
  markCurrentNoteSent() {
    this.currentNoteSent = true;
  }
  isSessionStarted() {
    return this.sessionStarted;
  }
  startSession() {
    this.sessionStarted = true;
  }
  resetForNewConversation() {
    this.sessionStarted = false;
    this.currentNoteSent = false;
    this.attachedFiles.clear();
    this.contextFileMap.clear();
    this.clearMcpMentions();
  }
  resetForLoadedConversation(hasMessages) {
    this.currentNoteSent = hasMessages;
    this.attachedFiles.clear();
    this.contextFileMap.clear();
    this.sessionStarted = hasMessages;
    this.clearMcpMentions();
  }
  setAttachedFiles(files) {
    this.attachedFiles.clear();
    for (const file of files) {
      this.attachedFiles.add(file);
    }
  }
  attachFile(path10) {
    this.attachedFiles.add(path10);
  }
  /** Attach an external context file with display name to absolute path mapping. */
  attachContextFile(displayName, absolutePath) {
    this.attachedFiles.add(absolutePath);
    this.contextFileMap.set(displayName, absolutePath);
  }
  detachFile(path10) {
    this.attachedFiles.delete(path10);
  }
  clearAttachments() {
    this.attachedFiles.clear();
    this.contextFileMap.clear();
  }
  /** Transform text by replacing external context file display names with absolute paths. */
  transformContextMentions(text) {
    let result = text;
    for (const [displayName, absolutePath] of this.contextFileMap) {
      result = result.replace(new RegExp(escapeRegExp2(displayName), "g"), absolutePath);
    }
    return result;
  }
  getMentionedMcpServers() {
    return new Set(this.mentionedMcpServers);
  }
  clearMcpMentions() {
    this.mentionedMcpServers.clear();
  }
  setMentionedMcpServers(mentions) {
    const changed = mentions.size !== this.mentionedMcpServers.size || [...mentions].some((name) => !this.mentionedMcpServers.has(name));
    if (changed) {
      this.mentionedMcpServers = new Set(mentions);
    }
    return changed;
  }
  addMentionedMcpServer(name) {
    this.mentionedMcpServers.add(name);
  }
};

// src/features/chat/ui/file-context/state/MarkdownFileCache.ts
var MarkdownFileCache = class {
  constructor(app) {
    this.cachedFiles = [];
    this.dirty = true;
    this.app = app;
  }
  markDirty() {
    this.dirty = true;
  }
  getFiles() {
    if (this.dirty || this.cachedFiles.length === 0) {
      this.cachedFiles = this.app.vault.getMarkdownFiles();
      this.dirty = false;
    }
    return [...this.cachedFiles];
  }
};

// src/features/chat/ui/file-context/view/FileChipsView.ts
var import_obsidian15 = require("obsidian");
var FileChipsView = class {
  constructor(containerEl, callbacks) {
    this.containerEl = containerEl;
    this.callbacks = callbacks;
    const firstChild = this.containerEl.firstChild;
    this.fileIndicatorEl = this.containerEl.createDiv({ cls: "claudian-file-indicator" });
    if (firstChild) {
      this.containerEl.insertBefore(this.fileIndicatorEl, firstChild);
    }
  }
  destroy() {
    this.fileIndicatorEl.remove();
  }
  renderCurrentNote(filePath) {
    this.fileIndicatorEl.empty();
    if (!filePath) {
      this.fileIndicatorEl.style.display = "none";
      return;
    }
    this.fileIndicatorEl.style.display = "flex";
    this.renderFileChip(filePath, () => {
      this.callbacks.onRemoveAttachment(filePath);
    });
  }
  renderFileChip(filePath, onRemove) {
    const chipEl = this.fileIndicatorEl.createDiv({ cls: "claudian-file-chip" });
    const iconEl = chipEl.createSpan({ cls: "claudian-file-chip-icon" });
    (0, import_obsidian15.setIcon)(iconEl, "file-text");
    const normalizedPath = filePath.replace(/\\/g, "/");
    const filename = normalizedPath.split("/").pop() || filePath;
    const nameEl = chipEl.createSpan({ cls: "claudian-file-chip-name" });
    nameEl.setText(filename);
    nameEl.setAttribute("title", filePath);
    const removeEl = chipEl.createSpan({ cls: "claudian-file-chip-remove" });
    removeEl.setText("\xD7");
    removeEl.setAttribute("aria-label", "Remove");
    chipEl.addEventListener("click", (e2) => {
      if (!e2.target.closest(".claudian-file-chip-remove")) {
        this.callbacks.onOpenFile(filePath);
      }
    });
    removeEl.addEventListener("click", () => {
      onRemove();
    });
  }
};

// src/features/chat/ui/FileContext.ts
var FileContextManager = class {
  constructor(app, chipsContainerEl, inputEl, callbacks, dropdownContainerEl) {
    this.deleteEventRef = null;
    this.renameEventRef = null;
    // Current note (shown as chip)
    this.currentNotePath = null;
    // MCP server support
    this.mcpService = null;
    this.onMcpMentionChange = null;
    this.app = app;
    this.chipsContainerEl = chipsContainerEl;
    this.dropdownContainerEl = dropdownContainerEl != null ? dropdownContainerEl : chipsContainerEl;
    this.inputEl = inputEl;
    this.callbacks = callbacks;
    this.state = new FileContextState();
    this.fileCache = new MarkdownFileCache(this.app);
    this.chipsView = new FileChipsView(this.chipsContainerEl, {
      onRemoveAttachment: (filePath) => {
        if (filePath === this.currentNotePath) {
          this.currentNotePath = null;
          this.state.detachFile(filePath);
          this.refreshCurrentNoteChip();
        }
      },
      onOpenFile: async (filePath) => {
        const file = this.app.vault.getAbstractFileByPath(filePath);
        if (!(file instanceof import_obsidian16.TFile)) {
          new import_obsidian16.Notice(`Could not open file: ${filePath}`);
          return;
        }
        try {
          await this.app.workspace.getLeaf().openFile(file);
        } catch (error) {
          new import_obsidian16.Notice(`Failed to open file: ${error instanceof Error ? error.message : String(error)}`);
        }
      }
    });
    this.mentionDropdown = new MentionDropdownController(
      this.dropdownContainerEl,
      this.inputEl,
      {
        onAttachFile: (filePath) => this.state.attachFile(filePath),
        onAttachContextFile: (displayName, absolutePath) => this.state.attachContextFile(displayName, absolutePath),
        onMcpMentionChange: (servers) => {
          var _a;
          return (_a = this.onMcpMentionChange) == null ? void 0 : _a.call(this, servers);
        },
        onAgentMentionSelect: (agentId) => {
          var _a, _b;
          return (_b = (_a = this.callbacks).onAgentMentionSelect) == null ? void 0 : _b.call(_a, agentId);
        },
        getMentionedMcpServers: () => this.state.getMentionedMcpServers(),
        setMentionedMcpServers: (mentions) => this.state.setMentionedMcpServers(mentions),
        addMentionedMcpServer: (name) => this.state.addMentionedMcpServer(name),
        getExternalContexts: () => {
          var _a, _b;
          return ((_b = (_a = this.callbacks).getExternalContexts) == null ? void 0 : _b.call(_a)) || [];
        },
        getCachedMarkdownFiles: () => this.fileCache.getFiles(),
        normalizePathForVault: (rawPath) => this.normalizePathForVault(rawPath)
      }
    );
    this.deleteEventRef = this.app.vault.on("delete", (file) => {
      if (file instanceof import_obsidian16.TFile) this.handleFileDeleted(file.path);
    });
    this.renameEventRef = this.app.vault.on("rename", (file, oldPath) => {
      if (file instanceof import_obsidian16.TFile) this.handleFileRenamed(oldPath, file.path);
    });
  }
  /** Returns the current note path (shown as chip). */
  getCurrentNotePath() {
    return this.currentNotePath;
  }
  /** Checks whether current note should be sent for this session. */
  shouldSendCurrentNote(notePath) {
    const resolvedPath = notePath != null ? notePath : this.currentNotePath;
    return !!resolvedPath && !this.state.hasSentCurrentNote();
  }
  /** Marks current note as sent (call after sending a message). */
  markCurrentNoteSent() {
    this.state.markCurrentNoteSent();
  }
  isSessionStarted() {
    return this.state.isSessionStarted();
  }
  startSession() {
    this.state.startSession();
  }
  /** Resets state for a new conversation. */
  resetForNewConversation() {
    this.currentNotePath = null;
    this.state.resetForNewConversation();
    this.refreshCurrentNoteChip();
  }
  /** Resets state for loading an existing conversation. */
  resetForLoadedConversation(hasMessages) {
    this.currentNotePath = null;
    this.state.resetForLoadedConversation(hasMessages);
    this.refreshCurrentNoteChip();
  }
  /** Sets current note (for restoring persisted state). */
  setCurrentNote(notePath) {
    this.currentNotePath = notePath;
    if (notePath) {
      this.state.attachFile(notePath);
    }
    this.refreshCurrentNoteChip();
  }
  /** Auto-attaches the currently focused file (for new sessions). */
  autoAttachActiveFile() {
    const activeFile = this.app.workspace.getActiveFile();
    if (activeFile && !this.hasExcludedTag(activeFile)) {
      const normalizedPath = this.normalizePathForVault(activeFile.path);
      if (normalizedPath) {
        this.currentNotePath = normalizedPath;
        this.state.attachFile(normalizedPath);
        this.refreshCurrentNoteChip();
      }
    }
  }
  /** Handles file open event. */
  handleFileOpen(file) {
    const normalizedPath = this.normalizePathForVault(file.path);
    if (!normalizedPath) return;
    if (!this.state.isSessionStarted()) {
      this.state.clearAttachments();
      if (!this.hasExcludedTag(file)) {
        this.currentNotePath = normalizedPath;
        this.state.attachFile(normalizedPath);
      } else {
        this.currentNotePath = null;
      }
      this.refreshCurrentNoteChip();
    }
  }
  markFilesCacheDirty() {
    this.fileCache.markDirty();
  }
  /** Handles input changes to detect @ mentions. */
  handleInputChange() {
    this.mentionDropdown.handleInputChange();
  }
  /** Handles keyboard navigation in mention dropdown. Returns true if handled. */
  handleMentionKeydown(e2) {
    return this.mentionDropdown.handleKeydown(e2);
  }
  isMentionDropdownVisible() {
    return this.mentionDropdown.isVisible();
  }
  hideMentionDropdown() {
    this.mentionDropdown.hide();
  }
  containsElement(el) {
    return this.mentionDropdown.containsElement(el);
  }
  transformContextMentions(text) {
    return this.state.transformContextMentions(text);
  }
  /** Cleans up event listeners (call on view close). */
  destroy() {
    if (this.deleteEventRef) this.app.vault.offref(this.deleteEventRef);
    if (this.renameEventRef) this.app.vault.offref(this.renameEventRef);
    this.mentionDropdown.destroy();
    this.chipsView.destroy();
  }
  /** Normalizes a file path to be vault-relative with forward slashes. */
  normalizePathForVault(rawPath) {
    const vaultPath = getVaultPath(this.app);
    return normalizePathForVault(rawPath, vaultPath);
  }
  refreshCurrentNoteChip() {
    var _a, _b;
    this.chipsView.renderCurrentNote(this.currentNotePath);
    (_b = (_a = this.callbacks).onChipsChanged) == null ? void 0 : _b.call(_a);
  }
  handleFileRenamed(oldPath, newPath) {
    const normalizedOld = this.normalizePathForVault(oldPath);
    const normalizedNew = this.normalizePathForVault(newPath);
    if (!normalizedOld) return;
    let needsUpdate = false;
    if (this.currentNotePath === normalizedOld) {
      this.currentNotePath = normalizedNew;
      needsUpdate = true;
    }
    if (this.state.getAttachedFiles().has(normalizedOld)) {
      this.state.detachFile(normalizedOld);
      if (normalizedNew) {
        this.state.attachFile(normalizedNew);
      }
      needsUpdate = true;
    }
    if (needsUpdate) {
      this.refreshCurrentNoteChip();
    }
  }
  handleFileDeleted(deletedPath) {
    const normalized = this.normalizePathForVault(deletedPath);
    if (!normalized) return;
    let needsUpdate = false;
    if (this.currentNotePath === normalized) {
      this.currentNotePath = null;
      needsUpdate = true;
    }
    if (this.state.getAttachedFiles().has(normalized)) {
      this.state.detachFile(normalized);
      needsUpdate = true;
    }
    if (needsUpdate) {
      this.refreshCurrentNoteChip();
    }
  }
  // ========================================
  // MCP Server Support
  // ========================================
  setMcpService(service) {
    this.mcpService = service;
    this.mentionDropdown.setMcpService(service);
  }
  setAgentService(agentManager) {
    this.mentionDropdown.setAgentService(agentManager);
  }
  setOnMcpMentionChange(callback) {
    this.onMcpMentionChange = callback;
  }
  /**
   * Pre-scans external context paths in the background to warm the cache.
   * Should be called when external context paths are added/changed.
   */
  preScanExternalContexts() {
    this.mentionDropdown.preScanExternalContexts();
  }
  getMentionedMcpServers() {
    return this.state.getMentionedMcpServers();
  }
  clearMcpMentions() {
    this.state.clearMcpMentions();
  }
  updateMcpMentionsFromText(text) {
    this.mentionDropdown.updateMcpMentionsFromText(text);
  }
  hasExcludedTag(file) {
    var _a;
    const excludedTags = this.callbacks.getExcludedTags();
    if (excludedTags.length === 0) return false;
    const cache = this.app.metadataCache.getFileCache(file);
    if (!cache) return false;
    const fileTags = [];
    if ((_a = cache.frontmatter) == null ? void 0 : _a.tags) {
      const fmTags = cache.frontmatter.tags;
      if (Array.isArray(fmTags)) {
        fileTags.push(...fmTags.map((t2) => t2.replace(/^#/, "")));
      } else if (typeof fmTags === "string") {
        fileTags.push(fmTags.replace(/^#/, ""));
      }
    }
    if (cache.tags) {
      fileTags.push(...cache.tags.map((t2) => t2.tag.replace(/^#/, "")));
    }
    return fileTags.some((tag) => excludedTags.includes(tag));
  }
};

// src/features/chat/ui/ImageContext.ts
var import_obsidian17 = require("obsidian");
var path7 = __toESM(require("path"));
var MAX_IMAGE_SIZE = 5 * 1024 * 1024;
var IMAGE_EXTENSIONS2 = {
  ".jpg": "image/jpeg",
  ".jpeg": "image/jpeg",
  ".png": "image/png",
  ".gif": "image/gif",
  ".webp": "image/webp"
};
var ImageContextManager = class {
  constructor(containerEl, inputEl, callbacks, previewContainerEl) {
    this.dropOverlay = null;
    this.attachedImages = /* @__PURE__ */ new Map();
    this.containerEl = containerEl;
    this.previewContainerEl = previewContainerEl != null ? previewContainerEl : containerEl;
    this.inputEl = inputEl;
    this.callbacks = callbacks;
    const fileIndicator = this.previewContainerEl.querySelector(".claudian-file-indicator");
    this.imagePreviewEl = this.previewContainerEl.createDiv({ cls: "claudian-image-preview" });
    if (fileIndicator && fileIndicator.parentElement === this.previewContainerEl) {
      this.previewContainerEl.insertBefore(this.imagePreviewEl, fileIndicator);
    }
    this.setupDragAndDrop();
    this.setupPasteHandler();
  }
  getAttachedImages() {
    return Array.from(this.attachedImages.values());
  }
  hasImages() {
    return this.attachedImages.size > 0;
  }
  clearImages() {
    this.attachedImages.clear();
    this.updateImagePreview();
    this.callbacks.onImagesChanged();
  }
  /** Sets images directly (used for queued messages). */
  setImages(images) {
    this.attachedImages.clear();
    for (const image of images) {
      this.attachedImages.set(image.id, image);
    }
    this.updateImagePreview();
    this.callbacks.onImagesChanged();
  }
  setupDragAndDrop() {
    const inputWrapper = this.containerEl.querySelector(".claudian-input-wrapper");
    if (!inputWrapper) return;
    this.dropOverlay = inputWrapper.createDiv({ cls: "claudian-drop-overlay" });
    const dropContent = this.dropOverlay.createDiv({ cls: "claudian-drop-content" });
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("viewBox", "0 0 24 24");
    svg.setAttribute("width", "32");
    svg.setAttribute("height", "32");
    svg.setAttribute("fill", "none");
    svg.setAttribute("stroke", "currentColor");
    svg.setAttribute("stroke-width", "2");
    const pathEl = document.createElementNS("http://www.w3.org/2000/svg", "path");
    pathEl.setAttribute("d", "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4");
    const polyline = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
    polyline.setAttribute("points", "17 8 12 3 7 8");
    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    line.setAttribute("x1", "12");
    line.setAttribute("y1", "3");
    line.setAttribute("x2", "12");
    line.setAttribute("y2", "15");
    svg.appendChild(pathEl);
    svg.appendChild(polyline);
    svg.appendChild(line);
    dropContent.appendChild(svg);
    dropContent.createSpan({ text: "Drop image here" });
    const dropZone = inputWrapper;
    dropZone.addEventListener("dragenter", (e2) => this.handleDragEnter(e2));
    dropZone.addEventListener("dragover", (e2) => this.handleDragOver(e2));
    dropZone.addEventListener("dragleave", (e2) => this.handleDragLeave(e2));
    dropZone.addEventListener("drop", (e2) => this.handleDrop(e2));
  }
  handleDragEnter(e2) {
    var _a, _b;
    e2.preventDefault();
    e2.stopPropagation();
    if ((_a = e2.dataTransfer) == null ? void 0 : _a.types.includes("Files")) {
      (_b = this.dropOverlay) == null ? void 0 : _b.addClass("visible");
    }
  }
  handleDragOver(e2) {
    e2.preventDefault();
    e2.stopPropagation();
  }
  handleDragLeave(e2) {
    var _a, _b;
    e2.preventDefault();
    e2.stopPropagation();
    const inputWrapper = this.containerEl.querySelector(".claudian-input-wrapper");
    if (!inputWrapper) {
      (_a = this.dropOverlay) == null ? void 0 : _a.removeClass("visible");
      return;
    }
    const rect = inputWrapper.getBoundingClientRect();
    if (e2.clientX <= rect.left || e2.clientX >= rect.right || e2.clientY <= rect.top || e2.clientY >= rect.bottom) {
      (_b = this.dropOverlay) == null ? void 0 : _b.removeClass("visible");
    }
  }
  async handleDrop(e2) {
    var _a, _b;
    e2.preventDefault();
    e2.stopPropagation();
    (_a = this.dropOverlay) == null ? void 0 : _a.removeClass("visible");
    const files = (_b = e2.dataTransfer) == null ? void 0 : _b.files;
    if (!files) return;
    for (let i2 = 0; i2 < files.length; i2++) {
      const file = files[i2];
      if (this.isImageFile(file)) {
        await this.addImageFromFile(file, "drop");
      }
    }
  }
  setupPasteHandler() {
    this.inputEl.addEventListener("paste", async (e2) => {
      var _a;
      const items = (_a = e2.clipboardData) == null ? void 0 : _a.items;
      if (!items) return;
      for (let i2 = 0; i2 < items.length; i2++) {
        const item = items[i2];
        if (item.type.startsWith("image/")) {
          e2.preventDefault();
          const file = item.getAsFile();
          if (file) {
            await this.addImageFromFile(file, "paste");
          }
          return;
        }
      }
    });
  }
  isImageFile(file) {
    return file.type.startsWith("image/") && this.getMediaType(file.name) !== null;
  }
  getMediaType(filename) {
    const ext = path7.extname(filename).toLowerCase();
    return IMAGE_EXTENSIONS2[ext] || null;
  }
  async addImageFromFile(file, source) {
    if (file.size > MAX_IMAGE_SIZE) {
      this.notifyImageError(`Image exceeds ${this.formatSize(MAX_IMAGE_SIZE)} limit.`);
      return false;
    }
    const mediaType = this.getMediaType(file.name) || file.type;
    if (!mediaType) {
      this.notifyImageError("Unsupported image type.");
      return false;
    }
    try {
      const base64 = await this.fileToBase64(file);
      const attachment = {
        id: this.generateId(),
        name: file.name || `image-${Date.now()}.${mediaType.split("/")[1]}`,
        mediaType,
        data: base64,
        size: file.size,
        source
      };
      this.attachedImages.set(attachment.id, attachment);
      this.updateImagePreview();
      this.callbacks.onImagesChanged();
      return true;
    } catch (error) {
      this.notifyImageError("Failed to attach image.", error);
      return false;
    }
  }
  async fileToBase64(file) {
    const arrayBuffer = await file.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);
    return buffer.toString("base64");
  }
  // ============================================
  // Private: Image Preview
  // ============================================
  updateImagePreview() {
    this.imagePreviewEl.empty();
    if (this.attachedImages.size === 0) {
      this.imagePreviewEl.style.display = "none";
      return;
    }
    this.imagePreviewEl.style.display = "flex";
    for (const [id, image] of this.attachedImages) {
      this.renderImagePreview(id, image);
    }
  }
  renderImagePreview(id, image) {
    const previewEl = this.imagePreviewEl.createDiv({ cls: "claudian-image-chip" });
    const thumbEl = previewEl.createDiv({ cls: "claudian-image-thumb" });
    thumbEl.createEl("img", {
      attr: {
        src: `data:${image.mediaType};base64,${image.data}`,
        alt: image.name
      }
    });
    const infoEl = previewEl.createDiv({ cls: "claudian-image-info" });
    const nameEl = infoEl.createSpan({ cls: "claudian-image-name" });
    nameEl.setText(this.truncateName(image.name, 20));
    nameEl.setAttribute("title", image.name);
    const sizeEl = infoEl.createSpan({ cls: "claudian-image-size" });
    sizeEl.setText(this.formatSize(image.size));
    const removeEl = previewEl.createSpan({ cls: "claudian-image-remove" });
    removeEl.setText("\xD7");
    removeEl.setAttribute("aria-label", "Remove image");
    removeEl.addEventListener("click", (e2) => {
      e2.stopPropagation();
      this.attachedImages.delete(id);
      this.updateImagePreview();
      this.callbacks.onImagesChanged();
    });
    thumbEl.addEventListener("click", () => {
      this.showFullImage(image);
    });
  }
  showFullImage(image) {
    const overlay = document.body.createDiv({ cls: "claudian-image-modal-overlay" });
    const modal = overlay.createDiv({ cls: "claudian-image-modal" });
    modal.createEl("img", {
      attr: {
        src: `data:${image.mediaType};base64,${image.data}`,
        alt: image.name
      }
    });
    const closeBtn = modal.createDiv({ cls: "claudian-image-modal-close" });
    closeBtn.setText("\xD7");
    const handleEsc = (e2) => {
      if (e2.key === "Escape") {
        close();
      }
    };
    const close = () => {
      document.removeEventListener("keydown", handleEsc);
      overlay.remove();
    };
    closeBtn.addEventListener("click", close);
    overlay.addEventListener("click", (e2) => {
      if (e2.target === overlay) close();
    });
    document.addEventListener("keydown", handleEsc);
  }
  generateId() {
    return `img-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
  }
  truncateName(name, maxLen) {
    if (name.length <= maxLen) return name;
    const ext = path7.extname(name);
    const base = name.slice(0, name.length - ext.length);
    const truncatedBase = base.slice(0, maxLen - ext.length - 3);
    return `${truncatedBase}...${ext}`;
  }
  formatSize(bytes) {
    if (bytes < 1024) return `${bytes} B`;
    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
    return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
  }
  notifyImageError(message, error) {
    let userMessage = message;
    if (error instanceof Error) {
      if (error.message.includes("ENOENT") || error.message.includes("no such file")) {
        userMessage = `${message} (File not found)`;
      } else if (error.message.includes("EACCES") || error.message.includes("permission denied")) {
        userMessage = `${message} (Permission denied)`;
      }
    }
    new import_obsidian17.Notice(userMessage);
  }
};

// src/features/chat/ui/InputToolbar.ts
var import_obsidian18 = require("obsidian");
var path8 = __toESM(require("path"));
var ModelSelector = class {
  constructor(parentEl, callbacks) {
    this.buttonEl = null;
    this.dropdownEl = null;
    this.callbacks = callbacks;
    this.container = parentEl.createDiv({ cls: "claudian-model-selector" });
    this.render();
  }
  getAvailableModels() {
    let models = [];
    if (this.callbacks.getEnvironmentVariables) {
      const envVarsStr = this.callbacks.getEnvironmentVariables();
      const envVars = parseEnvironmentVariables(envVarsStr);
      const customModels = getModelsFromEnvironment(envVars);
      if (customModels.length > 0) {
        models = customModels;
      } else {
        models = [...DEFAULT_CLAUDE_MODELS];
      }
    } else {
      models = [...DEFAULT_CLAUDE_MODELS];
    }
    const settings11 = this.callbacks.getSettings();
    if (settings11.show1MModel) {
      models = models.map(
        (m) => m.value === "sonnet" ? { ...m, label: "Sonnet (1M)" } : m
      );
    }
    return models;
  }
  render() {
    this.container.empty();
    this.buttonEl = this.container.createDiv({ cls: "claudian-model-btn" });
    this.updateDisplay();
    this.dropdownEl = this.container.createDiv({ cls: "claudian-model-dropdown" });
    this.renderOptions();
  }
  updateDisplay() {
    if (!this.buttonEl) return;
    const currentModel = this.callbacks.getSettings().model;
    const models = this.getAvailableModels();
    const modelInfo = models.find((m) => m.value === currentModel);
    const displayModel = modelInfo || models[0];
    this.buttonEl.empty();
    const labelEl = this.buttonEl.createSpan({ cls: "claudian-model-label" });
    labelEl.setText((displayModel == null ? void 0 : displayModel.label) || "Unknown");
  }
  renderOptions() {
    if (!this.dropdownEl) return;
    this.dropdownEl.empty();
    const currentModel = this.callbacks.getSettings().model;
    const models = this.getAvailableModels();
    for (const model of [...models].reverse()) {
      const option = this.dropdownEl.createDiv({ cls: "claudian-model-option" });
      if (model.value === currentModel) {
        option.addClass("selected");
      }
      option.createSpan({ text: model.label });
      if (model.description) {
        option.setAttribute("title", model.description);
      }
      option.addEventListener("click", async (e2) => {
        e2.stopPropagation();
        await this.callbacks.onModelChange(model.value);
        this.updateDisplay();
        this.renderOptions();
      });
    }
  }
};
var ThinkingBudgetSelector = class {
  constructor(parentEl, callbacks) {
    this.gearsEl = null;
    this.callbacks = callbacks;
    this.container = parentEl.createDiv({ cls: "claudian-thinking-selector" });
    this.render();
  }
  render() {
    this.container.empty();
    const labelEl = this.container.createSpan({ cls: "claudian-thinking-label-text" });
    labelEl.setText("Thinking:");
    this.gearsEl = this.container.createDiv({ cls: "claudian-thinking-gears" });
    this.renderGears();
  }
  renderGears() {
    if (!this.gearsEl) return;
    this.gearsEl.empty();
    const currentBudget = this.callbacks.getSettings().thinkingBudget;
    const currentBudgetInfo = THINKING_BUDGETS.find((b3) => b3.value === currentBudget);
    const currentEl = this.gearsEl.createDiv({ cls: "claudian-thinking-current" });
    currentEl.setText((currentBudgetInfo == null ? void 0 : currentBudgetInfo.label) || "Off");
    const optionsEl = this.gearsEl.createDiv({ cls: "claudian-thinking-options" });
    for (const budget of [...THINKING_BUDGETS].reverse()) {
      const gearEl = optionsEl.createDiv({ cls: "claudian-thinking-gear" });
      gearEl.setText(budget.label);
      gearEl.setAttribute("title", budget.tokens > 0 ? `${budget.tokens.toLocaleString()} tokens` : "Disabled");
      if (budget.value === currentBudget) {
        gearEl.addClass("selected");
      }
      gearEl.addEventListener("click", async (e2) => {
        e2.stopPropagation();
        await this.callbacks.onThinkingBudgetChange(budget.value);
        this.updateDisplay();
      });
    }
  }
  updateDisplay() {
    this.renderGears();
  }
};
var PermissionToggle = class {
  constructor(parentEl, callbacks) {
    this.toggleEl = null;
    this.labelEl = null;
    this.callbacks = callbacks;
    this.container = parentEl.createDiv({ cls: "claudian-permission-toggle" });
    this.render();
  }
  render() {
    this.container.empty();
    this.labelEl = this.container.createSpan({ cls: "claudian-permission-label" });
    this.toggleEl = this.container.createDiv({ cls: "claudian-toggle-switch" });
    this.updateDisplay();
    this.toggleEl.addEventListener("click", () => this.toggle());
  }
  updateDisplay() {
    if (!this.toggleEl || !this.labelEl) return;
    const isYolo = this.callbacks.getSettings().permissionMode === "yolo";
    if (isYolo) {
      this.toggleEl.addClass("active");
    } else {
      this.toggleEl.removeClass("active");
    }
    this.labelEl.setText(isYolo ? "YOLO" : "Safe");
  }
  async toggle() {
    const current = this.callbacks.getSettings().permissionMode;
    const newMode = current === "yolo" ? "normal" : "yolo";
    await this.callbacks.onPermissionModeChange(newMode);
    this.updateDisplay();
  }
};
var ExternalContextSelector = class {
  constructor(parentEl, callbacks) {
    this.iconEl = null;
    this.badgeEl = null;
    this.dropdownEl = null;
    /**
     * Current external context paths. May contain:
     * - Persistent paths only (new sessions via clearExternalContexts)
     * - Restored session paths (loaded sessions via setExternalContexts)
     * - Mixed paths during active sessions
     */
    this.externalContextPaths = [];
    /** Paths that persist across all sessions (stored in settings). */
    this.persistentPaths = /* @__PURE__ */ new Set();
    this.onChangeCallback = null;
    this.onPersistenceChangeCallback = null;
    this.callbacks = callbacks;
    this.container = parentEl.createDiv({ cls: "claudian-external-context-selector" });
    this.render();
  }
  setOnChange(callback) {
    this.onChangeCallback = callback;
  }
  setOnPersistenceChange(callback) {
    this.onPersistenceChangeCallback = callback;
  }
  getExternalContexts() {
    return [...this.externalContextPaths];
  }
  getPersistentPaths() {
    return [...this.persistentPaths];
  }
  setPersistentPaths(paths) {
    var _a;
    const validPaths = filterValidPaths(paths);
    const invalidPaths = paths.filter((p2) => !validPaths.includes(p2));
    this.persistentPaths = new Set(validPaths);
    this.mergePersistentPaths();
    this.updateDisplay();
    this.renderDropdown();
    if (invalidPaths.length > 0) {
      const pathNames = invalidPaths.map((p2) => this.shortenPath(p2)).join(", ");
      new import_obsidian18.Notice(`Removed ${invalidPaths.length} invalid external context path(s): ${pathNames}`, 5e3);
      (_a = this.onPersistenceChangeCallback) == null ? void 0 : _a.call(this, [...this.persistentPaths]);
    }
  }
  togglePersistence(path10) {
    var _a;
    if (this.persistentPaths.has(path10)) {
      this.persistentPaths.delete(path10);
    } else {
      if (!isValidDirectoryPath(path10)) {
        new import_obsidian18.Notice(`Cannot persist "${this.shortenPath(path10)}" - directory no longer exists`, 4e3);
        return;
      }
      this.persistentPaths.add(path10);
    }
    (_a = this.onPersistenceChangeCallback) == null ? void 0 : _a.call(this, [...this.persistentPaths]);
    this.renderDropdown();
  }
  mergePersistentPaths() {
    const pathSet = new Set(this.externalContextPaths);
    for (const path10 of this.persistentPaths) {
      pathSet.add(path10);
    }
    this.externalContextPaths = [...pathSet];
  }
  /**
   * Restore exact external context paths from a saved conversation.
   * Does NOT merge with persistent paths - preserves the session's historical state.
   * Use clearExternalContexts() for new sessions to start with current persistent paths.
   */
  setExternalContexts(paths) {
    this.externalContextPaths = [...paths];
    this.updateDisplay();
    this.renderDropdown();
  }
  /**
   * Remove a path from external contexts (and persistent paths if applicable).
   * Exposed for testing the remove button behavior.
   */
  removePath(pathStr) {
    var _a, _b;
    this.externalContextPaths = this.externalContextPaths.filter((p2) => p2 !== pathStr);
    if (this.persistentPaths.has(pathStr)) {
      this.persistentPaths.delete(pathStr);
      (_a = this.onPersistenceChangeCallback) == null ? void 0 : _a.call(this, [...this.persistentPaths]);
    }
    (_b = this.onChangeCallback) == null ? void 0 : _b.call(this, this.externalContextPaths);
    this.updateDisplay();
    this.renderDropdown();
  }
  /**
   * Add an external context path programmatically (e.g., from /add-dir command).
   * Validates the path and handles duplicates/conflicts.
   * @param pathInput - Path string (supports ~/ expansion)
   * @returns Result with success status and normalized path, or error message on failure
   */
  addExternalContext(pathInput) {
    var _a;
    const trimmed = pathInput == null ? void 0 : pathInput.trim();
    if (!trimmed) {
      return { success: false, error: "No path provided. Usage: /add-dir /absolute/path" };
    }
    let cleanPath = trimmed;
    if (cleanPath.startsWith('"') && cleanPath.endsWith('"') || cleanPath.startsWith("'") && cleanPath.endsWith("'")) {
      cleanPath = cleanPath.slice(1, -1);
    }
    const expandedPath = expandHomePath(cleanPath);
    const normalizedPath = normalizePathForFilesystem(expandedPath);
    if (!path8.isAbsolute(normalizedPath)) {
      return { success: false, error: "Path must be absolute. Usage: /add-dir /absolute/path" };
    }
    const validation = validateDirectoryPath(normalizedPath);
    if (!validation.valid) {
      return { success: false, error: `${validation.error}: ${pathInput}` };
    }
    if (isDuplicatePath(normalizedPath, this.externalContextPaths)) {
      return { success: false, error: "This folder is already added as an external context." };
    }
    const conflict = findConflictingPath(normalizedPath, this.externalContextPaths);
    if (conflict) {
      return { success: false, error: this.formatConflictMessage(normalizedPath, conflict) };
    }
    this.externalContextPaths = [...this.externalContextPaths, normalizedPath];
    (_a = this.onChangeCallback) == null ? void 0 : _a.call(this, this.externalContextPaths);
    this.updateDisplay();
    this.renderDropdown();
    return { success: true, normalizedPath };
  }
  /**
   * Clear session-only external context paths (call on new conversation).
   * Uses persistent paths from settings if provided, otherwise falls back to local cache.
   * Validates paths before using them (silently filters invalid during session init).
   */
  clearExternalContexts(persistentPathsFromSettings) {
    if (persistentPathsFromSettings) {
      const validPaths = filterValidPaths(persistentPathsFromSettings);
      this.persistentPaths = new Set(validPaths);
    }
    this.externalContextPaths = [...this.persistentPaths];
    this.updateDisplay();
    this.renderDropdown();
  }
  render() {
    this.container.empty();
    const iconWrapper = this.container.createDiv({ cls: "claudian-external-context-icon-wrapper" });
    this.iconEl = iconWrapper.createDiv({ cls: "claudian-external-context-icon" });
    (0, import_obsidian18.setIcon)(this.iconEl, "folder");
    this.badgeEl = iconWrapper.createDiv({ cls: "claudian-external-context-badge" });
    this.updateDisplay();
    iconWrapper.addEventListener("click", (e2) => {
      e2.stopPropagation();
      this.openFolderPicker();
    });
    this.dropdownEl = this.container.createDiv({ cls: "claudian-external-context-dropdown" });
    this.renderDropdown();
  }
  async openFolderPicker() {
    var _a;
    try {
      const { remote } = require("electron");
      const result = await remote.dialog.showOpenDialog({
        properties: ["openDirectory"],
        title: "Select External Context"
      });
      if (!result.canceled && result.filePaths.length > 0) {
        const selectedPath = result.filePaths[0];
        if (isDuplicatePath(selectedPath, this.externalContextPaths)) {
          new import_obsidian18.Notice("This folder is already added as an external context.", 3e3);
          return;
        }
        const conflict = findConflictingPath(selectedPath, this.externalContextPaths);
        if (conflict) {
          new import_obsidian18.Notice(this.formatConflictMessage(selectedPath, conflict), 5e3);
          return;
        }
        this.externalContextPaths = [...this.externalContextPaths, selectedPath];
        (_a = this.onChangeCallback) == null ? void 0 : _a.call(this, this.externalContextPaths);
        this.updateDisplay();
        this.renderDropdown();
      }
    } catch (e2) {
      new import_obsidian18.Notice("Unable to open folder picker.", 5e3);
    }
  }
  /** Formats a conflict error message for display. */
  formatConflictMessage(newPath, conflict) {
    const shortNew = this.shortenPath(newPath);
    const shortExisting = this.shortenPath(conflict.path);
    return conflict.type === "parent" ? `Cannot add "${shortNew}" - it's inside existing path "${shortExisting}"` : `Cannot add "${shortNew}" - it contains existing path "${shortExisting}"`;
  }
  renderDropdown() {
    if (!this.dropdownEl) return;
    this.dropdownEl.empty();
    const headerEl = this.dropdownEl.createDiv({ cls: "claudian-external-context-header" });
    headerEl.setText("External Contexts");
    const listEl = this.dropdownEl.createDiv({ cls: "claudian-external-context-list" });
    if (this.externalContextPaths.length === 0) {
      const emptyEl = listEl.createDiv({ cls: "claudian-external-context-empty" });
      emptyEl.setText("Click folder icon to add");
    } else {
      for (const pathStr of this.externalContextPaths) {
        const itemEl = listEl.createDiv({ cls: "claudian-external-context-item" });
        const pathTextEl = itemEl.createSpan({ cls: "claudian-external-context-text" });
        const displayPath = this.shortenPath(pathStr);
        pathTextEl.setText(displayPath);
        pathTextEl.setAttribute("title", pathStr);
        const isPersistent = this.persistentPaths.has(pathStr);
        const lockBtn = itemEl.createSpan({ cls: "claudian-external-context-lock" });
        if (isPersistent) {
          lockBtn.addClass("locked");
        }
        (0, import_obsidian18.setIcon)(lockBtn, isPersistent ? "lock" : "unlock");
        lockBtn.setAttribute("title", isPersistent ? "Persistent (click to make session-only)" : "Session-only (click to persist)");
        lockBtn.addEventListener("click", (e2) => {
          e2.stopPropagation();
          this.togglePersistence(pathStr);
        });
        const removeBtn = itemEl.createSpan({ cls: "claudian-external-context-remove" });
        (0, import_obsidian18.setIcon)(removeBtn, "x");
        removeBtn.setAttribute("title", "Remove path");
        removeBtn.addEventListener("click", (e2) => {
          e2.stopPropagation();
          this.removePath(pathStr);
        });
      }
    }
  }
  /** Shorten path for display (replace home dir with ~) */
  shortenPath(fullPath) {
    try {
      const os6 = require("os");
      const homeDir = os6.homedir();
      const normalize2 = (value) => value.replace(/\\/g, "/");
      const normalizedFull = normalize2(fullPath);
      const normalizedHome = normalize2(homeDir);
      const compareFull = process.platform === "win32" ? normalizedFull.toLowerCase() : normalizedFull;
      const compareHome = process.platform === "win32" ? normalizedHome.toLowerCase() : normalizedHome;
      if (compareFull.startsWith(compareHome)) {
        const remainder = normalizedFull.slice(normalizedHome.length);
        return "~" + remainder;
      }
    } catch (e2) {
    }
    return fullPath;
  }
  updateDisplay() {
    if (!this.iconEl || !this.badgeEl) return;
    const count = this.externalContextPaths.length;
    if (count > 0) {
      this.iconEl.addClass("active");
      this.iconEl.setAttribute("title", `${count} external context${count > 1 ? "s" : ""} (click to add more)`);
      if (count > 1) {
        this.badgeEl.setText(String(count));
        this.badgeEl.addClass("visible");
      } else {
        this.badgeEl.removeClass("visible");
      }
    } else {
      this.iconEl.removeClass("active");
      this.iconEl.setAttribute("title", "Add external contexts (click)");
      this.badgeEl.removeClass("visible");
    }
  }
};
var McpServerSelector = class {
  constructor(parentEl) {
    this.iconEl = null;
    this.badgeEl = null;
    this.dropdownEl = null;
    this.mcpService = null;
    this.enabledServers = /* @__PURE__ */ new Set();
    this.onChangeCallback = null;
    this.container = parentEl.createDiv({ cls: "claudian-mcp-selector" });
    this.render();
  }
  setMcpService(service) {
    this.mcpService = service;
    this.pruneEnabledServers();
    this.updateDisplay();
    this.renderDropdown();
  }
  setOnChange(callback) {
    this.onChangeCallback = callback;
  }
  getEnabledServers() {
    return new Set(this.enabledServers);
  }
  addMentionedServers(names) {
    let changed = false;
    for (const name of names) {
      if (!this.enabledServers.has(name)) {
        this.enabledServers.add(name);
        changed = true;
      }
    }
    if (changed) {
      this.updateDisplay();
      this.renderDropdown();
    }
  }
  clearEnabled() {
    this.enabledServers.clear();
    this.updateDisplay();
    this.renderDropdown();
  }
  setEnabledServers(names) {
    this.enabledServers = new Set(names);
    this.pruneEnabledServers();
    this.updateDisplay();
    this.renderDropdown();
  }
  pruneEnabledServers() {
    var _a;
    if (!this.mcpService) return;
    const activeNames = new Set(this.mcpService.getServers().filter((s) => s.enabled).map((s) => s.name));
    let changed = false;
    for (const name of this.enabledServers) {
      if (!activeNames.has(name)) {
        this.enabledServers.delete(name);
        changed = true;
      }
    }
    if (changed) {
      (_a = this.onChangeCallback) == null ? void 0 : _a.call(this, this.enabledServers);
    }
  }
  render() {
    this.container.empty();
    const iconWrapper = this.container.createDiv({ cls: "claudian-mcp-selector-icon-wrapper" });
    this.iconEl = iconWrapper.createDiv({ cls: "claudian-mcp-selector-icon" });
    this.iconEl.innerHTML = MCP_ICON_SVG;
    this.badgeEl = iconWrapper.createDiv({ cls: "claudian-mcp-selector-badge" });
    this.updateDisplay();
    this.dropdownEl = this.container.createDiv({ cls: "claudian-mcp-selector-dropdown" });
    this.renderDropdown();
    this.container.addEventListener("mouseenter", () => {
      this.renderDropdown();
    });
  }
  renderDropdown() {
    var _a;
    if (!this.dropdownEl) return;
    this.pruneEnabledServers();
    this.dropdownEl.empty();
    const headerEl = this.dropdownEl.createDiv({ cls: "claudian-mcp-selector-header" });
    headerEl.setText("MCP Servers");
    const listEl = this.dropdownEl.createDiv({ cls: "claudian-mcp-selector-list" });
    const allServers = ((_a = this.mcpService) == null ? void 0 : _a.getServers()) || [];
    const servers = allServers.filter((s) => s.enabled);
    if (servers.length === 0) {
      const emptyEl = listEl.createDiv({ cls: "claudian-mcp-selector-empty" });
      emptyEl.setText(allServers.length === 0 ? "No MCP servers configured" : "All MCP servers disabled");
      return;
    }
    for (const server of servers) {
      this.renderServerItem(listEl, server);
    }
  }
  renderServerItem(listEl, server) {
    const itemEl = listEl.createDiv({ cls: "claudian-mcp-selector-item" });
    itemEl.dataset.serverName = server.name;
    const isEnabled = this.enabledServers.has(server.name);
    if (isEnabled) {
      itemEl.addClass("enabled");
    }
    const checkEl = itemEl.createDiv({ cls: "claudian-mcp-selector-check" });
    if (isEnabled) {
      checkEl.innerHTML = CHECK_ICON_SVG;
    }
    const infoEl = itemEl.createDiv({ cls: "claudian-mcp-selector-item-info" });
    const nameEl = infoEl.createSpan({ cls: "claudian-mcp-selector-item-name" });
    nameEl.setText(server.name);
    if (server.contextSaving) {
      const csEl = infoEl.createSpan({ cls: "claudian-mcp-selector-cs-badge" });
      csEl.setText("@");
      csEl.setAttribute("title", "Context-saving: can also enable via @" + server.name);
    }
    itemEl.addEventListener("mousedown", (e2) => {
      e2.preventDefault();
      e2.stopPropagation();
      this.toggleServer(server.name, itemEl);
    });
  }
  toggleServer(name, itemEl) {
    var _a;
    if (this.enabledServers.has(name)) {
      this.enabledServers.delete(name);
    } else {
      this.enabledServers.add(name);
    }
    const isEnabled = this.enabledServers.has(name);
    const checkEl = itemEl.querySelector(".claudian-mcp-selector-check");
    if (isEnabled) {
      itemEl.addClass("enabled");
      if (checkEl) checkEl.innerHTML = CHECK_ICON_SVG;
    } else {
      itemEl.removeClass("enabled");
      if (checkEl) checkEl.innerHTML = "";
    }
    this.updateDisplay();
    (_a = this.onChangeCallback) == null ? void 0 : _a.call(this, this.enabledServers);
  }
  updateDisplay() {
    var _a;
    this.pruneEnabledServers();
    if (!this.iconEl || !this.badgeEl) return;
    const count = this.enabledServers.size;
    const hasServers = (((_a = this.mcpService) == null ? void 0 : _a.getServers().length) || 0) > 0;
    if (!hasServers) {
      this.container.style.display = "none";
      return;
    }
    this.container.style.display = "";
    if (count > 0) {
      this.iconEl.addClass("active");
      this.iconEl.setAttribute("title", `${count} MCP server${count > 1 ? "s" : ""} enabled (click to manage)`);
      if (count > 1) {
        this.badgeEl.setText(String(count));
        this.badgeEl.addClass("visible");
      } else {
        this.badgeEl.removeClass("visible");
      }
    } else {
      this.iconEl.removeClass("active");
      this.iconEl.setAttribute("title", "MCP servers (click to enable)");
      this.badgeEl.removeClass("visible");
    }
  }
};
var ContextUsageMeter = class {
  constructor(parentEl) {
    this.fillPath = null;
    this.percentEl = null;
    this.circumference = 0;
    this.container = parentEl.createDiv({ cls: "claudian-context-meter" });
    this.render();
    this.container.style.display = "none";
  }
  render() {
    const size = 16;
    const strokeWidth = 2;
    const radius = (size - strokeWidth) / 2;
    const cx = size / 2;
    const cy = size / 2;
    const startAngle = 150;
    const endAngle = 390;
    const arcDegrees = endAngle - startAngle;
    const arcRadians = arcDegrees * Math.PI / 180;
    this.circumference = radius * arcRadians;
    const startRad = startAngle * Math.PI / 180;
    const endRad = endAngle * Math.PI / 180;
    const x12 = cx + radius * Math.cos(startRad);
    const y12 = cy + radius * Math.sin(startRad);
    const x22 = cx + radius * Math.cos(endRad);
    const y22 = cy + radius * Math.sin(endRad);
    const gaugeEl = this.container.createDiv({ cls: "claudian-context-meter-gauge" });
    gaugeEl.innerHTML = `
      <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">
        <path class="claudian-meter-bg"
          d="M ${x12} ${y12} A ${radius} ${radius} 0 1 1 ${x22} ${y22}"
          fill="none" stroke-width="${strokeWidth}" stroke-linecap="round"/>
        <path class="claudian-meter-fill"
          d="M ${x12} ${y12} A ${radius} ${radius} 0 1 1 ${x22} ${y22}"
          fill="none" stroke-width="${strokeWidth}" stroke-linecap="round"
          stroke-dasharray="${this.circumference}" stroke-dashoffset="${this.circumference}"/>
      </svg>
    `;
    this.fillPath = gaugeEl.querySelector(".claudian-meter-fill");
    this.percentEl = this.container.createSpan({ cls: "claudian-context-meter-percent" });
  }
  update(usage) {
    if (!usage || usage.contextTokens <= 0) {
      this.container.style.display = "none";
      return;
    }
    this.container.style.display = "flex";
    const fillLength = usage.percentage / 100 * this.circumference;
    if (this.fillPath) {
      this.fillPath.style.strokeDashoffset = String(this.circumference - fillLength);
    }
    if (this.percentEl) {
      this.percentEl.setText(`${usage.percentage}%`);
    }
    if (usage.percentage > 80) {
      this.container.addClass("warning");
    } else {
      this.container.removeClass("warning");
    }
    const tooltip = `${this.formatTokens(usage.contextTokens)} / ${this.formatTokens(usage.contextWindow)}`;
    this.container.setAttribute("data-tooltip", tooltip);
  }
  formatTokens(tokens) {
    if (tokens >= 1e3) {
      return `${Math.round(tokens / 1e3)}k`;
    }
    return String(tokens);
  }
};
function createInputToolbar(parentEl, callbacks) {
  const modelSelector = new ModelSelector(parentEl, callbacks);
  const thinkingBudgetSelector = new ThinkingBudgetSelector(parentEl, callbacks);
  const contextUsageMeter = new ContextUsageMeter(parentEl);
  const externalContextSelector = new ExternalContextSelector(parentEl, callbacks);
  const mcpServerSelector = new McpServerSelector(parentEl);
  const permissionToggle = new PermissionToggle(parentEl, callbacks);
  return { modelSelector, thinkingBudgetSelector, contextUsageMeter, externalContextSelector, mcpServerSelector, permissionToggle };
}

// src/features/chat/ui/InstructionModeManager.ts
var INSTRUCTION_MODE_PLACEHOLDER = "# Save in custom system prompt";
var InstructionModeManager = class {
  constructor(inputEl, callbacks) {
    this.state = { active: false, rawInstruction: "" };
    this.isSubmitting = false;
    this.originalPlaceholder = "";
    this.inputEl = inputEl;
    this.callbacks = callbacks;
    this.originalPlaceholder = inputEl.placeholder;
  }
  /**
   * Handles keydown to detect # trigger.
   * Returns true if the event was consumed (should prevent default).
   */
  handleTriggerKey(e2) {
    if (!this.state.active && this.inputEl.value === "" && e2.key === "#") {
      if (this.enterMode()) {
        e2.preventDefault();
        return true;
      }
    }
    return false;
  }
  /** Handles input changes to track instruction text. */
  handleInputChange() {
    if (!this.state.active) return;
    const text = this.inputEl.value;
    if (text === "") {
      this.exitMode();
    } else {
      this.state.rawInstruction = text;
    }
  }
  /**
   * Enters instruction mode.
   * Only enters if the indicator can be successfully shown.
   * Returns true if mode was entered, false otherwise.
   */
  enterMode() {
    const wrapper = this.callbacks.getInputWrapper();
    if (!wrapper) return false;
    wrapper.addClass("claudian-input-instruction-mode");
    this.state = { active: true, rawInstruction: "" };
    this.inputEl.placeholder = INSTRUCTION_MODE_PLACEHOLDER;
    return true;
  }
  /** Exits instruction mode, restoring original state. */
  exitMode() {
    const wrapper = this.callbacks.getInputWrapper();
    if (wrapper) {
      wrapper.removeClass("claudian-input-instruction-mode");
    }
    this.state = { active: false, rawInstruction: "" };
    this.inputEl.placeholder = this.originalPlaceholder;
  }
  /** Handles keydown events. Returns true if handled. */
  handleKeydown(e2) {
    if (!this.state.active) return false;
    if (e2.key === "Enter" && !e2.shiftKey && !e2.isComposing) {
      if (!this.state.rawInstruction.trim()) {
        return false;
      }
      e2.preventDefault();
      this.submit();
      return true;
    }
    if (e2.key === "Escape" && !e2.isComposing) {
      e2.preventDefault();
      this.cancel();
      return true;
    }
    return false;
  }
  /** Checks if instruction mode is active. */
  isActive() {
    return this.state.active;
  }
  /** Gets the current raw instruction text. */
  getRawInstruction() {
    return this.state.rawInstruction;
  }
  /** Submits the instruction for refinement. */
  async submit() {
    if (this.isSubmitting) return;
    const rawInstruction = this.state.rawInstruction.trim();
    if (!rawInstruction) return;
    this.isSubmitting = true;
    try {
      await this.callbacks.onSubmit(rawInstruction);
    } finally {
      this.isSubmitting = false;
    }
  }
  /** Cancels instruction mode and clears input. */
  cancel() {
    var _a, _b;
    this.inputEl.value = "";
    this.exitMode();
    (_b = (_a = this.callbacks).resetInputHeight) == null ? void 0 : _b.call(_a);
  }
  /** Clears the input and resets state (called after successful submission). */
  clear() {
    var _a, _b;
    this.inputEl.value = "";
    this.exitMode();
    (_b = (_a = this.callbacks).resetInputHeight) == null ? void 0 : _b.call(_a);
  }
  /** Cleans up event listeners. */
  destroy() {
    const wrapper = this.callbacks.getInputWrapper();
    if (wrapper) {
      wrapper.removeClass("claudian-input-instruction-mode");
    }
    this.inputEl.placeholder = this.originalPlaceholder;
  }
};

// src/features/chat/ui/StatusPanel.ts
var import_obsidian19 = require("obsidian");
var TERMINAL_STATES = ["completed", "error", "orphaned"];
var StatusPanel = class {
  constructor() {
    this.containerEl = null;
    this.panelEl = null;
    // Async subagent section (above todos)
    this.subagentContainerEl = null;
    this.currentSubagents = /* @__PURE__ */ new Map();
    // Todo section
    this.todoContainerEl = null;
    this.todoHeaderEl = null;
    this.todoContentEl = null;
    this.isTodoExpanded = false;
    this.currentTodos = null;
    // Event handler references for cleanup
    this.todoClickHandler = null;
    this.todoKeydownHandler = null;
  }
  /**
   * Mount the panel into the messages container.
   * Appends to the end of the messages area.
   */
  mount(containerEl) {
    this.containerEl = containerEl;
    this.createPanel();
  }
  /**
   * Remount the panel to restore state after conversation changes.
   * Re-creates the panel structure and re-renders current state.
   */
  remount() {
    if (!this.containerEl) {
      return;
    }
    if (this.todoHeaderEl) {
      if (this.todoClickHandler) {
        this.todoHeaderEl.removeEventListener("click", this.todoClickHandler);
      }
      if (this.todoKeydownHandler) {
        this.todoHeaderEl.removeEventListener("keydown", this.todoKeydownHandler);
      }
    }
    this.todoClickHandler = null;
    this.todoKeydownHandler = null;
    if (this.panelEl) {
      this.panelEl.remove();
    }
    this.panelEl = null;
    this.subagentContainerEl = null;
    this.todoContainerEl = null;
    this.todoHeaderEl = null;
    this.todoContentEl = null;
    this.createPanel();
    this.renderSubagentStatus();
    if (this.currentTodos && this.currentTodos.length > 0) {
      this.updateTodos(this.currentTodos);
    }
  }
  /**
   * Create the panel structure.
   */
  createPanel() {
    if (!this.containerEl) {
      return;
    }
    this.panelEl = document.createElement("div");
    this.panelEl.className = "claudian-status-panel";
    this.subagentContainerEl = document.createElement("div");
    this.subagentContainerEl.className = "claudian-status-panel-subagents";
    this.subagentContainerEl.style.display = "none";
    this.panelEl.appendChild(this.subagentContainerEl);
    this.todoContainerEl = document.createElement("div");
    this.todoContainerEl.className = "claudian-status-panel-todos";
    this.todoContainerEl.style.display = "none";
    this.panelEl.appendChild(this.todoContainerEl);
    this.todoHeaderEl = document.createElement("div");
    this.todoHeaderEl.className = "claudian-status-panel-header";
    this.todoHeaderEl.setAttribute("tabindex", "0");
    this.todoHeaderEl.setAttribute("role", "button");
    this.todoClickHandler = () => this.toggleTodos();
    this.todoKeydownHandler = (e2) => {
      if (e2.key === "Enter" || e2.key === " ") {
        e2.preventDefault();
        this.toggleTodos();
      }
    };
    this.todoHeaderEl.addEventListener("click", this.todoClickHandler);
    this.todoHeaderEl.addEventListener("keydown", this.todoKeydownHandler);
    this.todoContainerEl.appendChild(this.todoHeaderEl);
    this.todoContentEl = document.createElement("div");
    this.todoContentEl.className = "claudian-status-panel-content claudian-todo-list-container";
    this.todoContentEl.style.display = "none";
    this.todoContainerEl.appendChild(this.todoContentEl);
    this.containerEl.appendChild(this.panelEl);
  }
  /**
   * Update the panel with new todo items.
   * Called by ChatState.onTodosChanged callback when TodoWrite tool is used.
   * Passing null or empty array hides the panel.
   */
  updateTodos(todos) {
    if (!this.todoContainerEl || !this.todoHeaderEl || !this.todoContentEl) {
      return;
    }
    this.currentTodos = todos;
    if (!todos || todos.length === 0) {
      this.todoContainerEl.style.display = "none";
      this.todoHeaderEl.empty();
      this.todoContentEl.empty();
      return;
    }
    this.todoContainerEl.style.display = "block";
    const completedCount = todos.filter((t2) => t2.status === "completed").length;
    const totalCount = todos.length;
    const currentTask = todos.find((t2) => t2.status === "in_progress");
    this.renderTodoHeader(completedCount, totalCount, currentTask);
    this.renderTodoContent(todos);
    this.updateTodoAriaLabel(completedCount, totalCount);
    this.scrollToBottom();
  }
  /**
   * Render the todo collapsed header.
   */
  renderTodoHeader(completedCount, totalCount, currentTask) {
    if (!this.todoHeaderEl) return;
    this.todoHeaderEl.empty();
    const icon = document.createElement("span");
    icon.className = "claudian-status-panel-icon";
    (0, import_obsidian19.setIcon)(icon, getToolIcon(TOOL_TODO_WRITE));
    this.todoHeaderEl.appendChild(icon);
    const label = document.createElement("span");
    label.className = "claudian-status-panel-label";
    label.textContent = `Tasks (${completedCount}/${totalCount})`;
    this.todoHeaderEl.appendChild(label);
    if (!this.isTodoExpanded) {
      if (completedCount === totalCount && totalCount > 0) {
        const status = document.createElement("span");
        status.className = "claudian-status-panel-status status-completed";
        (0, import_obsidian19.setIcon)(status, "check");
        this.todoHeaderEl.appendChild(status);
      }
      if (currentTask) {
        const current = document.createElement("span");
        current.className = "claudian-status-panel-current";
        current.textContent = currentTask.activeForm;
        this.todoHeaderEl.appendChild(current);
      }
    }
  }
  /**
   * Render the expanded todo content.
   */
  renderTodoContent(todos) {
    if (!this.todoContentEl) return;
    renderTodoItems(this.todoContentEl, todos);
  }
  /**
   * Toggle todo expanded/collapsed state.
   */
  toggleTodos() {
    this.isTodoExpanded = !this.isTodoExpanded;
    this.updateTodoDisplay();
  }
  /**
   * Update todo display based on expanded state.
   */
  updateTodoDisplay() {
    if (!this.todoContentEl || !this.todoHeaderEl) return;
    this.todoContentEl.style.display = this.isTodoExpanded ? "block" : "none";
    if (this.currentTodos && this.currentTodos.length > 0) {
      const completedCount = this.currentTodos.filter((t2) => t2.status === "completed").length;
      const totalCount = this.currentTodos.length;
      const currentTask = this.currentTodos.find((t2) => t2.status === "in_progress");
      this.renderTodoHeader(completedCount, totalCount, currentTask);
      this.updateTodoAriaLabel(completedCount, totalCount);
    }
    this.scrollToBottom();
  }
  /**
   * Update todo ARIA label.
   */
  updateTodoAriaLabel(completedCount, totalCount) {
    if (!this.todoHeaderEl) return;
    const action = this.isTodoExpanded ? "Collapse" : "Expand";
    this.todoHeaderEl.setAttribute(
      "aria-label",
      `${action} task list - ${completedCount} of ${totalCount} completed`
    );
    this.todoHeaderEl.setAttribute("aria-expanded", String(this.isTodoExpanded));
  }
  /**
   * Scroll messages container to bottom.
   */
  scrollToBottom() {
    if (this.containerEl) {
      this.containerEl.scrollTop = this.containerEl.scrollHeight;
    }
  }
  // ============================================
  // Async Subagent Status Methods
  // ============================================
  /**
   * Add or update an async subagent in the panel.
   */
  updateSubagent(info) {
    this.currentSubagents.set(info.id, info);
    this.renderSubagentStatus();
  }
  /**
   * Remove a subagent from the panel.
   */
  removeSubagent(id) {
    this.currentSubagents.delete(id);
    this.renderSubagentStatus();
  }
  /**
   * Clear all subagents from the panel.
   */
  clearSubagents() {
    this.currentSubagents.clear();
    this.renderSubagentStatus();
  }
  /**
   * Clear completed/error/orphaned subagents from the panel.
   * Called when user sends a new query - done entries are dismissed.
   */
  clearTerminalSubagents() {
    for (const [id, info] of this.currentSubagents) {
      if (TERMINAL_STATES.includes(info.status)) {
        this.currentSubagents.delete(id);
      }
    }
    this.renderSubagentStatus();
  }
  /**
   * Check if all subagents completed successfully.
   * Used for auto-hide on response completion.
   * Returns false if empty or any subagent is pending, running, error, or orphaned.
   */
  areAllSubagentsCompleted() {
    if (this.currentSubagents.size === 0) return false;
    for (const info of this.currentSubagents.values()) {
      if (info.status !== "completed") {
        return false;
      }
    }
    return true;
  }
  /**
   * Truncate description for display.
   */
  truncateDescription(description, maxLength = 50) {
    if (description.length <= maxLength) return description;
    return description.substring(0, maxLength) + "...";
  }
  /**
   * Format running task count text.
   */
  formatRunningCount(count) {
    const taskWord = count === 1 ? "background task" : "background tasks";
    return `${count} ${taskWord}`;
  }
  /**
   * Render the subagent status section.
   * - Completed tasks: show  + description for each
   * - Running tasks: show "X background tasks" count
   */
  renderSubagentStatus() {
    if (!this.subagentContainerEl) return;
    const runningSubagents = [];
    const completedSubagents = [];
    for (const info of this.currentSubagents.values()) {
      switch (info.status) {
        case "pending":
        case "running":
          runningSubagents.push(info);
          break;
        case "completed":
          completedSubagents.push(info);
          break;
      }
    }
    if (runningSubagents.length === 0 && completedSubagents.length === 0) {
      this.subagentContainerEl.style.display = "none";
      return;
    }
    this.subagentContainerEl.style.display = "block";
    this.subagentContainerEl.empty();
    const lastDoneIndex = completedSubagents.length - 1;
    for (let i2 = 0; i2 < completedSubagents.length; i2++) {
      const subagent = completedSubagents[i2];
      const isLastDone = i2 === lastDoneIndex;
      const showRunningOnThisRow = isLastDone && runningSubagents.length > 0;
      const rowEl = document.createElement("div");
      rowEl.className = showRunningOnThisRow ? "claudian-status-panel-done-row claudian-status-panel-combined-row" : "claudian-status-panel-done-row";
      const botIconEl = document.createElement("span");
      botIconEl.className = "claudian-status-panel-icon claudian-status-panel-bot-icon";
      (0, import_obsidian19.setIcon)(botIconEl, getToolIcon(TOOL_TASK));
      rowEl.appendChild(botIconEl);
      const textEl = document.createElement("span");
      textEl.className = "claudian-status-panel-done-text";
      textEl.textContent = this.truncateDescription(subagent.description);
      rowEl.appendChild(textEl);
      const iconEl = document.createElement("span");
      iconEl.className = "claudian-status-panel-icon claudian-status-panel-done-icon";
      (0, import_obsidian19.setIcon)(iconEl, "check");
      rowEl.appendChild(iconEl);
      if (showRunningOnThisRow) {
        const runningEl = document.createElement("span");
        runningEl.className = "claudian-status-panel-running-text";
        runningEl.textContent = this.formatRunningCount(runningSubagents.length);
        rowEl.appendChild(runningEl);
      }
      this.subagentContainerEl.appendChild(rowEl);
    }
    if (runningSubagents.length > 0 && completedSubagents.length === 0) {
      const rowEl = document.createElement("div");
      rowEl.className = "claudian-status-panel-running-row";
      const textEl = document.createElement("span");
      textEl.className = "claudian-status-panel-running-text";
      textEl.textContent = this.formatRunningCount(runningSubagents.length);
      rowEl.appendChild(textEl);
      this.subagentContainerEl.appendChild(rowEl);
    }
    this.scrollToBottom();
  }
  // ============================================
  // Cleanup
  // ============================================
  /**
   * Destroy the panel.
   */
  destroy() {
    if (this.todoHeaderEl) {
      if (this.todoClickHandler) {
        this.todoHeaderEl.removeEventListener("click", this.todoClickHandler);
      }
      if (this.todoKeydownHandler) {
        this.todoHeaderEl.removeEventListener("keydown", this.todoKeydownHandler);
      }
    }
    this.todoClickHandler = null;
    this.todoKeydownHandler = null;
    this.currentSubagents.clear();
    if (this.panelEl) {
      this.panelEl.remove();
      this.panelEl = null;
    }
    this.subagentContainerEl = null;
    this.todoContainerEl = null;
    this.todoHeaderEl = null;
    this.todoContentEl = null;
    this.containerEl = null;
    this.currentTodos = null;
  }
};

// src/features/chat/tabs/types.ts
var DEFAULT_MAX_TABS = 3;
var MIN_TABS = 3;
var MAX_TABS = 10;
var TEXTAREA_MIN_MAX_HEIGHT = 150;
var TEXTAREA_MAX_HEIGHT_PERCENT = 0.55;
function generateTabId() {
  return `tab-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
}

// src/features/chat/tabs/Tab.ts
function createTab(options) {
  var _a;
  const {
    containerEl,
    conversation,
    tabId,
    onStreamingChanged,
    onAttentionChanged,
    onConversationIdChanged
  } = options;
  const id = tabId != null ? tabId : generateTabId();
  const contentEl = containerEl.createDiv({ cls: "claudian-tab-content" });
  contentEl.style.display = "none";
  const state = new ChatState({
    onStreamingStateChanged: (isStreaming) => {
      onStreamingChanged == null ? void 0 : onStreamingChanged(isStreaming);
    },
    onAttentionChanged: (needsAttention) => {
      onAttentionChanged == null ? void 0 : onAttentionChanged(needsAttention);
    },
    onConversationChanged: (conversationId) => {
      onConversationIdChanged == null ? void 0 : onConversationIdChanged(conversationId);
    }
  });
  const subagentManager = new SubagentManager(() => {
  });
  const dom = buildTabDOM(contentEl);
  const tab = {
    id,
    conversationId: (_a = conversation == null ? void 0 : conversation.id) != null ? _a : null,
    service: null,
    serviceInitialized: false,
    state,
    controllers: {
      selectionController: null,
      conversationController: null,
      streamController: null,
      inputController: null,
      navigationController: null
    },
    services: {
      subagentManager,
      instructionRefineService: null,
      titleGenerationService: null
    },
    ui: {
      fileContextManager: null,
      imageContextManager: null,
      modelSelector: null,
      thinkingBudgetSelector: null,
      externalContextSelector: null,
      mcpServerSelector: null,
      permissionToggle: null,
      slashCommandDropdown: null,
      instructionModeManager: null,
      contextUsageMeter: null,
      statusPanel: null
    },
    dom,
    renderer: null
  };
  return tab;
}
function autoResizeTextarea(textarea) {
  var _a, _b;
  textarea.style.minHeight = "";
  const viewHeight = (_b = (_a = textarea.closest(".claudian-container")) == null ? void 0 : _a.clientHeight) != null ? _b : window.innerHeight;
  const maxHeight = Math.max(TEXTAREA_MIN_MAX_HEIGHT, viewHeight * TEXTAREA_MAX_HEIGHT_PERCENT);
  const flexAllocatedHeight = textarea.offsetHeight;
  const contentHeight = Math.min(textarea.scrollHeight, maxHeight);
  if (contentHeight > flexAllocatedHeight) {
    textarea.style.minHeight = `${contentHeight}px`;
  }
  textarea.style.maxHeight = `${maxHeight}px`;
}
function buildTabDOM(contentEl) {
  const messagesWrapperEl = contentEl.createDiv({ cls: "claudian-messages-wrapper" });
  const messagesEl = messagesWrapperEl.createDiv({ cls: "claudian-messages" });
  const welcomeEl = messagesEl.createDiv({ cls: "claudian-welcome" });
  const scrollToBottomEl = messagesWrapperEl.createEl("button", {
    cls: "claudian-scroll-to-bottom",
    attr: {
      "aria-label": "Scroll to bottom",
      type: "button"
    }
  });
  scrollToBottomEl.textContent = "Scroll to bottom";
  const statusPanelContainerEl = contentEl.createDiv({ cls: "claudian-status-panel-container" });
  const inputContainerEl = contentEl.createDiv({ cls: "claudian-input-container" });
  const navRowEl = inputContainerEl.createDiv({ cls: "claudian-input-nav-row" });
  const inputWrapper = inputContainerEl.createDiv({ cls: "claudian-input-wrapper" });
  const contextRowEl = inputWrapper.createDiv({ cls: "claudian-context-row" });
  const inputEl = inputWrapper.createEl("textarea", {
    cls: "claudian-input",
    attr: {
      placeholder: "How can I help you today?",
      rows: "3"
    }
  });
  return {
    contentEl,
    messagesEl,
    welcomeEl,
    statusPanelContainerEl,
    inputContainerEl,
    inputWrapper,
    inputEl,
    navRowEl,
    contextRowEl,
    selectionIndicatorEl: null,
    scrollToBottomEl,
    eventCleanups: []
  };
}
async function initializeTabService(tab, plugin, mcpManager) {
  var _a;
  if (tab.serviceInitialized) {
    return;
  }
  let service = null;
  try {
    service = new ClaudianService(plugin, mcpManager);
    try {
      await service.loadCCPermissions();
    } catch (e2) {
    }
    let sessionId;
    let externalContextPaths = plugin.settings.persistentExternalContextPaths || [];
    if (tab.conversationId) {
      const conversation = await plugin.getConversationById(tab.conversationId);
      sessionId = (_a = conversation == null ? void 0 : conversation.sessionId) != null ? _a : void 0;
      if (conversation) {
        const hasMessages = conversation.messages.length > 0;
        externalContextPaths = hasMessages ? conversation.externalContextPaths || [] : plugin.settings.persistentExternalContextPaths || [];
      }
    }
    service.ensureReady({
      sessionId,
      externalContextPaths
    }).catch(() => {
    });
    tab.service = service;
    tab.serviceInitialized = true;
  } catch (error) {
    service == null ? void 0 : service.closePersistentQuery("initialization failed");
    tab.service = null;
    tab.serviceInitialized = false;
    throw error;
  }
}
function initializeContextManagers(tab, plugin) {
  const { dom } = tab;
  const app = plugin.app;
  tab.ui.fileContextManager = new FileContextManager(
    app,
    dom.contextRowEl,
    dom.inputEl,
    {
      getExcludedTags: () => plugin.settings.excludedTags,
      onChipsChanged: () => {
        var _a, _b;
        (_a = tab.controllers.selectionController) == null ? void 0 : _a.updateContextRowVisibility();
        autoResizeTextarea(dom.inputEl);
        (_b = tab.renderer) == null ? void 0 : _b.scrollToBottomIfNeeded();
      },
      getExternalContexts: () => {
        var _a;
        return ((_a = tab.ui.externalContextSelector) == null ? void 0 : _a.getExternalContexts()) || [];
      }
    },
    dom.inputContainerEl
  );
  tab.ui.fileContextManager.setMcpService(plugin.mcpService);
  tab.ui.fileContextManager.setAgentService(plugin.agentManager);
  tab.ui.imageContextManager = new ImageContextManager(
    dom.inputContainerEl,
    dom.inputEl,
    {
      onImagesChanged: () => {
        var _a, _b;
        (_a = tab.controllers.selectionController) == null ? void 0 : _a.updateContextRowVisibility();
        autoResizeTextarea(dom.inputEl);
        (_b = tab.renderer) == null ? void 0 : _b.scrollToBottomIfNeeded();
      }
    },
    dom.contextRowEl
  );
}
function initializeSlashCommands(tab, getSdkCommands, getHiddenCommands) {
  var _a;
  const { dom } = tab;
  tab.ui.slashCommandDropdown = new SlashCommandDropdown(
    dom.inputContainerEl,
    dom.inputEl,
    {
      onSelect: () => {
      },
      onHide: () => {
      },
      getSdkCommands
    },
    {
      hiddenCommands: (_a = getHiddenCommands == null ? void 0 : getHiddenCommands()) != null ? _a : /* @__PURE__ */ new Set()
    }
  );
}
function initializeInstructionAndTodo(tab, plugin) {
  const { dom } = tab;
  tab.services.instructionRefineService = new InstructionRefineService(plugin);
  tab.services.titleGenerationService = new TitleGenerationService(plugin);
  tab.ui.instructionModeManager = new InstructionModeManager(
    dom.inputEl,
    {
      onSubmit: async (rawInstruction) => {
        var _a;
        await ((_a = tab.controllers.inputController) == null ? void 0 : _a.handleInstructionSubmit(rawInstruction));
      },
      getInputWrapper: () => dom.inputWrapper
    }
  );
  tab.ui.statusPanel = new StatusPanel();
  tab.ui.statusPanel.mount(dom.statusPanelContainerEl);
}
function initializeInputToolbar(tab, plugin) {
  var _a;
  const { dom } = tab;
  const inputToolbar = dom.inputWrapper.createDiv({ cls: "claudian-input-toolbar" });
  const toolbarComponents = createInputToolbar(inputToolbar, {
    getSettings: () => ({
      model: plugin.settings.model,
      thinkingBudget: plugin.settings.thinkingBudget,
      permissionMode: plugin.settings.permissionMode,
      show1MModel: plugin.settings.show1MModel
    }),
    getEnvironmentVariables: () => plugin.getActiveEnvironmentVariables(),
    onModelChange: async (model) => {
      var _a2, _b, _c;
      plugin.settings.model = model;
      const isDefaultModel = DEFAULT_CLAUDE_MODELS.find((m) => m.value === model);
      if (isDefaultModel) {
        plugin.settings.thinkingBudget = DEFAULT_THINKING_BUDGET[model];
        plugin.settings.lastClaudeModel = model;
      } else {
        plugin.settings.lastCustomModel = model;
      }
      await plugin.saveSettings();
      (_a2 = tab.ui.thinkingBudgetSelector) == null ? void 0 : _a2.updateDisplay();
      (_b = tab.ui.modelSelector) == null ? void 0 : _b.updateDisplay();
      (_c = tab.ui.modelSelector) == null ? void 0 : _c.renderOptions();
      const currentUsage = tab.state.usage;
      if (currentUsage) {
        const newContextWindow = getContextWindowSize(model, plugin.settings.show1MModel, plugin.settings.customContextLimits);
        const newPercentage = Math.min(100, Math.max(0, Math.round(currentUsage.contextTokens / newContextWindow * 100)));
        tab.state.usage = {
          ...currentUsage,
          model,
          contextWindow: newContextWindow,
          percentage: newPercentage
        };
      }
    },
    onThinkingBudgetChange: async (budget) => {
      plugin.settings.thinkingBudget = budget;
      await plugin.saveSettings();
    },
    onPermissionModeChange: async (mode) => {
      plugin.settings.permissionMode = mode;
      await plugin.saveSettings();
    }
  });
  tab.ui.modelSelector = toolbarComponents.modelSelector;
  tab.ui.thinkingBudgetSelector = toolbarComponents.thinkingBudgetSelector;
  tab.ui.contextUsageMeter = toolbarComponents.contextUsageMeter;
  tab.ui.externalContextSelector = toolbarComponents.externalContextSelector;
  tab.ui.mcpServerSelector = toolbarComponents.mcpServerSelector;
  tab.ui.permissionToggle = toolbarComponents.permissionToggle;
  tab.ui.mcpServerSelector.setMcpService(plugin.mcpService);
  (_a = tab.ui.fileContextManager) == null ? void 0 : _a.setOnMcpMentionChange((servers) => {
    var _a2;
    (_a2 = tab.ui.mcpServerSelector) == null ? void 0 : _a2.addMentionedServers(servers);
  });
  tab.ui.externalContextSelector.setOnChange(() => {
    var _a2;
    (_a2 = tab.ui.fileContextManager) == null ? void 0 : _a2.preScanExternalContexts();
  });
  tab.ui.externalContextSelector.setPersistentPaths(
    plugin.settings.persistentExternalContextPaths || []
  );
  tab.ui.externalContextSelector.setOnPersistenceChange(async (paths) => {
    plugin.settings.persistentExternalContextPaths = paths;
    await plugin.saveSettings();
  });
}
function initializeTabUI(tab, plugin, options = {}) {
  const { dom, state } = tab;
  initializeContextManagers(tab, plugin);
  dom.selectionIndicatorEl = dom.contextRowEl.createDiv({ cls: "claudian-selection-indicator" });
  dom.selectionIndicatorEl.style.display = "none";
  initializeSlashCommands(
    tab,
    options.getSdkCommands,
    () => new Set((plugin.settings.hiddenSlashCommands || []).map((c3) => c3.toLowerCase()))
  );
  initializeInstructionAndTodo(tab, plugin);
  initializeInputToolbar(tab, plugin);
  const updateScrollToBottomVisibility = () => {
    if (dom.scrollToBottomEl) {
      const hasOverflow = dom.messagesEl.scrollHeight > dom.messagesEl.clientHeight;
      const shouldShow = !state.autoScrollEnabled && hasOverflow;
      dom.scrollToBottomEl.classList.toggle("visible", shouldShow);
    }
  };
  dom.updateScrollVisibility = updateScrollToBottomVisibility;
  state.callbacks = {
    ...state.callbacks,
    onUsageChanged: (usage) => {
      var _a;
      return (_a = tab.ui.contextUsageMeter) == null ? void 0 : _a.update(usage);
    },
    onTodosChanged: (todos) => {
      var _a;
      return (_a = tab.ui.statusPanel) == null ? void 0 : _a.updateTodos(todos);
    },
    onAutoScrollChanged: () => updateScrollToBottomVisibility()
  };
  const resizeObserver = new ResizeObserver(() => {
    updateScrollToBottomVisibility();
  });
  resizeObserver.observe(dom.messagesEl);
  dom.eventCleanups.push(() => resizeObserver.disconnect());
  updateScrollToBottomVisibility();
}
function initializeTabControllers(tab, plugin, component, mcpManager) {
  const { dom, state, services, ui } = tab;
  tab.renderer = new MessageRenderer(plugin, component, dom.messagesEl);
  tab.controllers.selectionController = new SelectionController(
    plugin.app,
    dom.selectionIndicatorEl,
    dom.inputEl,
    dom.contextRowEl,
    () => autoResizeTextarea(dom.inputEl)
  );
  tab.controllers.streamController = new StreamController({
    plugin,
    state,
    renderer: tab.renderer,
    subagentManager: services.subagentManager,
    getMessagesEl: () => dom.messagesEl,
    getFileContextManager: () => ui.fileContextManager,
    updateQueueIndicator: () => {
      var _a;
      return (_a = tab.controllers.inputController) == null ? void 0 : _a.updateQueueIndicator();
    },
    getAgentService: () => tab.service
  });
  services.subagentManager.setCallback(
    (subagent) => {
      var _a;
      (_a = tab.controllers.streamController) == null ? void 0 : _a.onAsyncSubagentStateChange(subagent);
      if (subagent.mode === "async" && ui.statusPanel) {
        ui.statusPanel.updateSubagent({
          id: subagent.id,
          description: subagent.description,
          status: subagent.asyncStatus === "completed" ? "completed" : subagent.asyncStatus === "error" ? "error" : subagent.asyncStatus === "orphaned" ? "orphaned" : subagent.asyncStatus === "running" ? "running" : "pending",
          prompt: subagent.prompt,
          result: subagent.result
        });
      }
    }
  );
  tab.controllers.conversationController = new ConversationController(
    {
      plugin,
      state,
      renderer: tab.renderer,
      subagentManager: services.subagentManager,
      getHistoryDropdown: () => null,
      // Tab doesn't have its own history dropdown
      getWelcomeEl: () => dom.welcomeEl,
      setWelcomeEl: (el) => {
        dom.welcomeEl = el;
      },
      getMessagesEl: () => dom.messagesEl,
      getInputEl: () => dom.inputEl,
      getFileContextManager: () => ui.fileContextManager,
      getImageContextManager: () => ui.imageContextManager,
      getMcpServerSelector: () => ui.mcpServerSelector,
      getExternalContextSelector: () => ui.externalContextSelector,
      clearQueuedMessage: () => {
        var _a;
        return (_a = tab.controllers.inputController) == null ? void 0 : _a.clearQueuedMessage();
      },
      getTitleGenerationService: () => services.titleGenerationService,
      getStatusPanel: () => ui.statusPanel,
      getAgentService: () => tab.service
      // Use tab's service instead of plugin's
    },
    {}
  );
  const generateId = () => `msg-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
  tab.controllers.inputController = new InputController({
    plugin,
    state,
    renderer: tab.renderer,
    streamController: tab.controllers.streamController,
    selectionController: tab.controllers.selectionController,
    conversationController: tab.controllers.conversationController,
    getInputEl: () => dom.inputEl,
    getWelcomeEl: () => dom.welcomeEl,
    getMessagesEl: () => dom.messagesEl,
    getFileContextManager: () => ui.fileContextManager,
    getImageContextManager: () => ui.imageContextManager,
    getMcpServerSelector: () => ui.mcpServerSelector,
    getExternalContextSelector: () => ui.externalContextSelector,
    getInstructionModeManager: () => ui.instructionModeManager,
    getInstructionRefineService: () => services.instructionRefineService,
    getTitleGenerationService: () => services.titleGenerationService,
    getStatusPanel: () => ui.statusPanel,
    generateId,
    resetInputHeight: () => {
    },
    // Override to use tab's service instead of plugin.agentService
    getAgentService: () => tab.service,
    getSubagentManager: () => services.subagentManager,
    // Lazy initialization: ensure service is ready before first query
    // initializeTabService() handles session ID resolution from tab.conversationId
    ensureServiceInitialized: async () => {
      if (tab.serviceInitialized) {
        return true;
      }
      try {
        await initializeTabService(tab, plugin, mcpManager);
        setupApprovalCallback(tab);
        return true;
      } catch (e2) {
        return false;
      }
    }
  });
  tab.controllers.navigationController = new NavigationController({
    getMessagesEl: () => dom.messagesEl,
    getInputEl: () => dom.inputEl,
    getSettings: () => plugin.settings.keyboardNavigation,
    isStreaming: () => state.isStreaming,
    shouldSkipEscapeHandling: () => {
      var _a, _b, _c;
      if ((_a = ui.instructionModeManager) == null ? void 0 : _a.isActive()) return true;
      if ((_b = ui.slashCommandDropdown) == null ? void 0 : _b.isVisible()) return true;
      if ((_c = ui.fileContextManager) == null ? void 0 : _c.isMentionDropdownVisible()) return true;
      return false;
    }
  });
  tab.controllers.navigationController.initialize();
}
function wireTabInputEvents(tab, plugin) {
  const { dom, ui, state, controllers } = tab;
  const keydownHandler = (e2) => {
    var _a, _b, _c, _d, _e, _f;
    if ((_a = ui.instructionModeManager) == null ? void 0 : _a.handleTriggerKey(e2)) {
      return;
    }
    if ((_b = ui.instructionModeManager) == null ? void 0 : _b.handleKeydown(e2)) {
      return;
    }
    if ((_c = ui.slashCommandDropdown) == null ? void 0 : _c.handleKeydown(e2)) {
      return;
    }
    if ((_d = ui.fileContextManager) == null ? void 0 : _d.handleMentionKeydown(e2)) {
      return;
    }
    if (e2.key === "Escape" && !e2.isComposing && state.isStreaming) {
      e2.preventDefault();
      (_e = controllers.inputController) == null ? void 0 : _e.cancelStreaming();
      return;
    }
    if (e2.key === "Enter" && !e2.shiftKey && !e2.isComposing) {
      e2.preventDefault();
      void ((_f = controllers.inputController) == null ? void 0 : _f.sendMessage());
    }
  };
  dom.inputEl.addEventListener("keydown", keydownHandler);
  dom.eventCleanups.push(() => dom.inputEl.removeEventListener("keydown", keydownHandler));
  const inputHandler = () => {
    var _a, _b;
    (_a = ui.fileContextManager) == null ? void 0 : _a.handleInputChange();
    (_b = ui.instructionModeManager) == null ? void 0 : _b.handleInputChange();
    autoResizeTextarea(dom.inputEl);
  };
  dom.inputEl.addEventListener("input", inputHandler);
  dom.eventCleanups.push(() => dom.inputEl.removeEventListener("input", inputHandler));
  const focusHandler = () => {
    var _a;
    (_a = controllers.selectionController) == null ? void 0 : _a.showHighlight();
  };
  dom.inputEl.addEventListener("focus", focusHandler);
  dom.eventCleanups.push(() => dom.inputEl.removeEventListener("focus", focusHandler));
  const SCROLL_THRESHOLD = 20;
  const RE_ENABLE_DELAY = 150;
  let reEnableTimeout = null;
  const isAutoScrollAllowed = () => {
    var _a;
    return (_a = plugin.settings.enableAutoScroll) != null ? _a : true;
  };
  const scrollHandler = () => {
    if (!isAutoScrollAllowed()) {
      if (reEnableTimeout) {
        clearTimeout(reEnableTimeout);
        reEnableTimeout = null;
      }
      state.autoScrollEnabled = false;
      return;
    }
    const { scrollTop, scrollHeight, clientHeight } = dom.messagesEl;
    const isAtBottom = scrollHeight - scrollTop - clientHeight <= SCROLL_THRESHOLD;
    if (!isAtBottom) {
      if (reEnableTimeout) {
        clearTimeout(reEnableTimeout);
        reEnableTimeout = null;
      }
      state.autoScrollEnabled = false;
    } else if (!state.autoScrollEnabled) {
      if (!reEnableTimeout) {
        reEnableTimeout = setTimeout(() => {
          reEnableTimeout = null;
          const { scrollTop: scrollTop2, scrollHeight: scrollHeight2, clientHeight: clientHeight2 } = dom.messagesEl;
          if (scrollHeight2 - scrollTop2 - clientHeight2 <= SCROLL_THRESHOLD) {
            state.autoScrollEnabled = true;
          }
        }, RE_ENABLE_DELAY);
      }
    }
  };
  dom.messagesEl.addEventListener("scroll", scrollHandler, { passive: true });
  dom.eventCleanups.push(() => {
    dom.messagesEl.removeEventListener("scroll", scrollHandler);
    if (reEnableTimeout) clearTimeout(reEnableTimeout);
  });
  if (dom.scrollToBottomEl) {
    const scrollToBottomHandler = () => {
      dom.messagesEl.scrollTop = dom.messagesEl.scrollHeight;
      if (isAutoScrollAllowed()) {
        state.autoScrollEnabled = true;
      }
    };
    dom.scrollToBottomEl.addEventListener("click", scrollToBottomHandler);
    dom.eventCleanups.push(() => {
      var _a;
      return (_a = dom.scrollToBottomEl) == null ? void 0 : _a.removeEventListener("click", scrollToBottomHandler);
    });
  }
}
function activateTab(tab) {
  var _a, _b, _c;
  tab.dom.contentEl.style.display = "flex";
  (_a = tab.controllers.selectionController) == null ? void 0 : _a.start();
  (_c = (_b = tab.dom).updateScrollVisibility) == null ? void 0 : _c.call(_b);
}
function deactivateTab(tab) {
  var _a;
  tab.dom.contentEl.style.display = "none";
  (_a = tab.controllers.selectionController) == null ? void 0 : _a.stop();
}
async function destroyTab(tab) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  (_a = tab.controllers.selectionController) == null ? void 0 : _a.stop();
  (_b = tab.controllers.selectionController) == null ? void 0 : _b.clear();
  (_c = tab.controllers.navigationController) == null ? void 0 : _c.dispose();
  cleanupThinkingBlock(tab.state.currentThinkingState);
  tab.state.currentThinkingState = null;
  (_d = tab.ui.fileContextManager) == null ? void 0 : _d.destroy();
  (_e = tab.ui.slashCommandDropdown) == null ? void 0 : _e.destroy();
  tab.ui.slashCommandDropdown = null;
  (_f = tab.ui.instructionModeManager) == null ? void 0 : _f.destroy();
  tab.ui.instructionModeManager = null;
  (_g = tab.services.instructionRefineService) == null ? void 0 : _g.cancel();
  tab.services.instructionRefineService = null;
  (_h = tab.services.titleGenerationService) == null ? void 0 : _h.cancel();
  tab.services.titleGenerationService = null;
  (_i = tab.ui.statusPanel) == null ? void 0 : _i.destroy();
  tab.ui.statusPanel = null;
  tab.services.subagentManager.orphanAllActive();
  tab.services.subagentManager.clear();
  for (const cleanup of tab.dom.eventCleanups) {
    cleanup();
  }
  tab.dom.eventCleanups.length = 0;
  (_j = tab.service) == null ? void 0 : _j.closePersistentQuery("tab closed");
  tab.service = null;
  tab.dom.contentEl.remove();
}
function getTabTitle(tab, plugin) {
  if (tab.conversationId) {
    const conversation = plugin.getConversationSync(tab.conversationId);
    if (conversation == null ? void 0 : conversation.title) {
      return conversation.title;
    }
  }
  return "New Chat";
}
function setupApprovalCallback(tab) {
  if (tab.service && tab.controllers.inputController) {
    tab.service.setApprovalCallback(
      (toolName, input, description) => tab.controllers.inputController.handleApprovalRequest(toolName, input, description)
    );
  }
}

// src/features/chat/tabs/TabBar.ts
var TabBar = class {
  constructor(containerEl, callbacks) {
    this.containerEl = containerEl;
    this.callbacks = callbacks;
    this.build();
  }
  /** Builds the tab bar UI. */
  build() {
    this.containerEl.addClass("claudian-tab-badges");
  }
  /**
   * Updates the tab bar with new tab data.
   * @param items Tab items to render.
   */
  update(items) {
    this.containerEl.empty();
    for (const item of items) {
      this.renderBadge(item);
    }
  }
  /** Renders a single tab badge. */
  renderBadge(item) {
    let stateClass = "claudian-tab-badge-idle";
    if (item.isActive) {
      stateClass = "claudian-tab-badge-active";
    } else if (item.needsAttention) {
      stateClass = "claudian-tab-badge-attention";
    } else if (item.isStreaming) {
      stateClass = "claudian-tab-badge-streaming";
    }
    const badgeEl = this.containerEl.createDiv({
      cls: `claudian-tab-badge ${stateClass}`,
      text: String(item.index)
    });
    badgeEl.setAttribute("aria-label", item.title);
    badgeEl.setAttribute("title", item.title);
    badgeEl.addEventListener("click", () => {
      this.callbacks.onTabClick(item.id);
    });
    if (item.canClose) {
      badgeEl.addEventListener("contextmenu", (e2) => {
        e2.preventDefault();
        this.callbacks.onTabClose(item.id);
      });
    }
  }
  /** Destroys the tab bar. */
  destroy() {
    this.containerEl.empty();
    this.containerEl.removeClass("claudian-tab-badges");
  }
};

// src/features/chat/tabs/TabManager.ts
var TabManager = class {
  constructor(plugin, mcpManager, containerEl, view, callbacks = {}) {
    this.tabs = /* @__PURE__ */ new Map();
    this.activeTabId = null;
    /** Guard to prevent concurrent tab switches. */
    this.isSwitchingTab = false;
    this.plugin = plugin;
    this.mcpManager = mcpManager;
    this.containerEl = containerEl;
    this.view = view;
    this.callbacks = callbacks;
  }
  /**
   * Gets the current max tabs limit from settings.
   * Clamps to MIN_TABS and MAX_TABS bounds.
   */
  getMaxTabs() {
    var _a;
    const settingsValue = (_a = this.plugin.settings.maxTabs) != null ? _a : DEFAULT_MAX_TABS;
    return Math.max(MIN_TABS, Math.min(MAX_TABS, settingsValue));
  }
  // ============================================
  // Tab Lifecycle
  // ============================================
  /**
   * Creates a new tab.
   * @param conversationId Optional conversation to load into the tab.
   * @param tabId Optional tab ID (for restoration).
   * @returns The created tab, or null if max tabs reached.
   */
  async createTab(conversationId, tabId) {
    var _a, _b;
    const maxTabs = this.getMaxTabs();
    if (this.tabs.size >= maxTabs) {
      return null;
    }
    const conversation = conversationId ? await this.plugin.getConversationById(conversationId) : void 0;
    const tab = createTab({
      plugin: this.plugin,
      mcpManager: this.mcpManager,
      containerEl: this.containerEl,
      conversation: conversation != null ? conversation : void 0,
      tabId,
      onStreamingChanged: (isStreaming) => {
        var _a2, _b2;
        (_b2 = (_a2 = this.callbacks).onTabStreamingChanged) == null ? void 0 : _b2.call(_a2, tab.id, isStreaming);
      },
      onTitleChanged: (title) => {
        var _a2, _b2;
        (_b2 = (_a2 = this.callbacks).onTabTitleChanged) == null ? void 0 : _b2.call(_a2, tab.id, title);
      },
      onAttentionChanged: (needsAttention) => {
        var _a2, _b2;
        (_b2 = (_a2 = this.callbacks).onTabAttentionChanged) == null ? void 0 : _b2.call(_a2, tab.id, needsAttention);
      },
      onConversationIdChanged: (conversationId2) => {
        var _a2, _b2;
        tab.conversationId = conversationId2;
        (_b2 = (_a2 = this.callbacks).onTabConversationChanged) == null ? void 0 : _b2.call(_a2, tab.id, conversationId2);
      }
    });
    initializeTabUI(tab, this.plugin, {
      getSdkCommands: () => this.getSdkCommands()
    });
    initializeTabControllers(tab, this.plugin, this.view, this.mcpManager);
    wireTabInputEvents(tab, this.plugin);
    this.tabs.set(tab.id, tab);
    (_b = (_a = this.callbacks).onTabCreated) == null ? void 0 : _b.call(_a, tab);
    await this.switchToTab(tab.id);
    return tab;
  }
  /**
   * Switches to a different tab.
   * @param tabId The tab to switch to.
   */
  async switchToTab(tabId) {
    var _a, _b, _c, _d, _e;
    const tab = this.tabs.get(tabId);
    if (!tab) {
      return;
    }
    if (this.isSwitchingTab) {
      return;
    }
    this.isSwitchingTab = true;
    const previousTabId = this.activeTabId;
    try {
      if (previousTabId && previousTabId !== tabId) {
        const currentTab = this.tabs.get(previousTabId);
        if (currentTab) {
          deactivateTab(currentTab);
        }
      }
      this.activeTabId = tabId;
      activateTab(tab);
      if (tab.conversationId && tab.state.messages.length === 0) {
        await ((_a = tab.controllers.conversationController) == null ? void 0 : _a.switchTo(tab.conversationId));
      } else if (tab.conversationId && tab.state.messages.length > 0 && tab.service) {
        const conversation = await this.plugin.getConversationById(tab.conversationId);
        if (conversation) {
          const hasMessages = conversation.messages.length > 0;
          const externalContextPaths = hasMessages ? conversation.externalContextPaths || [] : this.plugin.settings.persistentExternalContextPaths || [];
          tab.service.setSessionId((_b = conversation.sessionId) != null ? _b : null, externalContextPaths);
        }
      } else if (!tab.conversationId && tab.state.messages.length === 0) {
        (_c = tab.controllers.conversationController) == null ? void 0 : _c.initializeWelcome();
      }
      (_e = (_d = this.callbacks).onTabSwitched) == null ? void 0 : _e.call(_d, previousTabId, tabId);
    } finally {
      this.isSwitchingTab = false;
    }
  }
  /**
   * Closes a tab.
   * @param tabId The tab to close.
   * @param force If true, close even if streaming.
   * @returns True if the tab was closed.
   */
  async closeTab(tabId, force = false) {
    var _a, _b, _c;
    const tab = this.tabs.get(tabId);
    if (!tab) {
      return false;
    }
    if (tab.state.isStreaming && !force) {
      return false;
    }
    if (this.tabs.size === 1 && !tab.conversationId && tab.state.messages.length === 0) {
      return false;
    }
    await ((_a = tab.controllers.conversationController) == null ? void 0 : _a.save());
    const tabIdsBefore = Array.from(this.tabs.keys());
    const closingIndex = tabIdsBefore.indexOf(tabId);
    await destroyTab(tab);
    this.tabs.delete(tabId);
    (_c = (_b = this.callbacks).onTabClosed) == null ? void 0 : _c.call(_b, tabId);
    if (this.activeTabId === tabId) {
      this.activeTabId = null;
      if (this.tabs.size > 0) {
        const fallbackTabId = closingIndex === 0 ? tabIdsBefore[1] : tabIdsBefore[closingIndex - 1];
        if (fallbackTabId && this.tabs.has(fallbackTabId)) {
          await this.switchToTab(fallbackTabId);
          if (this.tabs.size === 1) {
            await this.initializeActiveTabService();
          }
        }
      } else {
        await this.createTab();
        await this.initializeActiveTabService();
      }
    }
    return true;
  }
  // ============================================
  // Tab Queries
  // ============================================
  /** Gets the currently active tab. */
  getActiveTab() {
    var _a;
    return this.activeTabId ? (_a = this.tabs.get(this.activeTabId)) != null ? _a : null : null;
  }
  /** Gets the active tab ID. */
  getActiveTabId() {
    return this.activeTabId;
  }
  /** Gets a tab by ID. */
  getTab(tabId) {
    var _a;
    return (_a = this.tabs.get(tabId)) != null ? _a : null;
  }
  /** Gets all tabs. */
  getAllTabs() {
    return Array.from(this.tabs.values());
  }
  /** Gets the number of tabs. */
  getTabCount() {
    return this.tabs.size;
  }
  /** Checks if more tabs can be created. */
  canCreateTab() {
    return this.tabs.size < this.getMaxTabs();
  }
  // ============================================
  // Tab Bar Data
  // ============================================
  /** Gets data for rendering the tab bar. */
  getTabBarItems() {
    const items = [];
    let index = 1;
    for (const tab of this.tabs.values()) {
      items.push({
        id: tab.id,
        index: index++,
        title: getTabTitle(tab, this.plugin),
        isActive: tab.id === this.activeTabId,
        isStreaming: tab.state.isStreaming,
        needsAttention: tab.state.needsAttention,
        canClose: this.tabs.size > 1 || !tab.state.isStreaming
      });
    }
    return items;
  }
  // ============================================
  // Conversation Management
  // ============================================
  /**
   * Opens a conversation in a new tab or existing tab.
   * @param conversationId The conversation to open.
   * @param preferNewTab If true, prefer opening in a new tab.
   */
  async openConversation(conversationId, preferNewTab = false) {
    var _a, _b;
    for (const tab of this.tabs.values()) {
      if (tab.conversationId === conversationId) {
        await this.switchToTab(tab.id);
        return;
      }
    }
    const crossViewResult = this.plugin.findConversationAcrossViews(conversationId);
    const isSameView = (crossViewResult == null ? void 0 : crossViewResult.view) === this.view;
    if (crossViewResult && !isSameView) {
      this.plugin.app.workspace.revealLeaf(crossViewResult.view.leaf);
      await ((_a = crossViewResult.view.getTabManager()) == null ? void 0 : _a.switchToTab(crossViewResult.tabId));
      return;
    }
    if (preferNewTab && this.canCreateTab()) {
      await this.createTab(conversationId);
    } else {
      const activeTab = this.getActiveTab();
      if (activeTab) {
        await ((_b = activeTab.controllers.conversationController) == null ? void 0 : _b.switchTo(conversationId));
      }
    }
  }
  /**
   * Creates a new conversation in the active tab.
   */
  async createNewConversation() {
    var _a;
    const activeTab = this.getActiveTab();
    if (activeTab) {
      await ((_a = activeTab.controllers.conversationController) == null ? void 0 : _a.createNew());
      activeTab.conversationId = activeTab.state.currentConversationId;
    }
  }
  // ============================================
  // Persistence
  // ============================================
  /** Gets the state to persist. */
  getPersistedState() {
    const openTabs = [];
    for (const tab of this.tabs.values()) {
      openTabs.push({
        tabId: tab.id,
        conversationId: tab.conversationId
      });
    }
    return {
      openTabs,
      activeTabId: this.activeTabId
    };
  }
  /** Restores state from persisted data. */
  async restoreState(state) {
    for (const tabState of state.openTabs) {
      try {
        await this.createTab(tabState.conversationId, tabState.tabId);
      } catch (e2) {
      }
    }
    if (state.activeTabId && this.tabs.has(state.activeTabId)) {
      try {
        await this.switchToTab(state.activeTabId);
      } catch (e2) {
      }
    }
    if (this.tabs.size === 0) {
      await this.createTab();
    }
    await this.initializeActiveTabService();
  }
  /**
   * Initializes the active tab's service if not already done.
   * Called after restore to ensure the visible tab is ready immediately.
   */
  async initializeActiveTabService() {
    const activeTab = this.getActiveTab();
    if (!activeTab || activeTab.serviceInitialized) {
      return;
    }
    try {
      await initializeTabService(activeTab, this.plugin, this.mcpManager);
      setupApprovalCallback(activeTab);
    } catch (e2) {
    }
  }
  // ============================================
  // SDK Commands (Shared)
  // ============================================
  /**
   * Gets SDK supported commands from any ready service.
   * The command list is the same for all tabs, so we just need one ready service.
   * @returns Array of SDK commands, or empty array if no service is ready.
   */
  async getSdkCommands() {
    var _a;
    for (const tab of this.tabs.values()) {
      if ((_a = tab.service) == null ? void 0 : _a.isReady()) {
        return tab.service.getSupportedCommands();
      }
    }
    return [];
  }
  // ============================================
  // Broadcast
  // ============================================
  /**
   * Broadcasts a function call to all tabs' ClaudianService instances.
   * Used by settings managers to apply configuration changes to all tabs.
   * @param fn Function to call on each service.
   */
  async broadcastToAllTabs(fn) {
    const promises = [];
    for (const tab of this.tabs.values()) {
      if (tab.service && tab.serviceInitialized) {
        promises.push(
          fn(tab.service).catch(() => {
          })
        );
      }
    }
    await Promise.all(promises);
  }
  // ============================================
  // Cleanup
  // ============================================
  /** Destroys all tabs and cleans up resources. */
  async destroy() {
    var _a;
    for (const tab of this.tabs.values()) {
      await ((_a = tab.controllers.conversationController) == null ? void 0 : _a.save());
    }
    for (const tab of this.tabs.values()) {
      await destroyTab(tab);
    }
    this.tabs.clear();
    this.activeTabId = null;
  }
};

// src/features/chat/ClaudianView.ts
var ClaudianView = class extends import_obsidian20.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    // Tab management
    this.tabManager = null;
    this.tabBar = null;
    this.tabBarContainerEl = null;
    this.tabContentEl = null;
    this.navRowContent = null;
    // DOM Elements
    this.viewContainerEl = null;
    this.headerEl = null;
    this.titleSlotEl = null;
    this.logoEl = null;
    this.titleTextEl = null;
    this.headerActionsEl = null;
    this.headerActionsContent = null;
    // Header elements
    this.historyDropdown = null;
    // Event refs for cleanup
    this.eventRefs = [];
    // Debouncing for tab bar updates
    this.pendingTabBarUpdate = null;
    // Debouncing for tab state persistence
    this.pendingPersist = null;
    this.plugin = plugin;
    const originalLoad = Object.getPrototypeOf(this).load.bind(this);
    Object.defineProperty(this, "load", {
      value: async () => {
        if (!this.containerEl) {
          this.containerEl = createDiv({ cls: "view-content" });
        }
        try {
          return await originalLoad();
        } catch (e2) {
        }
      },
      writable: false,
      configurable: false
    });
  }
  getViewType() {
    return VIEW_TYPE_CLAUDIAN;
  }
  getDisplayText() {
    return "Claudian";
  }
  getIcon() {
    return "bot";
  }
  /** Refreshes the model selector display (used after env var changes). */
  refreshModelSelector() {
    var _a, _b, _c;
    const activeTab = (_a = this.tabManager) == null ? void 0 : _a.getActiveTab();
    (_b = activeTab == null ? void 0 : activeTab.ui.modelSelector) == null ? void 0 : _b.updateDisplay();
    (_c = activeTab == null ? void 0 : activeTab.ui.modelSelector) == null ? void 0 : _c.renderOptions();
  }
  /** Updates hidden slash commands on all tabs (used after settings change). */
  updateHiddenSlashCommands() {
    var _a, _b, _c;
    const hiddenCommands = new Set(
      (this.plugin.settings.hiddenSlashCommands || []).map((c3) => c3.toLowerCase())
    );
    for (const tab of (_b = (_a = this.tabManager) == null ? void 0 : _a.getAllTabs()) != null ? _b : []) {
      (_c = tab.ui.slashCommandDropdown) == null ? void 0 : _c.setHiddenCommands(hiddenCommands);
    }
  }
  async onOpen() {
    var _a;
    if (!this.containerEl) {
      return;
    }
    let container = (_a = this.contentEl) != null ? _a : this.containerEl.children[1];
    if (!container) {
      container = this.containerEl.createDiv();
    }
    this.viewContainerEl = container;
    this.viewContainerEl.empty();
    this.viewContainerEl.addClass("claudian-container");
    const header = this.viewContainerEl.createDiv({ cls: "claudian-header" });
    this.buildHeader(header);
    this.navRowContent = this.buildNavRowContent();
    this.tabContentEl = this.viewContainerEl.createDiv({ cls: "claudian-tab-content-container" });
    this.tabManager = new TabManager(
      this.plugin,
      this.plugin.mcpService.getManager(),
      this.tabContentEl,
      this,
      {
        onTabCreated: () => {
          this.updateTabBar();
          this.updateNavRowLocation();
          this.persistTabState();
        },
        onTabSwitched: () => {
          this.updateTabBar();
          this.updateHistoryDropdown();
          this.updateNavRowLocation();
          this.persistTabState();
        },
        onTabClosed: () => {
          this.updateTabBar();
          this.persistTabState();
        },
        onTabStreamingChanged: () => this.updateTabBar(),
        onTabTitleChanged: () => this.updateTabBar(),
        onTabAttentionChanged: () => this.updateTabBar(),
        onTabConversationChanged: () => {
          this.persistTabState();
        }
      }
    );
    this.wireEventHandlers();
    await this.restoreOrCreateTabs();
    this.updateLayoutForPosition();
  }
  async onClose() {
    var _a, _b;
    if (this.pendingTabBarUpdate !== null) {
      cancelAnimationFrame(this.pendingTabBarUpdate);
      this.pendingTabBarUpdate = null;
    }
    for (const ref of this.eventRefs) {
      this.plugin.app.vault.offref(ref);
    }
    this.eventRefs = [];
    await this.persistTabStateImmediate();
    await ((_a = this.tabManager) == null ? void 0 : _a.destroy());
    this.tabManager = null;
    (_b = this.tabBar) == null ? void 0 : _b.destroy();
    this.tabBar = null;
  }
  // ============================================
  // UI Building
  // ============================================
  buildHeader(header) {
    this.headerEl = header;
    this.titleSlotEl = header.createDiv({ cls: "claudian-title-slot" });
    this.logoEl = this.titleSlotEl.createSpan({ cls: "claudian-logo" });
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("viewBox", LOGO_SVG.viewBox);
    svg.setAttribute("width", LOGO_SVG.width);
    svg.setAttribute("height", LOGO_SVG.height);
    svg.setAttribute("fill", "none");
    const path10 = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path10.setAttribute("d", LOGO_SVG.path);
    path10.setAttribute("fill", LOGO_SVG.fill);
    svg.appendChild(path10);
    this.logoEl.appendChild(svg);
    this.titleTextEl = this.titleSlotEl.createEl("h4", { text: "Claudian", cls: "claudian-title-text" });
    this.headerActionsEl = header.createDiv({ cls: "claudian-header-actions claudian-header-actions-slot" });
    this.headerActionsEl.style.display = "none";
  }
  /**
   * Builds the nav row content (tab badges + header actions).
   * This is called once and the content is moved between locations.
   */
  buildNavRowContent() {
    const fragment = document.createDocumentFragment();
    this.tabBarContainerEl = document.createElement("div");
    this.tabBarContainerEl.className = "claudian-tab-bar-container";
    this.tabBar = new TabBar(this.tabBarContainerEl, {
      onTabClick: (tabId) => this.handleTabClick(tabId),
      onTabClose: (tabId) => this.handleTabClose(tabId),
      onNewTab: () => this.handleNewTab()
    });
    fragment.appendChild(this.tabBarContainerEl);
    this.headerActionsContent = document.createElement("div");
    this.headerActionsContent.className = "claudian-header-actions";
    const newTabBtn = this.headerActionsContent.createDiv({ cls: "claudian-header-btn claudian-new-tab-btn" });
    (0, import_obsidian20.setIcon)(newTabBtn, "square-plus");
    newTabBtn.setAttribute("aria-label", "New tab");
    newTabBtn.addEventListener("click", async () => {
      await this.handleNewTab();
    });
    const newBtn = this.headerActionsContent.createDiv({ cls: "claudian-header-btn" });
    (0, import_obsidian20.setIcon)(newBtn, "square-pen");
    newBtn.setAttribute("aria-label", "New conversation");
    newBtn.addEventListener("click", async () => {
      var _a;
      await ((_a = this.tabManager) == null ? void 0 : _a.createNewConversation());
      this.updateHistoryDropdown();
    });
    const historyContainer = this.headerActionsContent.createDiv({ cls: "claudian-history-container" });
    const historyBtn = historyContainer.createDiv({ cls: "claudian-header-btn" });
    (0, import_obsidian20.setIcon)(historyBtn, "history");
    historyBtn.setAttribute("aria-label", "Chat history");
    this.historyDropdown = historyContainer.createDiv({ cls: "claudian-history-menu" });
    historyBtn.addEventListener("click", (e2) => {
      e2.stopPropagation();
      this.toggleHistoryDropdown();
    });
    fragment.appendChild(this.headerActionsContent);
    const wrapper = document.createElement("div");
    wrapper.style.display = "contents";
    wrapper.appendChild(fragment);
    return wrapper;
  }
  /**
   * Moves nav row content based on tabBarPosition setting.
   * - 'input' mode: Both tab badges and actions go to active tab's navRowEl
   * - 'header' mode: Tab badges go to title slot (after logo), actions go to header right side
   */
  updateNavRowLocation() {
    var _a;
    if (!this.tabBarContainerEl || !this.headerActionsContent) return;
    const isHeaderMode = this.plugin.settings.tabBarPosition === "header";
    if (isHeaderMode) {
      if (this.titleSlotEl) {
        this.titleSlotEl.appendChild(this.tabBarContainerEl);
      }
      if (this.headerActionsEl) {
        this.headerActionsEl.appendChild(this.headerActionsContent);
        this.headerActionsEl.style.display = "flex";
      }
    } else {
      const activeTab = (_a = this.tabManager) == null ? void 0 : _a.getActiveTab();
      if (activeTab && this.navRowContent) {
        this.navRowContent.appendChild(this.tabBarContainerEl);
        this.navRowContent.appendChild(this.headerActionsContent);
        activeTab.dom.navRowEl.appendChild(this.navRowContent);
      }
      if (this.headerActionsEl) {
        this.headerActionsEl.style.display = "none";
      }
    }
  }
  /**
   * Updates layout when tabBarPosition setting changes.
   * Called from settings when user changes the tab bar position.
   */
  updateLayoutForPosition() {
    if (!this.viewContainerEl) return;
    const isHeaderMode = this.plugin.settings.tabBarPosition === "header";
    this.viewContainerEl.toggleClass("claudian-container--header-mode", isHeaderMode);
    this.updateNavRowLocation();
    this.updateTabBarVisibility();
  }
  // ============================================
  // Tab Management
  // ============================================
  handleTabClick(tabId) {
    var _a;
    (_a = this.tabManager) == null ? void 0 : _a.switchToTab(tabId);
  }
  async handleTabClose(tabId) {
    var _a, _b, _c;
    const tab = (_a = this.tabManager) == null ? void 0 : _a.getTab(tabId);
    const force = (_b = tab == null ? void 0 : tab.state.isStreaming) != null ? _b : false;
    await ((_c = this.tabManager) == null ? void 0 : _c.closeTab(tabId, force));
    this.updateTabBarVisibility();
  }
  async handleNewTab() {
    var _a, _b;
    const tab = await ((_a = this.tabManager) == null ? void 0 : _a.createTab());
    if (!tab) {
      const maxTabs = (_b = this.plugin.settings.maxTabs) != null ? _b : 3;
      new import_obsidian20.Notice(`Maximum ${maxTabs} tabs allowed`);
      return;
    }
    this.updateTabBarVisibility();
  }
  updateTabBar() {
    if (!this.tabManager || !this.tabBar) return;
    if (this.pendingTabBarUpdate !== null) {
      cancelAnimationFrame(this.pendingTabBarUpdate);
    }
    this.pendingTabBarUpdate = requestAnimationFrame(() => {
      this.pendingTabBarUpdate = null;
      if (!this.tabManager || !this.tabBar) return;
      const items = this.tabManager.getTabBarItems();
      this.tabBar.update(items);
      this.updateTabBarVisibility();
    });
  }
  updateTabBarVisibility() {
    if (!this.tabBarContainerEl || !this.tabManager) return;
    const tabCount = this.tabManager.getTabCount();
    const showTabBar = tabCount >= 2;
    const isHeaderMode = this.plugin.settings.tabBarPosition === "header";
    this.tabBarContainerEl.style.display = showTabBar ? "flex" : "none";
    const hideBranding = showTabBar && isHeaderMode;
    if (this.logoEl) {
      this.logoEl.style.display = hideBranding ? "none" : "";
    }
    if (this.titleTextEl) {
      this.titleTextEl.style.display = hideBranding ? "none" : "";
    }
  }
  // ============================================
  // History Dropdown
  // ============================================
  toggleHistoryDropdown() {
    if (!this.historyDropdown) return;
    const isVisible = this.historyDropdown.hasClass("visible");
    if (isVisible) {
      this.historyDropdown.removeClass("visible");
    } else {
      this.updateHistoryDropdown();
      this.historyDropdown.addClass("visible");
    }
  }
  updateHistoryDropdown() {
    var _a;
    if (!this.historyDropdown) return;
    this.historyDropdown.empty();
    const activeTab = (_a = this.tabManager) == null ? void 0 : _a.getActiveTab();
    const conversationController = activeTab == null ? void 0 : activeTab.controllers.conversationController;
    if (conversationController) {
      conversationController.renderHistoryDropdown(this.historyDropdown, {
        onSelectConversation: async (conversationId) => {
          var _a2, _b, _c, _d, _e, _f;
          const existingTab = this.findTabWithConversation(conversationId);
          if (existingTab) {
            await ((_a2 = this.tabManager) == null ? void 0 : _a2.switchToTab(existingTab.id));
            (_b = this.historyDropdown) == null ? void 0 : _b.removeClass("visible");
            return;
          }
          const crossViewResult = this.plugin.findConversationAcrossViews(conversationId);
          if (crossViewResult && crossViewResult.view !== this) {
            this.plugin.app.workspace.revealLeaf(crossViewResult.view.leaf);
            await ((_c = crossViewResult.view.getTabManager()) == null ? void 0 : _c.switchToTab(crossViewResult.tabId));
            (_d = this.historyDropdown) == null ? void 0 : _d.removeClass("visible");
            return;
          }
          await ((_e = this.tabManager) == null ? void 0 : _e.openConversation(conversationId));
          (_f = this.historyDropdown) == null ? void 0 : _f.removeClass("visible");
        }
      });
    }
  }
  findTabWithConversation(conversationId) {
    var _a, _b, _c;
    const tabs = (_b = (_a = this.tabManager) == null ? void 0 : _a.getAllTabs()) != null ? _b : [];
    return (_c = tabs.find((tab) => tab.conversationId === conversationId)) != null ? _c : null;
  }
  // ============================================
  // Event Wiring
  // ============================================
  wireEventHandlers() {
    this.registerDomEvent(document, "click", () => {
      var _a;
      (_a = this.historyDropdown) == null ? void 0 : _a.removeClass("visible");
    });
    this.registerDomEvent(document, "keydown", (e2) => {
      var _a, _b;
      if (e2.key === "Escape" && !e2.isComposing) {
        const activeTab = (_a = this.tabManager) == null ? void 0 : _a.getActiveTab();
        if (activeTab == null ? void 0 : activeTab.state.isStreaming) {
          e2.preventDefault();
          (_b = activeTab.controllers.inputController) == null ? void 0 : _b.cancelStreaming();
        }
      }
    });
    const markDirty = () => {
      var _a, _b, _c;
      (_c = (_b = (_a = this.tabManager) == null ? void 0 : _a.getActiveTab()) == null ? void 0 : _b.ui.fileContextManager) == null ? void 0 : _c.markFilesCacheDirty();
    };
    this.eventRefs.push(
      this.plugin.app.vault.on("create", markDirty),
      this.plugin.app.vault.on("delete", markDirty),
      this.plugin.app.vault.on("rename", markDirty),
      this.plugin.app.vault.on("modify", markDirty)
    );
    this.registerEvent(
      this.plugin.app.workspace.on("file-open", (file) => {
        var _a, _b, _c;
        if (file) {
          (_c = (_b = (_a = this.tabManager) == null ? void 0 : _a.getActiveTab()) == null ? void 0 : _b.ui.fileContextManager) == null ? void 0 : _c.handleFileOpen(file);
        }
      })
    );
    this.registerDomEvent(document, "click", (e2) => {
      var _a;
      const activeTab = (_a = this.tabManager) == null ? void 0 : _a.getActiveTab();
      if (activeTab) {
        const fcm = activeTab.ui.fileContextManager;
        if (fcm && !fcm.containsElement(e2.target) && e2.target !== activeTab.dom.inputEl) {
          fcm.hideMentionDropdown();
        }
      }
    });
  }
  // ============================================
  // Persistence
  // ============================================
  async restoreOrCreateTabs() {
    if (!this.tabManager) return;
    const persistedState = await this.plugin.storage.getTabManagerState();
    if (persistedState && persistedState.openTabs.length > 0) {
      await this.tabManager.restoreState(persistedState);
      await this.plugin.storage.clearLegacyActiveConversationId();
      return;
    }
    const legacyActiveId = await this.plugin.storage.getLegacyActiveConversationId();
    if (legacyActiveId) {
      const conversation = await this.plugin.getConversationById(legacyActiveId);
      if (conversation) {
        await this.tabManager.createTab(conversation.id);
      } else {
        await this.tabManager.createTab();
      }
      await this.plugin.storage.clearLegacyActiveConversationId();
      return;
    }
    await this.tabManager.createTab();
    await this.plugin.storage.clearLegacyActiveConversationId();
  }
  persistTabState() {
    if (this.pendingPersist !== null) {
      clearTimeout(this.pendingPersist);
    }
    this.pendingPersist = setTimeout(() => {
      this.pendingPersist = null;
      if (!this.tabManager) return;
      const state = this.tabManager.getPersistedState();
      this.plugin.storage.setTabManagerState(state).catch(() => {
      });
    }, 300);
  }
  /** Force immediate persistence (for onClose/onunload). */
  async persistTabStateImmediate() {
    if (this.pendingPersist !== null) {
      clearTimeout(this.pendingPersist);
      this.pendingPersist = null;
    }
    if (!this.tabManager) return;
    const state = this.tabManager.getPersistedState();
    await this.plugin.storage.setTabManagerState(state);
  }
  // ============================================
  // Public API
  // ============================================
  /** Gets the currently active tab. */
  getActiveTab() {
    var _a, _b;
    return (_b = (_a = this.tabManager) == null ? void 0 : _a.getActiveTab()) != null ? _b : null;
  }
  /** Gets the tab manager. */
  getTabManager() {
    return this.tabManager;
  }
};

// src/features/inline-edit/ui/InlineEditModal.ts
var import_obsidian21 = require("obsidian");

// src/utils/inlineEdit.ts
function normalizeInsertionText(text) {
  return text.replace(/^(?:\r?\n)+|(?:\r?\n)+$/g, "");
}
function escapeHtml2(text) {
  return text.replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

// src/core/prompts/inlineEdit.ts
function getInlineEditSystemPrompt() {
  return `Today is ${getTodayDate()}.

You are **Claudian**, an expert editor and writing assistant embedded in Obsidian. You help users refine their text, answer questions, and generate content with high precision.

## Core Directives

1.  **Style Matching**: Mimic the user's tone, voice, and formatting style (indentation, bullet points, capitalization).
2.  **Context Awareness**: Always Read the full file (or significant context) to understand the broader topic before editing. Do not rely solely on the selection.
3.  **Silent Execution**: Use tools (Read, WebSearch) silently. Your final output must be ONLY the result.
4.  **No Fluff**: No pleasantries, no "Here is the text", no "I have updated...". Just the content.

## Input Format

User messages have the instruction first, followed by XML context tags:

### Selection Mode
\`\`\`
user's instruction

<editor_selection path="path/to/file.md">
selected text here
</editor_selection>
\`\`\`
Use \`<replacement>\` tags for edits.

### Cursor Mode
\`\`\`
user's instruction

<editor_cursor path="path/to/file.md">
text before|text after #inline
</editor_cursor>
\`\`\`
Or between paragraphs:
\`\`\`
user's instruction

<editor_cursor path="path/to/file.md">
Previous paragraph
| #inbetween
Next paragraph
</editor_cursor>
\`\`\`
Use \`<insertion>\` tags to insert new content at the cursor position (\`|\`).

## Tools & Path Rules

- **Tools**: Read, Grep, Glob, LS, WebSearch, WebFetch. (All read-only).
- **Paths**: Must be RELATIVE to vault root (e.g., "notes/file.md").

## Thinking Process

Before generating the final output, mentally check:
1.  **Context**: Have I read enough of the file to understand the *topic* and *structure*?
2.  **Style**: What is the user's indentation (2 vs 4 spaces, tabs)? What is their tone?
3.  **Type**: Is this **Prose** (flow, grammar, clarity) or **Code** (syntax, logic, variable names)?
    - *Prose*: Ensure smooth transitions.
    - *Code*: Preserve syntax validity; do not break surrounding brackets/indentation.

## Output Rules - CRITICAL

**ABSOLUTE RULE**: Your text output must contain ONLY the final answer, replacement, or insertion. NEVER output:
- "I'll read the file..." / "Let me check..." / "I will..."
- "I'm asked about..." / "The user wants..."
- "Based on my analysis..." / "After reading..."
- "Here's..." / "The answer is..."
- ANY announcement of what you're about to do or did

Use tools silently. Your text output = final result only.

### When Replacing Selected Text (Selection Mode)

If the user wants to MODIFY or REPLACE the selected text, wrap the replacement in <replacement> tags:

<replacement>your replacement text here</replacement>

The content inside the tags should be ONLY the replacement text - no explanation.

### When Inserting at Cursor (Cursor Mode)

If the user wants to INSERT new content at the cursor position, wrap the insertion in <insertion> tags:

<insertion>your inserted text here</insertion>

The content inside the tags should be ONLY the text to insert - no explanation.

### When Answering Questions or Providing Information

If the user is asking a QUESTION, respond WITHOUT tags. Output the answer directly.

WRONG: "I'll read the full context of this file to give you a better explanation. This is a guide about..."
CORRECT: "This is a guide about..."

### When Clarification is Needed

If the request is ambiguous, ask a clarifying question. Keep questions concise and specific.

## Examples

### Selection Mode
Input:
\`\`\`
translate to French

<editor_selection path="notes/readme.md">
Hello world
</editor_selection>
\`\`\`

CORRECT (replacement):
<replacement>Bonjour le monde</replacement>

Input:
\`\`\`
what does this do?

<editor_selection path="notes/code.md">
const x = arr.reduce((a, b) => a + b, 0);
</editor_selection>
\`\`\`

CORRECT (question - no tags):
This code sums all numbers in the array \`arr\`. It uses \`reduce\` to iterate through the array, accumulating the total starting from 0.

### Cursor Mode

Input:
\`\`\`
what animal?

<editor_cursor path="notes/draft.md">
The quick brown | jumps over the lazy dog. #inline
</editor_cursor>
\`\`\`

CORRECT (insertion):
<insertion>fox</insertion>

### Q&A
Input:
\`\`\`
add a brief description section

<editor_cursor path="notes/readme.md">
# Introduction
This is my project.
| #inbetween
## Features
</editor_cursor>
\`\`\`

CORRECT (insertion):
<insertion>
## Description

This project provides tools for managing your notes efficiently.
</insertion>

Input:
\`\`\`
translate to Spanish

<editor_selection path="notes/draft.md">
The bank was steep.
</editor_selection>
\`\`\`

CORRECT (asking for clarification):
"Bank" can mean a financial institution (banco) or a river bank (orilla). Which meaning should I use?

Then after user clarifies "river bank":
<replacement>La orilla era empinada.</replacement>`;
}

// src/features/inline-edit/InlineEditService.ts
var InlineEditService = class {
  constructor(plugin) {
    this.abortController = null;
    this.sessionId = null;
    this.plugin = plugin;
  }
  resetConversation() {
    this.sessionId = null;
  }
  async editText(request) {
    this.sessionId = null;
    const prompt = this.buildPrompt(request);
    return this.sendMessage(prompt);
  }
  async continueConversation(message, contextFiles) {
    if (!this.sessionId) {
      return { success: false, error: "No active conversation to continue" };
    }
    let prompt = message;
    if (contextFiles && contextFiles.length > 0) {
      prompt = appendContextFiles(message, contextFiles);
    }
    return this.sendMessage(prompt);
  }
  async sendMessage(prompt) {
    var _a;
    const vaultPath = getVaultPath(this.plugin.app);
    if (!vaultPath) {
      return { success: false, error: "Could not determine vault path" };
    }
    const resolvedClaudePath = this.plugin.getResolvedClaudeCliPath();
    if (!resolvedClaudePath) {
      return { success: false, error: "Claude CLI not found. Please install Claude Code CLI." };
    }
    this.abortController = new AbortController();
    const customEnv = parseEnvironmentVariables(this.plugin.getActiveEnvironmentVariables());
    const enhancedPath = getEnhancedPath(customEnv.PATH, resolvedClaudePath);
    const missingNodeError = getMissingNodeError(resolvedClaudePath, enhancedPath);
    if (missingNodeError) {
      return { success: false, error: missingNodeError };
    }
    const options = {
      cwd: vaultPath,
      systemPrompt: getInlineEditSystemPrompt(),
      model: this.plugin.settings.model,
      abortController: this.abortController,
      pathToClaudeCodeExecutable: resolvedClaudePath,
      env: {
        ...process.env,
        ...customEnv,
        PATH: enhancedPath
      },
      tools: [...READ_ONLY_TOOLS],
      permissionMode: "bypassPermissions",
      allowDangerouslySkipPermissions: true,
      settingSources: this.plugin.settings.loadUserClaudeSettings ? ["user", "project"] : ["project"],
      hooks: {
        PreToolUse: [
          this.createReadOnlyHook(),
          this.createVaultRestrictionHook(vaultPath)
        ]
      }
    };
    if (this.sessionId) {
      options.resume = this.sessionId;
    }
    const budgetSetting = this.plugin.settings.thinkingBudget;
    const budgetConfig = THINKING_BUDGETS.find((b3) => b3.value === budgetSetting);
    if (budgetConfig && budgetConfig.tokens > 0) {
      options.maxThinkingTokens = budgetConfig.tokens;
    }
    try {
      const response = u_({ prompt, options });
      let responseText = "";
      for await (const message of response) {
        if ((_a = this.abortController) == null ? void 0 : _a.signal.aborted) {
          await response.interrupt();
          return { success: false, error: "Cancelled" };
        }
        if (message.type === "system" && message.subtype === "init" && message.session_id) {
          this.sessionId = message.session_id;
        }
        const text = this.extractTextFromMessage(message);
        if (text) {
          responseText += text;
        }
      }
      return this.parseResponse(responseText);
    } catch (error) {
      const msg = error instanceof Error ? error.message : "Unknown error";
      return { success: false, error: msg };
    } finally {
      this.abortController = null;
    }
  }
  /** Parses response text for <replacement> or <insertion> tag. */
  parseResponse(responseText) {
    const replacementMatch = responseText.match(/<replacement>([\s\S]*?)<\/replacement>/);
    if (replacementMatch) {
      return { success: true, editedText: replacementMatch[1] };
    }
    const insertionMatch = responseText.match(/<insertion>([\s\S]*?)<\/insertion>/);
    if (insertionMatch) {
      return { success: true, insertedText: insertionMatch[1] };
    }
    const trimmed = responseText.trim();
    if (trimmed) {
      return { success: true, clarification: trimmed };
    }
    return { success: false, error: "Empty response" };
  }
  buildPrompt(request) {
    let prompt;
    if (request.mode === "cursor") {
      prompt = this.buildCursorPrompt(request);
    } else {
      const lineAttr = request.startLine && request.lineCount ? ` lines="${request.startLine}-${request.startLine + request.lineCount - 1}"` : "";
      prompt = [
        request.instruction,
        "",
        `<editor_selection path="${request.notePath}"${lineAttr}>`,
        request.selectedText,
        "</editor_selection>"
      ].join("\n");
    }
    if (request.contextFiles && request.contextFiles.length > 0) {
      prompt = appendContextFiles(prompt, request.contextFiles);
    }
    return prompt;
  }
  buildCursorPrompt(request) {
    const ctx = request.cursorContext;
    const lineAttr = ` line="${ctx.line + 1}"`;
    let cursorContent;
    if (ctx.isInbetween) {
      const parts = [];
      if (ctx.beforeCursor) parts.push(ctx.beforeCursor);
      parts.push("| #inbetween");
      if (ctx.afterCursor) parts.push(ctx.afterCursor);
      cursorContent = parts.join("\n");
    } else {
      cursorContent = `${ctx.beforeCursor}|${ctx.afterCursor} #inline`;
    }
    return [
      request.instruction,
      "",
      `<editor_cursor path="${request.notePath}"${lineAttr}>`,
      cursorContent,
      "</editor_cursor>"
    ].join("\n");
  }
  createReadOnlyHook() {
    return {
      hooks: [
        async (hookInput) => {
          const input = hookInput;
          const toolName = input.tool_name;
          if (isReadOnlyTool(toolName)) {
            return { continue: true };
          }
          return {
            continue: false,
            hookSpecificOutput: {
              hookEventName: "PreToolUse",
              permissionDecision: "deny",
              permissionDecisionReason: `Inline edit mode: tool "${toolName}" is not allowed (read-only)`
            }
          };
        }
      ]
    };
  }
  createVaultRestrictionHook(vaultPath) {
    const fileTools = [TOOL_READ, TOOL_GLOB, TOOL_GREP, TOOL_LS];
    return {
      hooks: [
        async (hookInput) => {
          const input = hookInput;
          const toolName = input.tool_name;
          if (!fileTools.includes(toolName)) {
            return { continue: true };
          }
          const filePath = getPathFromToolInput(toolName, input.tool_input);
          if (!filePath) {
            return {
              continue: false,
              hookSpecificOutput: {
                hookEventName: "PreToolUse",
                permissionDecision: "deny",
                permissionDecisionReason: `Access denied: Could not determine path for "${toolName}" tool.`
              }
            };
          }
          let accessType;
          try {
            accessType = getPathAccessType(filePath, void 0, void 0, vaultPath);
          } catch (e2) {
            return {
              continue: false,
              hookSpecificOutput: {
                hookEventName: "PreToolUse",
                permissionDecision: "deny",
                permissionDecisionReason: `Access denied: Failed to validate path "${filePath}".`
              }
            };
          }
          if (accessType === "vault" || accessType === "context" || accessType === "readwrite") {
            return { continue: true };
          }
          return {
            continue: false,
            hookSpecificOutput: {
              hookEventName: "PreToolUse",
              permissionDecision: "deny",
              permissionDecisionReason: `Access denied: Path "${filePath}" is outside allowed paths. Inline edit is restricted to vault and ~/.claude/ directories.`
            }
          };
        }
      ]
    };
  }
  extractTextFromMessage(message) {
    var _a, _b, _c;
    if (message.type === "assistant" && ((_a = message.message) == null ? void 0 : _a.content)) {
      for (const block of message.message.content) {
        if (block.type === "text" && block.text) {
          return block.text;
        }
      }
    }
    if (message.type === "stream_event") {
      const event = message.event;
      if ((event == null ? void 0 : event.type) === "content_block_start" && ((_b = event.content_block) == null ? void 0 : _b.type) === "text") {
        return event.content_block.text || null;
      }
      if ((event == null ? void 0 : event.type) === "content_block_delta" && ((_c = event.delta) == null ? void 0 : _c.type) === "text_delta") {
        return event.delta.text || null;
      }
    }
    return null;
  }
  cancel() {
    if (this.abortController) {
      this.abortController.abort();
    }
  }
};

// src/features/inline-edit/ui/InlineEditModal.ts
var import_state3 = require("@codemirror/state");
var import_view2 = require("@codemirror/view");
var showInlineEdit = import_state3.StateEffect.define();
var showDiff = import_state3.StateEffect.define();
var showInsertion = import_state3.StateEffect.define();
var hideInlineEdit = import_state3.StateEffect.define();
var activeController = null;
var DiffWidget = class extends import_view2.WidgetType {
  constructor(diffHtml, controller) {
    super();
    this.diffHtml = diffHtml;
    this.controller = controller;
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = "claudian-inline-diff-replace";
    span.innerHTML = this.diffHtml;
    const btns = document.createElement("span");
    btns.className = "claudian-inline-diff-buttons";
    const rejectBtn = document.createElement("button");
    rejectBtn.className = "claudian-inline-diff-btn reject";
    rejectBtn.textContent = "\u2715";
    rejectBtn.title = "Reject (Esc)";
    rejectBtn.onclick = () => this.controller.reject();
    const acceptBtn = document.createElement("button");
    acceptBtn.className = "claudian-inline-diff-btn accept";
    acceptBtn.textContent = "\u2713";
    acceptBtn.title = "Accept (Enter)";
    acceptBtn.onclick = () => this.controller.accept();
    btns.appendChild(rejectBtn);
    btns.appendChild(acceptBtn);
    span.appendChild(btns);
    return span;
  }
  eq(other) {
    return this.diffHtml === other.diffHtml;
  }
  ignoreEvent() {
    return true;
  }
};
var InputWidget = class extends import_view2.WidgetType {
  constructor(controller) {
    super();
    this.controller = controller;
  }
  toDOM() {
    return this.controller.createInputDOM();
  }
  eq() {
    return false;
  }
  ignoreEvent() {
    return true;
  }
};
var inlineEditField = import_state3.StateField.define({
  create: () => import_view2.Decoration.none,
  update: (deco, tr) => {
    var _a;
    deco = deco.map(tr.changes);
    for (const e2 of tr.effects) {
      if (e2.is(showInlineEdit)) {
        const builder = new import_state3.RangeSetBuilder();
        const isInbetween = (_a = e2.value.isInbetween) != null ? _a : false;
        builder.add(e2.value.inputPos, e2.value.inputPos, import_view2.Decoration.widget({
          widget: new InputWidget(e2.value.widget),
          block: !isInbetween,
          side: isInbetween ? 1 : -1
        }));
        deco = builder.finish();
      } else if (e2.is(showDiff)) {
        const builder = new import_state3.RangeSetBuilder();
        builder.add(e2.value.from, e2.value.to, import_view2.Decoration.replace({
          widget: new DiffWidget(e2.value.diffHtml, e2.value.widget)
        }));
        deco = builder.finish();
      } else if (e2.is(showInsertion)) {
        const builder = new import_state3.RangeSetBuilder();
        builder.add(e2.value.pos, e2.value.pos, import_view2.Decoration.widget({
          widget: new DiffWidget(e2.value.diffHtml, e2.value.widget),
          side: 1
          // After the position
        }));
        deco = builder.finish();
      } else if (e2.is(hideInlineEdit)) {
        deco = import_view2.Decoration.none;
      }
    }
    return deco;
  },
  provide: (f3) => import_view2.EditorView.decorations.from(f3)
});
var installedEditors = /* @__PURE__ */ new WeakSet();
function computeDiff(oldText, newText) {
  const oldWords = oldText.split(/(\s+)/);
  const newWords = newText.split(/(\s+)/);
  const m = oldWords.length, n2 = newWords.length;
  const dp = Array(m + 1).fill(null).map(() => Array(n2 + 1).fill(0));
  for (let i3 = 1; i3 <= m; i3++) {
    for (let j5 = 1; j5 <= n2; j5++) {
      dp[i3][j5] = oldWords[i3 - 1] === newWords[j5 - 1] ? dp[i3 - 1][j5 - 1] + 1 : Math.max(dp[i3 - 1][j5], dp[i3][j5 - 1]);
    }
  }
  const ops = [];
  let i2 = m, j3 = n2;
  const temp = [];
  while (i2 > 0 || j3 > 0) {
    if (i2 > 0 && j3 > 0 && oldWords[i2 - 1] === newWords[j3 - 1]) {
      temp.push({ type: "equal", text: oldWords[i2 - 1] });
      i2--;
      j3--;
    } else if (j3 > 0 && (i2 === 0 || dp[i2][j3 - 1] >= dp[i2 - 1][j3])) {
      temp.push({ type: "insert", text: newWords[j3 - 1] });
      j3--;
    } else {
      temp.push({ type: "delete", text: oldWords[i2 - 1] });
      i2--;
    }
  }
  temp.reverse();
  for (const op of temp) {
    if (ops.length > 0 && ops[ops.length - 1].type === op.type) {
      ops[ops.length - 1].text += op.text;
    } else {
      ops.push({ ...op });
    }
  }
  return ops;
}
function diffToHtml(ops) {
  return ops.map((op) => {
    const escaped = escapeHtml2(op.text);
    switch (op.type) {
      case "delete":
        return `<span class="claudian-diff-del">${escaped}</span>`;
      case "insert":
        return `<span class="claudian-diff-ins">${escaped}</span>`;
      default:
        return escaped;
    }
  }).join("");
}
var InlineEditModal = class {
  constructor(app, plugin, editContext, notePath) {
    this.app = app;
    this.plugin = plugin;
    this.editContext = editContext;
    this.notePath = notePath;
    this.controller = null;
  }
  async openAndWait() {
    if (activeController) {
      activeController.reject();
      return { decision: "reject" };
    }
    const view = this.app.workspace.getActiveViewOfType(import_obsidian21.MarkdownView);
    if (!view) return { decision: "reject" };
    const editor = view.editor;
    const editorView = getEditorView(editor);
    if (!editorView) return { decision: "reject" };
    return new Promise((resolve3) => {
      this.controller = new InlineEditController(
        this.app,
        this.plugin,
        editorView,
        editor,
        this.editContext,
        this.notePath,
        resolve3
      );
      activeController = this.controller;
      this.controller.show();
    });
  }
};
var InlineEditController = class {
  constructor(app, plugin, editorView, editor, editContext, notePath, resolve3) {
    this.app = app;
    this.plugin = plugin;
    this.editorView = editorView;
    this.editor = editor;
    this.notePath = notePath;
    this.resolve = resolve3;
    this.inputEl = null;
    this.spinnerEl = null;
    this.agentReplyEl = null;
    this.containerEl = null;
    this.editedText = null;
    this.insertedText = null;
    this.startLine = 0;
    this.cursorContext = null;
    this.escHandler = null;
    this.selectionListener = null;
    this.isConversing = false;
    this.slashCommandDropdown = null;
    this.mentionDropdown = null;
    this.attachedFiles = /* @__PURE__ */ new Set();
    this.inlineEditService = new InlineEditService(plugin);
    this.mode = editContext.mode;
    if (editContext.mode === "cursor") {
      this.cursorContext = editContext.cursorContext;
      this.selectedText = "";
    } else {
      this.selectedText = editContext.selectedText;
    }
    this.updatePositionsFromEditor();
  }
  updatePositionsFromEditor() {
    const doc = this.editorView.state.doc;
    if (this.mode === "cursor") {
      const ctx = this.cursorContext;
      const line = doc.line(ctx.line + 1);
      this.selFrom = line.from + ctx.column;
      this.selTo = this.selFrom;
    } else {
      const from = this.editor.getCursor("from");
      const to = this.editor.getCursor("to");
      const fromLine = doc.line(from.line + 1);
      const toLine = doc.line(to.line + 1);
      this.selFrom = fromLine.from + from.ch;
      this.selTo = toLine.from + to.ch;
      this.selectedText = this.editor.getSelection() || this.selectedText;
      this.startLine = from.line + 1;
    }
  }
  show() {
    if (!installedEditors.has(this.editorView)) {
      this.editorView.dispatch({
        effects: import_state3.StateEffect.appendConfig.of(inlineEditField)
      });
      installedEditors.add(this.editorView);
    }
    this.updateHighlight();
    if (this.mode === "selection") {
      this.attachSelectionListeners();
    }
    this.escHandler = (e2) => {
      if (e2.key === "Escape" && !e2.isComposing) {
        this.reject();
      }
    };
    document.addEventListener("keydown", this.escHandler);
  }
  updateHighlight() {
    var _a;
    const doc = this.editorView.state.doc;
    const line = doc.lineAt(this.selFrom);
    const isInbetween = this.mode === "cursor" && ((_a = this.cursorContext) == null ? void 0 : _a.isInbetween);
    this.editorView.dispatch({
      effects: showInlineEdit.of({
        inputPos: isInbetween ? this.selFrom : line.from,
        selFrom: this.selFrom,
        selTo: this.selTo,
        widget: this,
        isInbetween
      })
    });
    this.updateSelectionHighlight();
  }
  updateSelectionHighlight() {
    if (this.mode === "selection" && this.selFrom !== this.selTo) {
      showSelectionHighlight(this.editorView, this.selFrom, this.selTo);
    } else {
      hideSelectionHighlight(this.editorView);
    }
  }
  attachSelectionListeners() {
    this.removeSelectionListeners();
    this.selectionListener = (e2) => {
      const target = e2.target;
      if (target && this.inputEl && (target === this.inputEl || this.inputEl.contains(target))) {
        return;
      }
      const prevFrom = this.selFrom;
      const prevTo = this.selTo;
      const newSelection = this.editor.getSelection();
      if (newSelection && newSelection.length > 0) {
        this.updatePositionsFromEditor();
        if (prevFrom !== this.selFrom || prevTo !== this.selTo) {
          this.updateHighlight();
        }
      }
    };
    this.editorView.dom.addEventListener("mouseup", this.selectionListener);
    this.editorView.dom.addEventListener("keyup", this.selectionListener);
  }
  createInputDOM() {
    const container = document.createElement("div");
    container.className = "claudian-inline-input-container";
    this.containerEl = container;
    this.agentReplyEl = document.createElement("div");
    this.agentReplyEl.className = "claudian-inline-agent-reply";
    this.agentReplyEl.style.display = "none";
    container.appendChild(this.agentReplyEl);
    const inputWrap = document.createElement("div");
    inputWrap.className = "claudian-inline-input-wrap";
    container.appendChild(inputWrap);
    this.inputEl = document.createElement("input");
    this.inputEl.type = "text";
    this.inputEl.className = "claudian-inline-input";
    this.inputEl.placeholder = this.mode === "cursor" ? "Insert instructions..." : "Edit instructions...";
    this.inputEl.spellcheck = false;
    inputWrap.appendChild(this.inputEl);
    this.spinnerEl = document.createElement("div");
    this.spinnerEl.className = "claudian-inline-spinner";
    this.spinnerEl.style.display = "none";
    inputWrap.appendChild(this.spinnerEl);
    this.slashCommandDropdown = new SlashCommandDropdown(
      document.body,
      // Fixed positioning
      this.inputEl,
      {
        onSelect: () => {
        },
        onHide: () => {
        },
        getSdkCommands: () => this.plugin.getSdkCommands()
      },
      {
        fixed: true,
        hiddenCommands: new Set((this.plugin.settings.hiddenSlashCommands || []).map((c3) => c3.toLowerCase()))
      }
    );
    this.mentionDropdown = new MentionDropdownController(
      document.body,
      this.inputEl,
      {
        onAttachFile: (filePath) => this.attachedFiles.add(filePath),
        onMcpMentionChange: () => {
        },
        getMentionedMcpServers: () => /* @__PURE__ */ new Set(),
        setMentionedMcpServers: () => false,
        addMentionedMcpServer: () => {
        },
        getExternalContexts: () => [],
        getCachedMarkdownFiles: () => {
          try {
            return this.app.vault.getMarkdownFiles();
          } catch (e2) {
            return [];
          }
        },
        normalizePathForVault: (rawPath) => this.normalizePathForVault(rawPath)
      },
      { fixed: true }
    );
    this.inputEl.addEventListener("keydown", (e2) => this.handleKeydown(e2));
    this.inputEl.addEventListener("input", () => {
      var _a;
      return (_a = this.mentionDropdown) == null ? void 0 : _a.handleInputChange();
    });
    setTimeout(() => {
      var _a;
      return (_a = this.inputEl) == null ? void 0 : _a.focus();
    }, 50);
    return container;
  }
  async generate() {
    if (!this.inputEl || !this.spinnerEl) return;
    const userMessage = this.inputEl.value.trim();
    if (!userMessage) return;
    this.removeSelectionListeners();
    this.inputEl.disabled = true;
    this.spinnerEl.style.display = "block";
    const contextFiles = Array.from(this.attachedFiles);
    this.attachedFiles.clear();
    let result;
    if (this.isConversing) {
      result = await this.inlineEditService.continueConversation(userMessage, contextFiles);
    } else {
      if (this.mode === "cursor") {
        result = await this.inlineEditService.editText({
          mode: "cursor",
          instruction: userMessage,
          notePath: this.notePath,
          cursorContext: this.cursorContext,
          contextFiles
        });
      } else {
        const lineCount = this.selectedText.split(/\r?\n/).length;
        result = await this.inlineEditService.editText({
          mode: "selection",
          instruction: userMessage,
          notePath: this.notePath,
          selectedText: this.selectedText,
          startLine: this.startLine,
          lineCount,
          contextFiles
        });
      }
    }
    this.spinnerEl.style.display = "none";
    if (result.success) {
      if (result.editedText !== void 0) {
        this.editedText = result.editedText;
        this.showDiffInPlace();
      } else if (result.insertedText !== void 0) {
        this.insertedText = result.insertedText;
        this.showInsertionInPlace();
      } else if (result.clarification) {
        this.showAgentReply(result.clarification);
        this.isConversing = true;
        this.inputEl.disabled = false;
        this.inputEl.value = "";
        this.inputEl.placeholder = "Reply to continue...";
        this.inputEl.focus();
      } else {
        this.handleError("No response from agent");
      }
    } else {
      this.handleError(result.error || "Error - try again");
    }
  }
  showAgentReply(message) {
    if (!this.agentReplyEl || !this.containerEl) return;
    this.agentReplyEl.style.display = "block";
    this.agentReplyEl.textContent = message;
    this.containerEl.classList.add("has-agent-reply");
  }
  handleError(errorMessage) {
    if (!this.inputEl) return;
    this.inputEl.disabled = false;
    this.inputEl.placeholder = errorMessage;
    this.updatePositionsFromEditor();
    this.updateHighlight();
    this.attachSelectionListeners();
    this.inputEl.focus();
  }
  showDiffInPlace() {
    if (this.editedText === null) return;
    hideSelectionHighlight(this.editorView);
    const diffOps = computeDiff(this.selectedText, this.editedText);
    const diffHtml = diffToHtml(diffOps);
    this.editorView.dispatch({
      effects: showDiff.of({
        from: this.selFrom,
        to: this.selTo,
        diffHtml,
        widget: this
      })
    });
    if (this.escHandler) {
      document.removeEventListener("keydown", this.escHandler);
    }
    this.escHandler = (e2) => {
      if (e2.key === "Escape" && !e2.isComposing) {
        this.reject();
      } else if (e2.key === "Enter" && !e2.isComposing) {
        this.accept();
      }
    };
    document.addEventListener("keydown", this.escHandler);
  }
  showInsertionInPlace() {
    if (this.insertedText === null) return;
    hideSelectionHighlight(this.editorView);
    const trimmedText = normalizeInsertionText(this.insertedText);
    this.insertedText = trimmedText;
    const escaped = escapeHtml2(trimmedText);
    const diffHtml = `<span class="claudian-diff-ins">${escaped}</span>`;
    this.editorView.dispatch({
      effects: showInsertion.of({
        pos: this.selFrom,
        diffHtml,
        widget: this
      })
    });
    if (this.escHandler) {
      document.removeEventListener("keydown", this.escHandler);
    }
    this.escHandler = (e2) => {
      if (e2.key === "Escape" && !e2.isComposing) {
        this.reject();
      } else if (e2.key === "Enter" && !e2.isComposing) {
        this.accept();
      }
    };
    document.addEventListener("keydown", this.escHandler);
  }
  accept() {
    var _a;
    const textToInsert = (_a = this.editedText) != null ? _a : this.insertedText;
    if (textToInsert !== null) {
      const doc = this.editorView.state.doc;
      const fromLine = doc.lineAt(this.selFrom);
      const toLine = doc.lineAt(this.selTo);
      const from = { line: fromLine.number - 1, ch: this.selFrom - fromLine.from };
      const to = { line: toLine.number - 1, ch: this.selTo - toLine.from };
      this.cleanup();
      this.editor.replaceRange(textToInsert, from, to);
      this.resolve({ decision: "accept", editedText: textToInsert });
    } else {
      this.cleanup();
      this.resolve({ decision: "reject" });
    }
  }
  reject() {
    this.cleanup({ keepSelectionHighlight: true });
    this.restoreSelectionHighlight();
    this.resolve({ decision: "reject" });
  }
  removeSelectionListeners() {
    if (this.selectionListener) {
      this.editorView.dom.removeEventListener("mouseup", this.selectionListener);
      this.editorView.dom.removeEventListener("keyup", this.selectionListener);
      this.selectionListener = null;
    }
  }
  cleanup(options) {
    var _a, _b;
    this.inlineEditService.cancel();
    this.inlineEditService.resetConversation();
    this.isConversing = false;
    this.removeSelectionListeners();
    if (this.escHandler) {
      document.removeEventListener("keydown", this.escHandler);
    }
    (_a = this.slashCommandDropdown) == null ? void 0 : _a.destroy();
    this.slashCommandDropdown = null;
    (_b = this.mentionDropdown) == null ? void 0 : _b.destroy();
    this.mentionDropdown = null;
    this.attachedFiles.clear();
    if (activeController === this) {
      activeController = null;
    }
    this.editorView.dispatch({
      effects: hideInlineEdit.of(null)
    });
    if (!(options == null ? void 0 : options.keepSelectionHighlight)) {
      hideSelectionHighlight(this.editorView);
    }
  }
  restoreSelectionHighlight() {
    if (this.mode !== "selection" || this.selFrom === this.selTo) {
      return;
    }
    showSelectionHighlight(this.editorView, this.selFrom, this.selTo);
  }
  handleKeydown(e2) {
    var _a, _b;
    if ((_a = this.mentionDropdown) == null ? void 0 : _a.handleKeydown(e2)) {
      return;
    }
    if ((_b = this.slashCommandDropdown) == null ? void 0 : _b.handleKeydown(e2)) {
      return;
    }
    if (e2.key === "Enter" && !e2.isComposing) {
      e2.preventDefault();
      this.generate();
    }
  }
  normalizePathForVault(rawPath) {
    try {
      const vaultPath = getVaultPath(this.app);
      return normalizePathForVault(rawPath, vaultPath);
    } catch (e2) {
      new import_obsidian21.Notice("Failed to attach file: invalid path");
      return null;
    }
  }
};

// src/features/settings/ClaudianSettings.ts
var fs7 = __toESM(require("fs"));
var import_obsidian28 = require("obsidian");

// src/i18n/locales/de.json
var de_exports = {};
__export(de_exports, {
  common: () => common,
  default: () => de_default,
  settings: () => settings
});
var common = {
  save: "Speichern",
  cancel: "Abbrechen",
  delete: "L\xF6schen",
  edit: "Bearbeiten",
  add: "Hinzuf\xFCgen",
  remove: "Entfernen",
  clear: "L\xF6schen",
  clearAll: "Alle l\xF6schen",
  loading: "L\xE4dt",
  error: "Fehler",
  success: "Erfolg",
  warning: "Warnung",
  confirm: "Best\xE4tigen",
  settings: "Einstellungen",
  advanced: "Erweitert",
  enabled: "Aktiviert",
  disabled: "Deaktiviert",
  platform: "Plattform"
};
var settings = {
  title: "Claudian Einstellungen",
  customization: "Anpassung",
  userName: {
    name: "Wie soll Claudian dich nennen?",
    desc: "Dein Name f\xFCr personalisierte Begr\xFC\xDFungen (leer lassen f\xFCr allgemeine Begr\xFC\xDFungen)"
  },
  excludedTags: {
    name: "Ausgeschlossene Tags",
    desc: "Notizen mit diesen Tags werden nicht automatisch als Kontext geladen (einer pro Zeile, ohne #)"
  },
  mediaFolder: {
    name: "Medienordner",
    desc: "Ordner mit Anh\xE4ngen/Bildern. Wenn Notizen ![[image.jpg]] verwenden, sucht Claude hier. Leer lassen f\xFCr Vault-Stammverzeichnis."
  },
  systemPrompt: {
    name: "Benutzerdefinierter System-Prompt",
    desc: "Zus\xE4tzliche Anweisungen, die an den Standard-System-Prompt angeh\xE4ngt werden"
  },
  autoTitle: {
    name: "Konversationstitel automatisch generieren",
    desc: "Generiert automatisch Konversationstitel nach der ersten Nutzernachricht."
  },
  titleModel: {
    name: "Titel-Generierungsmodell",
    desc: "Modell zur automatischen Generierung von Konversationstiteln.",
    auto: "Automatisch (Haiku)"
  },
  navMappings: {
    name: "Vim-Style Navigationszuordnungen",
    desc: 'Eine Zuordnung pro Zeile. Format: "map <Taste> <Aktion>" (Aktionen: scrollUp, scrollDown, focusInput).'
  },
  hotkeys: "Tastenk\xFCrzel",
  slashCommands: {
    name: "Schr\xE4gstrich-Befehle",
    desc: "Erstelle benutzerdefinierte Prompt-Vorlagen, die durch /command ausgel\xF6st werden. Verwende $ARGUMENTS f\xFCr alle Argumente, $1/$2 f\xFCr Positionsargumente, @file f\xFCr Dateiinhalt und !`bash` f\xFCr Befehlsausgabe."
  },
  hiddenSlashCommands: {
    name: "Ausgeblendete Befehle",
    desc: "Bestimmte Schr\xE4gstrich-Befehle aus dem Dropdown ausblenden. N\xFCtzlich, um Claude Code-Befehle auszublenden, die f\xFCr Claudian nicht relevant sind. Gib Befehlsnamen ohne f\xFChrenden Schr\xE4gstrich ein, einen pro Zeile.",
    placeholder: "commit\nbuild\ntest"
  },
  mcpServers: {
    name: "MCP-Server",
    desc: "Konfiguriere Model Context Protocol Server, um Claude mit externen Tools und Datenquellen zu erweitern. Server mit Kontext-Speichermodus ben\xF6tigen @mention zur Aktivierung."
  },
  plugins: {
    name: "Claude Code Plugins",
    desc: "Aktiviere oder deaktiviere Claude Code Plugins aus ~/.claude/plugins. Aktivierte Plugins werden pro Vault gespeichert."
  },
  safety: "Sicherheit",
  loadUserSettings: {
    name: "Benutzer-Claude-Einstellungen laden",
    desc: "L\xE4dt ~/.claude/settings.json. Wenn aktiviert, k\xF6nnen Benutzer-Claude-Code-Berechtigungsregeln den Sicherheitsmodus umgehen."
  },
  enableBlocklist: {
    name: "Befehlsblockliste aktivieren",
    desc: "Blockiert potenziell gef\xE4hrliche Bash-Befehle"
  },
  blockedCommands: {
    name: "Blockierte Befehle ({platform})",
    desc: "Muster zum Blockieren auf {platform} (einer pro Zeile). Unterst\xFCtzt Regex.",
    unixName: "Blockierte Befehle (Unix/Git Bash)",
    unixDesc: "Unix-Muster werden auch auf Windows blockiert, da Git Bash sie aufrufen kann."
  },
  exportPaths: {
    name: "Zugelassene Exportpfade",
    desc: "Pfade au\xDFerhalb des Vaults, in die Dateien exportiert werden k\xF6nnen (einer pro Zeile). Unterst\xFCtzt ~ f\xFCr Home-Verzeichnis."
  },
  environment: "Umgebung",
  customVariables: {
    name: "Benutzerdefinierte Variablen",
    desc: "Umgebungsvariablen f\xFCr Claude SDK (KEY=VALUE-Format, eine pro Zeile). Export-Pr\xE4fix unterst\xFCtzt."
  },
  envSnippets: {
    name: "Snippets",
    addBtn: "Snippet hinzuf\xFCgen",
    noSnippets: "Keine gespeicherten Umgebungsvariablen-Snippets. Klicken Sie auf +, um Ihre aktuelle Konfiguration zu speichern.",
    nameRequired: "Bitte geben Sie einen Namen f\xFCr das Snippet ein",
    modal: {
      titleEdit: "Snippet bearbeiten",
      titleSave: "Snippet speichern",
      name: "Name",
      namePlaceholder: "Ein beschreibender Name f\xFCr diese Umgebungskonfiguration",
      description: "Beschreibung",
      descPlaceholder: "Optionale Beschreibung",
      envVars: "Umgebungsvariablen",
      envVarsPlaceholder: "KEY=VALUE-Format, eine pro Zeile (export-Pr\xE4fix unterst\xFCtzt)",
      save: "Speichern",
      update: "Aktualisieren",
      cancel: "Abbrechen"
    }
  },
  customContextLimits: {
    name: "Benutzerdefinierte Kontextlimits",
    desc: "Legen Sie die Kontextfenstergr\xF6\xDFen f\xFCr Ihre benutzerdefinierten Modelle fest. Leer lassen f\xFCr den Standardwert (200k Token).",
    invalid: "Ung\xFCltiges Format. Verwenden Sie: 256k, 1m oder exakte Anzahl (1000-10000000)."
  },
  advanced: "Erweitert",
  show1MModel: {
    name: "Sonnet mit 1M-Kontextfenster aktivieren",
    desc: "Standard-Sonnet durch Sonnet (1M) in der Modellauswahl ersetzen. Gleiche Preise unter 200k Token. Erfordert Max-Abonnement."
  },
  enableChrome: {
    name: "Chrome-Erweiterung aktivieren",
    desc: "Erlaubt Claude die Interaktion mit Chrome \xFCber die claude-in-chrome-Erweiterung. Die Erweiterung muss installiert sein. Erfordert Neustart der Sitzung."
  },
  maxTabs: {
    name: "Maximale Chat-Tabs",
    desc: "Maximale Anzahl gleichzeitiger Chat-Tabs (3-10). Jeder Tab verwendet eine separate Claude-Sitzung.",
    warning: "Mehr als 5 Tabs k\xF6nnen Leistung und Speichernutzung beeintr\xE4chtigen."
  },
  tabBarPosition: {
    name: "Tab-Leiste Position",
    desc: "W\xE4hlen Sie, wo Tab-Badges und Aktionsschaltfl\xE4chen angezeigt werden",
    input: "\xDCber Eingabefeld (Standard)",
    header: "In Kopfzeile"
  },
  enableAutoScroll: {
    name: "Automatisches Scrollen w\xE4hrend Streaming",
    desc: "Automatisch nach unten scrollen, w\xE4hrend Claude Antworten streamt. Deaktivieren, um oben zu bleiben und von Anfang an zu lesen."
  },
  cliPath: {
    name: "Claude CLI-Pfad",
    desc: "Benutzerdefinierter Pfad zum Claude Code CLI. Leer lassen f\xFCr automatische Erkennung.",
    descWindows: "F\xFCr den nativen Installer verwenden Sie claude.exe. F\xFCr npm/pnpm/yarn oder andere Paketmanager-Installationen verwenden Sie den cli.js-Pfad (nicht claude.cmd).",
    descUnix: 'F\xFCgen Sie die Ausgabe von "which claude" ein \u2014 funktioniert sowohl f\xFCr native als auch npm/pnpm/yarn-Installationen.',
    validation: {
      notExist: "Pfad existiert nicht",
      isDirectory: "Pfad ist ein Verzeichnis, keine Datei"
    }
  },
  language: {
    name: "Sprache",
    desc: "Anzeigesprache der Plugin-Oberfl\xE4che \xE4ndern"
  }
};
var de_default = {
  common,
  settings
};

// src/i18n/locales/en.json
var en_exports = {};
__export(en_exports, {
  common: () => common2,
  default: () => en_default,
  settings: () => settings2
});
var common2 = {
  save: "Save",
  cancel: "Cancel",
  delete: "Delete",
  edit: "Edit",
  add: "Add",
  remove: "Remove",
  clear: "Clear",
  clearAll: "Clear all",
  loading: "Loading",
  error: "Error",
  success: "Success",
  warning: "Warning",
  confirm: "Confirm",
  settings: "Settings",
  advanced: "Advanced",
  enabled: "Enabled",
  disabled: "Disabled",
  platform: "Platform"
};
var settings2 = {
  title: "Claudian Settings",
  customization: "Customization",
  userName: {
    name: "What should Claudian call you?",
    desc: "Your name for personalized greetings (leave empty for generic greetings)"
  },
  excludedTags: {
    name: "Excluded tags",
    desc: "Notes with these tags will not auto-load as context (one per line, without #)"
  },
  mediaFolder: {
    name: "Media folder",
    desc: "Folder containing attachments/images. When notes use ![[image.jpg]], Claude will look here. Leave empty for vault root."
  },
  systemPrompt: {
    name: "Custom system prompt",
    desc: "Additional instructions appended to the default system prompt"
  },
  autoTitle: {
    name: "Auto-generate conversation titles",
    desc: "Automatically generate conversation titles after the first user message is sent."
  },
  titleModel: {
    name: "Title generation model",
    desc: "Model used for auto-generating conversation titles.",
    auto: "Auto (Haiku)"
  },
  navMappings: {
    name: "Vim-style navigation mappings",
    desc: 'One mapping per line. Format: "map <key> <action>" (actions: scrollUp, scrollDown, focusInput).'
  },
  hotkeys: "Hotkeys",
  slashCommands: {
    name: "Slash Commands",
    desc: "Create custom prompt templates triggered by /command. Use $ARGUMENTS for all arguments, $1/$2 for positional args, @file for file content, and !`bash` for command output."
  },
  hiddenSlashCommands: {
    name: "Hidden Commands",
    desc: "Hide specific slash commands from the dropdown. Useful for hiding Claude Code commands that are not relevant to Claudian. Enter command names without the leading slash, one per line.",
    placeholder: "commit\nbuild\ntest"
  },
  mcpServers: {
    name: "MCP Servers",
    desc: "Configure Model Context Protocol servers to extend Claude's capabilities with external tools and data sources. Servers with context-saving mode require @mention to activate."
  },
  plugins: {
    name: "Claude Code Plugins",
    desc: "Enable or disable Claude Code plugins discovered from ~/.claude/plugins. Enabled plugins are stored per vault."
  },
  safety: "Safety",
  loadUserSettings: {
    name: "Load user Claude settings",
    desc: "Load ~/.claude/settings.json. When enabled, user's Claude Code permission rules may bypass Safe mode."
  },
  enableBlocklist: {
    name: "Enable command blocklist",
    desc: "Block potentially dangerous bash commands"
  },
  blockedCommands: {
    name: "Blocked commands ({platform})",
    desc: "Patterns to block on {platform} (one per line). Supports regex.",
    unixName: "Blocked commands (Unix/Git Bash)",
    unixDesc: "Unix patterns also blocked on Windows because Git Bash can invoke them."
  },
  exportPaths: {
    name: "Allowed export paths",
    desc: "Paths outside the vault where files can be exported (one per line). Supports ~ for home directory."
  },
  environment: "Environment",
  customVariables: {
    name: "Custom variables",
    desc: "Environment variables for Claude SDK (KEY=VALUE format, one per line). Shell export prefix supported."
  },
  envSnippets: {
    name: "Snippets",
    addBtn: "Add snippet",
    noSnippets: "No saved environment snippets yet. Click + to save your current environment configuration.",
    nameRequired: "Please enter a name for the snippet",
    modal: {
      titleEdit: "Edit snippet",
      titleSave: "Save snippet",
      name: "Name",
      namePlaceholder: "A descriptive name for this environment configuration",
      description: "Description",
      descPlaceholder: "Optional description",
      envVars: "Environment variables",
      envVarsPlaceholder: "KEY=VALUE format, one per line (export prefix supported)",
      save: "Save",
      update: "Update",
      cancel: "Cancel"
    }
  },
  customContextLimits: {
    name: "Custom Context Limits",
    desc: "Set context window sizes for your custom models. Leave empty to use the default (200k tokens).",
    invalid: "Invalid format. Use: 256k, 1m, or exact count (1000-10000000)."
  },
  advanced: "Advanced",
  show1MModel: {
    name: "Enable Sonnet with 1M context window",
    desc: "Replace standard Sonnet with Sonnet (1M) in the model selector. Same pricing under 200k tokens. Requires Max subscription."
  },
  enableChrome: {
    name: "Enable Chrome extension",
    desc: "Allow Claude to interact with Chrome via the claude-in-chrome extension. Requires the extension to be installed. Requires session restart."
  },
  maxTabs: {
    name: "Maximum chat tabs",
    desc: "Maximum number of concurrent chat tabs (3-10). Each tab uses a separate Claude session.",
    warning: "More than 5 tabs may impact performance and memory usage."
  },
  tabBarPosition: {
    name: "Tab bar position",
    desc: "Choose where to display tab badges and action buttons",
    input: "Above input (default)",
    header: "In header"
  },
  enableAutoScroll: {
    name: "Auto-scroll during streaming",
    desc: "Automatically scroll to the bottom as Claude streams responses. Disable to stay at the top and read from the beginning."
  },
  cliPath: {
    name: "Claude CLI path",
    desc: "Custom path to Claude Code CLI. Leave empty for auto-detection.",
    descWindows: "For the native installer, use claude.exe. For npm/pnpm/yarn or other package manager installs, use the cli.js path (not claude.cmd).",
    descUnix: 'Paste the output of "which claude" \u2014 works for both native and npm/pnpm/yarn installs.',
    validation: {
      notExist: "Path does not exist",
      isDirectory: "Path is a directory, not a file"
    }
  },
  language: {
    name: "Language",
    desc: "Change the display language of the plugin interface"
  }
};
var en_default = {
  common: common2,
  settings: settings2
};

// src/i18n/locales/es.json
var es_exports = {};
__export(es_exports, {
  common: () => common3,
  default: () => es_default,
  settings: () => settings3
});
var common3 = {
  save: "Guardar",
  cancel: "Cancelar",
  delete: "Eliminar",
  edit: "Editar",
  add: "Agregar",
  remove: "Eliminar",
  clear: "Limpiar",
  clearAll: "Limpiar todo",
  loading: "Cargando",
  error: "Error",
  success: "\xC9xito",
  warning: "Advertencia",
  confirm: "Confirmar",
  settings: "Configuraci\xF3n",
  advanced: "Avanzado",
  enabled: "Habilitado",
  disabled: "Deshabilitado",
  platform: "Plataforma"
};
var settings3 = {
  title: "Configuraci\xF3n de Claudian",
  customization: "Personalizaci\xF3n",
  userName: {
    name: "\xBFC\xF3mo deber\xEDa Claudian llamarte?",
    desc: "Tu nombre para saludos personalizados (dejar vac\xEDo para saludos gen\xE9ricos)"
  },
  excludedTags: {
    name: "Etiquetas excluidas",
    desc: "Las notas con estas etiquetas no se cargar\xE1n autom\xE1ticamente como contexto (una por l\xEDnea, sin #)"
  },
  mediaFolder: {
    name: "Carpeta de medios",
    desc: "Carpeta que contiene archivos adjuntos/imagenes. Cuando las notas usan ![[image.jpg]], Claude buscar\xE1 aqu\xED. Dejar vac\xEDo para la ra\xEDz del dep\xF3sito."
  },
  systemPrompt: {
    name: "Prompt de sistema personalizado",
    desc: "Instrucciones adicionales a\xF1adidas al prompt de sistema por defecto"
  },
  autoTitle: {
    name: "Generar autom\xE1ticamente t\xEDtulos de conversaci\xF3n",
    desc: "Genera autom\xE1ticamente t\xEDtulos de conversaci\xF3n despu\xE9s del primer mensaje del usuario."
  },
  titleModel: {
    name: "Modelo de generaci\xF3n de t\xEDtulos",
    desc: "Modelo utilizado para generar autom\xE1ticamente t\xEDtulos de conversaci\xF3n.",
    auto: "Auto (Haiku)"
  },
  navMappings: {
    name: "Mapeos de navegaci\xF3n estilo Vim",
    desc: 'Un mapeo por l\xEDnea. Formato: "map <tecla> <acci\xF3n>" (acciones: scrollUp, scrollDown, focusInput).'
  },
  hotkeys: "Atajos de teclado",
  slashCommands: {
    name: "Comandos slash",
    desc: "Crea plantillas de prompts personalizadas activadas por /command. Usa $ARGUMENTS para todos los argumentos, $1/$2 para argumentos posicionales, @file para contenido de archivo y !`bash` para salida de comandos."
  },
  hiddenSlashCommands: {
    name: "Comandos ocultos",
    desc: "Oculta comandos slash espec\xEDficos del men\xFA desplegable. \xDAtil para ocultar comandos de Claude Code que no son relevantes para Claudian. Ingresa nombres de comandos sin la barra inicial, uno por l\xEDnea.",
    placeholder: "commit\nbuild\ntest"
  },
  mcpServers: {
    name: "Servidores MCP",
    desc: "Configura servidores Model Context Protocol para extender las capacidades de Claude con herramientas y fuentes de datos externas. Los servidores con modo de guardado de contexto requieren @mention para activarse."
  },
  plugins: {
    name: "Plugins de Claude Code",
    desc: "Habilita o deshabilita plugins de Claude Code descubiertos desde ~/.claude/plugins. Los plugins habilitados se almacenan por b\xF3veda."
  },
  safety: "Seguridad",
  loadUserSettings: {
    name: "Cargar configuraci\xF3n de usuario Claude",
    desc: "Carga ~/.claude/settings.json. Cuando est\xE1 habilitado, las reglas de permisos del usuario pueden eludir el modo seguro."
  },
  enableBlocklist: {
    name: "Habilitar lista negra de comandos",
    desc: "Bloquea comandos bash potencialmente peligrosos"
  },
  blockedCommands: {
    name: "Comandos bloqueados ({platform})",
    desc: "Patrones a bloquear en {platform} (uno por l\xEDnea). Soporta expresiones regulares.",
    unixName: "Comandos bloqueados (Unix/Git Bash)",
    unixDesc: "Los patrones Unix tambi\xE9n se bloquean en Windows porque Git Bash puede invocarlos."
  },
  exportPaths: {
    name: "Rutas de exportaci\xF3n permitidas",
    desc: "Rutas fuera del dep\xF3sito donde se pueden exportar archivos (una por l\xEDnea). Soporta ~ para el directorio home."
  },
  environment: "Entorno",
  customVariables: {
    name: "Variables personalizadas",
    desc: "Variables de entorno para Claude SDK (formato KEY=VALUE, una por l\xEDnea). Prefijo export soportado."
  },
  envSnippets: {
    name: "Snippets",
    addBtn: "A\xF1adir fragmento",
    noSnippets: "No hay fragmentos de entorno guardados. Haga clic en + para guardar su configuraci\xF3n actual.",
    nameRequired: "Por favor ingrese un nombre para el fragmento",
    modal: {
      titleEdit: "Editar fragmento",
      titleSave: "Guardar fragmento",
      name: "Nombre",
      namePlaceholder: "Un nombre descriptivo para esta configuraci\xF3n",
      description: "Descripci\xF3n",
      descPlaceholder: "Descripci\xF3n opcional",
      envVars: "Variables de entorno",
      envVarsPlaceholder: "Formato KEY=VALUE, una por l\xEDnea (prefijo export soportado)",
      save: "Guardar",
      update: "Actualizar",
      cancel: "Cancelar"
    }
  },
  customContextLimits: {
    name: "L\xEDmites de contexto personalizados",
    desc: "Establezca tama\xF1os de ventana de contexto para sus modelos personalizados. Deje vac\xEDo para usar el valor predeterminado (200k tokens).",
    invalid: "Formato inv\xE1lido. Use: 256k, 1m o n\xFAmero exacto (1000-10000000)."
  },
  advanced: "Avanzado",
  show1MModel: {
    name: "Habilitar Sonnet con ventana de contexto de 1M",
    desc: "Reemplazar Sonnet est\xE1ndar con Sonnet (1M) en el selector de modelos. Mismo precio bajo 200k tokens. Requiere suscripci\xF3n Max."
  },
  enableChrome: {
    name: "Habilitar extensi\xF3n de Chrome",
    desc: "Permitir que Claude interact\xFAe con Chrome a trav\xE9s de la extensi\xF3n claude-in-chrome. Requiere que la extensi\xF3n est\xE9 instalada. Requiere reinicio de sesi\xF3n."
  },
  maxTabs: {
    name: "M\xE1ximo de pesta\xF1as de chat",
    desc: "N\xFAmero m\xE1ximo de pesta\xF1as de chat simult\xE1neas (3-10). Cada pesta\xF1a usa una sesi\xF3n de Claude separada.",
    warning: "M\xE1s de 5 pesta\xF1as puede afectar el rendimiento y el uso de memoria."
  },
  tabBarPosition: {
    name: "Posici\xF3n de la barra de pesta\xF1as",
    desc: "Elige d\xF3nde mostrar las insignias de pesta\xF1as y los botones de acci\xF3n",
    input: "Sobre el \xE1rea de entrada (predeterminado)",
    header: "En el encabezado"
  },
  enableAutoScroll: {
    name: "Desplazamiento autom\xE1tico durante streaming",
    desc: "Desplazarse autom\xE1ticamente hacia abajo mientras Claude transmite respuestas. Desactivar para quedarse arriba y leer desde el principio."
  },
  cliPath: {
    name: "Ruta CLI Claude",
    desc: "Ruta personalizada a Claude Code CLI. Dejar vac\xEDo para detecci\xF3n autom\xE1tica.",
    descWindows: "Para el instalador nativo, use claude.exe. Para instalaciones con npm/pnpm/yarn u otros gestores de paquetes, use la ruta cli.js (no claude.cmd).",
    descUnix: 'Pegue la salida de "which claude" \u2014 funciona tanto para instalaciones nativas como npm/pnpm/yarn.',
    validation: {
      notExist: "La ruta no existe",
      isDirectory: "La ruta es un directorio, no un archivo"
    }
  },
  language: {
    name: "Idioma",
    desc: "Cambiar el idioma de visualizaci\xF3n de la interfaz del plugin"
  }
};
var es_default = {
  common: common3,
  settings: settings3
};

// src/i18n/locales/fr.json
var fr_exports = {};
__export(fr_exports, {
  common: () => common4,
  default: () => fr_default,
  settings: () => settings4
});
var common4 = {
  save: "Enregistrer",
  cancel: "Annuler",
  delete: "Supprimer",
  edit: "Modifier",
  add: "Ajouter",
  remove: "Supprimer",
  clear: "Effacer",
  clearAll: "Tout effacer",
  loading: "Chargement",
  error: "Erreur",
  success: "Succ\xE8s",
  warning: "Avertissement",
  confirm: "Confirmer",
  settings: "Param\xE8tres",
  advanced: "Avanc\xE9",
  enabled: "Activ\xE9",
  disabled: "D\xE9sactiv\xE9",
  platform: "Plateforme"
};
var settings4 = {
  title: "Param\xE8tres Claudian",
  customization: "Personnalisation",
  userName: {
    name: "Comment Claudian doit-il vous appeler ?",
    desc: "Votre nom pour les salutations personnalis\xE9es (laisser vide pour les salutations g\xE9n\xE9riques)"
  },
  excludedTags: {
    name: "Tags exclus",
    desc: "Les notes avec ces tags ne seront pas charg\xE9es automatiquement comme contexte (un par ligne, sans #)"
  },
  mediaFolder: {
    name: "Dossier des m\xE9dias",
    desc: "Dossier contenant les pi\xE8ces jointes/images. Lorsque les notes utilisent ![[image.jpg]], Claude cherchera ici. Laisser vide pour la racine du coffre."
  },
  systemPrompt: {
    name: "Prompt syst\xE8me personnalis\xE9",
    desc: "Instructions suppl\xE9mentaires ajout\xE9es au prompt syst\xE8me par d\xE9faut"
  },
  autoTitle: {
    name: "G\xE9n\xE9rer automatiquement les titres de conversation",
    desc: "G\xE9n\xE8re automatiquement les titres de conversation apr\xE8s le premier message de l'utilisateur."
  },
  titleModel: {
    name: "Mod\xE8le de g\xE9n\xE9ration de titre",
    desc: "Mod\xE8le utilis\xE9 pour g\xE9n\xE9rer automatiquement les titres de conversation.",
    auto: "Auto (Haiku)"
  },
  navMappings: {
    name: "Mappages de navigation style Vim",
    desc: 'Un mappage par ligne. Format : "map <touche> <action>" (actions : scrollUp, scrollDown, focusInput).'
  },
  hotkeys: "Raccourcis clavier",
  slashCommands: {
    name: "Commandes slash",
    desc: "Cr\xE9ez des mod\xE8les de prompts personnalis\xE9s d\xE9clench\xE9s par /command. Utilisez $ARGUMENTS pour tous les arguments, $1/$2 pour les arguments positionnels, @file pour le contenu du fichier et !`bash` pour la sortie de commande."
  },
  hiddenSlashCommands: {
    name: "Commandes masqu\xE9es",
    desc: "Masquer des commandes slash sp\xE9cifiques du menu d\xE9roulant. Utile pour masquer les commandes Claude Code qui ne sont pas pertinentes pour Claudian. Entrez les noms de commandes sans le slash initial, un par ligne.",
    placeholder: "commit\nbuild\ntest"
  },
  mcpServers: {
    name: "Serveurs MCP",
    desc: "Configurez les serveurs Model Context Protocol pour \xE9tendre les capacit\xE9s de Claude avec des outils et sources de donn\xE9es externes. Les serveurs avec mode de sauvegarde de contexte n\xE9cessitent une @mention pour s'activer."
  },
  plugins: {
    name: "Plugins Claude Code",
    desc: "Activez ou d\xE9sactivez les plugins Claude Code d\xE9couverts dans ~/.claude/plugins. Les plugins activ\xE9s sont stock\xE9s par coffre."
  },
  safety: "S\xE9curit\xE9",
  loadUserSettings: {
    name: "Charger les param\xE8tres utilisateur Claude",
    desc: "Charge ~/.claude/settings.json. Lorsqu'activ\xE9, les r\xE8gles de permission de l'utilisateur peuvent contourner le mode s\xE9curis\xE9."
  },
  enableBlocklist: {
    name: "Activer la liste noire de commandes",
    desc: "Bloque les commandes bash potentiellement dangereuses"
  },
  blockedCommands: {
    name: "Commandes bloqu\xE9es ({platform})",
    desc: "Mod\xE8les \xE0 bloquer sur {platform} (un par ligne). Supporte les expressions r\xE9guli\xE8res.",
    unixName: "Commandes bloqu\xE9es (Unix/Git Bash)",
    unixDesc: "Les mod\xE8les Unix sont \xE9galement bloqu\xE9s sur Windows car Git Bash peut les appeler."
  },
  exportPaths: {
    name: "Chemins d'exportation autoris\xE9s",
    desc: "Chemins en dehors du coffre o\xF9 les fichiers peuvent \xEAtre export\xE9s (un par ligne). Supporte ~ pour le r\xE9pertoire home."
  },
  environment: "Environnement",
  customVariables: {
    name: "Variables personnalis\xE9es",
    desc: "Variables d'environnement pour Claude SDK (format KEY=VALUE, une par ligne). Pr\xE9fixe export support\xE9."
  },
  envSnippets: {
    name: "Snippets",
    addBtn: "Ajouter un extrait",
    noSnippets: "Aucun extrait d'environnement enregistr\xE9. Cliquez sur + pour sauvegarder votre configuration actuelle.",
    nameRequired: "Veuillez entrer un nom pour l'extrait",
    modal: {
      titleEdit: "Modifier l'extrait",
      titleSave: "Sauvegarder l'extrait",
      name: "Nom",
      namePlaceholder: "Un nom descriptif pour cette configuration",
      description: "Description",
      descPlaceholder: "Description optionnelle",
      envVars: "Variables d'environnement",
      envVarsPlaceholder: "Format KEY=VALUE, une par ligne (pr\xE9fixe export support\xE9)",
      save: "Enregistrer",
      update: "Mettre \xE0 jour",
      cancel: "Annuler"
    }
  },
  customContextLimits: {
    name: "Limites de contexte personnalis\xE9es",
    desc: "D\xE9finissez les tailles de fen\xEAtre de contexte pour vos mod\xE8les personnalis\xE9s. Laissez vide pour utiliser la valeur par d\xE9faut (200k tokens).",
    invalid: "Format invalide. Utilisez : 256k, 1m ou nombre exact (1000-10000000)."
  },
  advanced: "Avanc\xE9",
  show1MModel: {
    name: "Activer Sonnet avec fen\xEAtre de contexte de 1M",
    desc: "Remplacer Sonnet standard par Sonnet (1M) dans le s\xE9lecteur de mod\xE8les. M\xEAme tarif sous 200k tokens. N\xE9cessite un abonnement Max."
  },
  enableChrome: {
    name: "Activer l'extension Chrome",
    desc: "Permettre \xE0 Claude d'interagir avec Chrome via l'extension claude-in-chrome. L'extension doit \xEAtre install\xE9e. N\xE9cessite un red\xE9marrage de session."
  },
  maxTabs: {
    name: "Maximum d'onglets de chat",
    desc: "Nombre maximum d'onglets de chat simultan\xE9s (3-10). Chaque onglet utilise une session Claude s\xE9par\xE9e.",
    warning: "Plus de 5 onglets peut affecter les performances et l'utilisation de la m\xE9moire."
  },
  tabBarPosition: {
    name: "Position de la barre d'onglets",
    desc: "Choisissez o\xF9 afficher les badges d'onglets et les boutons d'action",
    input: "Au-dessus de la saisie (par d\xE9faut)",
    header: "Dans l'en-t\xEAte"
  },
  enableAutoScroll: {
    name: "D\xE9filement automatique pendant le streaming",
    desc: "D\xE9filer automatiquement vers le bas pendant que Claude diffuse les r\xE9ponses. D\xE9sactiver pour rester en haut et lire depuis le d\xE9but."
  },
  cliPath: {
    name: "Chemin CLI Claude",
    desc: "Chemin personnalis\xE9 vers Claude Code CLI. Laisser vide pour la d\xE9tection automatique.",
    descWindows: "Pour l'installateur natif, utilisez claude.exe. Pour les installations npm/pnpm/yarn ou autres gestionnaires de paquets, utilisez le chemin cli.js (pas claude.cmd).",
    descUnix: 'Collez la sortie de "which claude" \u2014 fonctionne pour les installations natives et npm/pnpm/yarn.',
    validation: {
      notExist: "Le chemin n'existe pas",
      isDirectory: "Le chemin est un r\xE9pertoire, pas un fichier"
    }
  },
  language: {
    name: "Langue",
    desc: "Changer la langue d'affichage de l'interface du plugin"
  }
};
var fr_default = {
  common: common4,
  settings: settings4
};

// src/i18n/locales/ja.json
var ja_exports = {};
__export(ja_exports, {
  common: () => common5,
  default: () => ja_default,
  settings: () => settings5
});
var common5 = {
  save: "\u4FDD\u5B58",
  cancel: "\u30AD\u30E3\u30F3\u30BB\u30EB",
  delete: "\u524A\u9664",
  edit: "\u7DE8\u96C6",
  add: "\u8FFD\u52A0",
  remove: "\u524A\u9664",
  clear: "\u30AF\u30EA\u30A2",
  clearAll: "\u3059\u3079\u3066\u30AF\u30EA\u30A2",
  loading: "\u8AAD\u307F\u8FBC\u307F\u4E2D",
  error: "\u30A8\u30E9\u30FC",
  success: "\u6210\u529F",
  warning: "\u8B66\u544A",
  confirm: "\u78BA\u8A8D",
  settings: "\u8A2D\u5B9A",
  advanced: "\u8A73\u7D30",
  enabled: "\u6709\u52B9",
  disabled: "\u7121\u52B9",
  platform: "\u30D7\u30E9\u30C3\u30C8\u30D5\u30A9\u30FC\u30E0"
};
var settings5 = {
  title: "Claudian \u8A2D\u5B9A",
  customization: "\u30AB\u30B9\u30BF\u30DE\u30A4\u30BA",
  userName: {
    name: "Claudian \u306F\u3069\u306E\u3088\u3046\u306B\u547C\u3073\u307E\u3059\u304B\uFF1F",
    desc: "\u30D1\u30FC\u30BD\u30CA\u30E9\u30A4\u30BA\u3055\u308C\u305F\u6328\u62F6\u306B\u4F7F\u7528\u3059\u308B\u540D\u524D\uFF08\u7A7A\u6B04\u3067\u4E00\u822C\u306E\u6328\u62F6\uFF09"
  },
  excludedTags: {
    name: "\u9664\u5916\u30BF\u30B0",
    desc: "\u3053\u308C\u3089\u306E\u30BF\u30B0\u3092\u542B\u3080\u30CE\u30FC\u30C8\u306F\u81EA\u52D5\u7684\u306B\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\u3068\u3057\u3066\u8AAD\u307F\u8FBC\u307E\u308C\u307E\u305B\u3093\uFF081\u884C\u306B1\u3064\u3001#\u306A\u3057\uFF09"
  },
  mediaFolder: {
    name: "\u30E1\u30C7\u30A3\u30A2\u30D5\u30A9\u30EB\u30C0",
    desc: "\u6DFB\u4ED8\u30D5\u30A1\u30A4\u30EB/\u753B\u50CF\u3092\u683C\u7D0D\u3059\u308B\u30D5\u30A9\u30EB\u30C0\u3002\u30CE\u30FC\u30C8\u304C ![[image.jpg]] \u3092\u4F7F\u7528\u3059\u308B\u5834\u5408\u3001Claude \u306F\u3053\u3053\u3067\u63A2\u3057\u307E\u3059\u3002\u7A7A\u6B04\u3067\u30EA\u30DD\u30B8\u30C8\u30EA\u306E\u30EB\u30FC\u30C8\u3092\u4F7F\u7528\u3002"
  },
  systemPrompt: {
    name: "\u30AB\u30B9\u30BF\u30E0\u30B7\u30B9\u30C6\u30E0\u30D7\u30ED\u30F3\u30D7\u30C8",
    desc: "\u30C7\u30D5\u30A9\u30EB\u30C8\u306E\u30B7\u30B9\u30C6\u30E0\u30D7\u30ED\u30F3\u30D7\u30C8\u306B\u8FFD\u52A0\u3055\u308C\u308B\u8FFD\u52A0\u6307\u793A"
  },
  autoTitle: {
    name: "\u4F1A\u8A71\u30BF\u30A4\u30C8\u30EB\u3092\u81EA\u52D5\u751F\u6210",
    desc: "\u6700\u521D\u306E\u30E6\u30FC\u30B6\u30FC\u30E1\u30C3\u30BB\u30FC\u30B8\u9001\u4FE1\u5F8C\u306B\u4F1A\u8A71\u30BF\u30A4\u30C8\u30EB\u3092\u81EA\u52D5\u7684\u306B\u751F\u6210\u3057\u307E\u3059\u3002"
  },
  titleModel: {
    name: "\u30BF\u30A4\u30C8\u30EB\u751F\u6210\u30E2\u30C7\u30EB",
    desc: "\u4F1A\u8A71\u30BF\u30A4\u30C8\u30EB\u3092\u81EA\u52D5\u751F\u6210\u3059\u308B\u305F\u3081\u306B\u4F7F\u7528\u3055\u308C\u308B\u30E2\u30C7\u30EB\u3002",
    auto: "\u81EA\u52D5 (Haiku)"
  },
  navMappings: {
    name: "Vim\u30B9\u30BF\u30A4\u30EB\u30CA\u30D3\u30B2\u30FC\u30B7\u30E7\u30F3\u30DE\u30C3\u30D4\u30F3\u30B0",
    desc: '1\u884C\u306B1\u3064\u306E\u30DE\u30C3\u30D4\u30F3\u30B0\u3002\u5F62\u5F0F\uFF1A"map <\u30AD\u30FC> <\u30A2\u30AF\u30B7\u30E7\u30F3>"\uFF08\u30A2\u30AF\u30B7\u30E7\u30F3\uFF1AscrollUp, scrollDown, focusInput\uFF09\u3002'
  },
  hotkeys: "\u30DB\u30C3\u30C8\u30AD\u30FC",
  slashCommands: {
    name: "\u30B9\u30E9\u30C3\u30B7\u30E5\u30B3\u30DE\u30F3\u30C9",
    desc: "/command \u3067\u30C8\u30EA\u30AC\u30FC\u3055\u308C\u308B\u30AB\u30B9\u30BF\u30E0\u30D7\u30ED\u30F3\u30D7\u30C8\u30C6\u30F3\u30D7\u30EC\u30FC\u30C8\u3092\u4F5C\u6210\u3057\u307E\u3059\u3002$ARGUMENTS \u3067\u3059\u3079\u3066\u306E\u5F15\u6570\u3001$1/$2 \u3067\u4F4D\u7F6E\u5F15\u6570\u3001@file \u3067\u30D5\u30A1\u30A4\u30EB\u5185\u5BB9\u3001!`bash` \u3067\u30B3\u30DE\u30F3\u30C9\u51FA\u529B\u3092\u53D6\u5F97\u3067\u304D\u307E\u3059\u3002"
  },
  hiddenSlashCommands: {
    name: "\u975E\u8868\u793A\u30B3\u30DE\u30F3\u30C9",
    desc: "\u30C9\u30ED\u30C3\u30D7\u30C0\u30A6\u30F3\u304B\u3089\u7279\u5B9A\u306E\u30B9\u30E9\u30C3\u30B7\u30E5\u30B3\u30DE\u30F3\u30C9\u3092\u975E\u8868\u793A\u306B\u3057\u307E\u3059\u3002Claudian \u306B\u95A2\u4FC2\u306E\u306A\u3044 Claude Code \u30B3\u30DE\u30F3\u30C9\u3092\u975E\u8868\u793A\u306B\u3059\u308B\u306E\u306B\u4FBF\u5229\u3067\u3059\u3002\u5148\u982D\u306E\u30B9\u30E9\u30C3\u30B7\u30E5\u306A\u3057\u3067\u30B3\u30DE\u30F3\u30C9\u540D\u30921\u884C\u306B1\u3064\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
    placeholder: "commit\nbuild\ntest"
  },
  mcpServers: {
    name: "MCP \u30B5\u30FC\u30D0\u30FC",
    desc: "\u30E2\u30C7\u30EB\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\u30D7\u30ED\u30C8\u30B3\u30EB\u30B5\u30FC\u30D0\u30FC\u3092\u8A2D\u5B9A\u3057\u3001\u5916\u90E8\u30C4\u30FC\u30EB\u3084\u30C7\u30FC\u30BF\u30BD\u30FC\u30B9\u3067 Claude \u306E\u6A5F\u80FD\u3092\u62E1\u5F35\u3057\u307E\u3059\u3002\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\u4FDD\u5B58\u30E2\u30FC\u30C9\u306E\u30B5\u30FC\u30D0\u30FC\u306F @mention \u3067\u30A2\u30AF\u30C6\u30A3\u30D6\u306B\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\u3002"
  },
  plugins: {
    name: "Claude Code \u30D7\u30E9\u30B0\u30A4\u30F3",
    desc: "~/.claude/plugins \u304B\u3089\u691C\u51FA\u3055\u308C\u305F Claude Code \u30D7\u30E9\u30B0\u30A4\u30F3\u3092\u6709\u52B9\u5316\u307E\u305F\u306F\u7121\u52B9\u5316\u3057\u307E\u3059\u3002\u6709\u52B9\u5316\u3055\u308C\u305F\u30D7\u30E9\u30B0\u30A4\u30F3\u306F\u4FDD\u7BA1\u5EAB\u3054\u3068\u306B\u4FDD\u5B58\u3055\u308C\u307E\u3059\u3002"
  },
  safety: "\u30BB\u30AD\u30E5\u30EA\u30C6\u30A3",
  loadUserSettings: {
    name: "\u30E6\u30FC\u30B6\u30FCClaude\u8A2D\u5B9A\u3092\u8AAD\u307F\u8FBC\u3080",
    desc: "~/.claude/settings.json \u3092\u8AAD\u307F\u8FBC\u307F\u307E\u3059\u3002\u6709\u52B9\u306B\u3059\u308B\u3068\u3001\u30E6\u30FC\u30B6\u30FC\u306E Claude Code \u8A31\u53EF\u30EB\u30FC\u30EB\u304C\u30BB\u30AD\u30E5\u30EA\u30C6\u30A3\u30E2\u30FC\u30C9\u3092\u30D0\u30A4\u30D1\u30B9\u3059\u308B\u53EF\u80FD\u6027\u304C\u3042\u308A\u307E\u3059\u3002"
  },
  enableBlocklist: {
    name: "\u30B3\u30DE\u30F3\u30C9\u30D6\u30E9\u30C3\u30AF\u30EA\u30B9\u30C8\u3092\u6709\u52B9\u5316",
    desc: "\u6F5C\u5728\u7684\u306B\u5371\u967A\u306Abash\u30B3\u30DE\u30F3\u30C9\u3092\u30D6\u30ED\u30C3\u30AF"
  },
  blockedCommands: {
    name: "\u30D6\u30ED\u30C3\u30AF\u3055\u308C\u305F\u30B3\u30DE\u30F3\u30C9 ({platform})",
    desc: "{platform} \u3067\u30D6\u30ED\u30C3\u30AF\u3059\u308B\u30D1\u30BF\u30FC\u30F3\uFF081\u884C\u306B1\u3064\uFF09\u3002\u6B63\u898F\u8868\u73FE\u3092\u30B5\u30DD\u30FC\u30C8\u3002",
    unixName: "\u30D6\u30ED\u30C3\u30AF\u3055\u308C\u305F\u30B3\u30DE\u30F3\u30C9 (Unix/Git Bash)",
    unixDesc: "Git Bash\u304C\u547C\u3073\u51FA\u305B\u308B\u305F\u3081\u3001Unix\u30D1\u30BF\u30FC\u30F3\u3082Windows\u4E0A\u3067\u30D6\u30ED\u30C3\u30AF\u3055\u308C\u307E\u3059\u3002"
  },
  exportPaths: {
    name: "\u8A31\u53EF\u3055\u308C\u305F\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u30D1\u30B9",
    desc: "\u30D5\u30A1\u30A4\u30EB\u3092\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u3067\u304D\u308B\u30EA\u30DD\u30B8\u30C8\u30EA\u5916\u306E\u30D1\u30B9\uFF081\u884C\u306B1\u3064\uFF09\u3002~ \u3067\u30DB\u30FC\u30E0\u30C7\u30A3\u30EC\u30AF\u30C8\u30EA\u3092\u30B5\u30DD\u30FC\u30C8\u3002"
  },
  environment: "\u74B0\u5883",
  customVariables: {
    name: "\u30AB\u30B9\u30BF\u30E0\u5909\u6570",
    desc: "Claude SDK\u306E\u74B0\u5883\u5909\u6570\uFF08KEY=VALUE\u5F62\u5F0F\u30011\u884C\u306B1\u3064\uFF09\u3002export\u30D7\u30EC\u30D5\u30A3\u30C3\u30AF\u30B9\u5BFE\u5FDC\u3002"
  },
  envSnippets: {
    name: "\u30B9\u30CB\u30DA\u30C3\u30C8",
    addBtn: "\u30B9\u30CB\u30DA\u30C3\u30C8\u3092\u8FFD\u52A0",
    noSnippets: "\u4FDD\u5B58\u3055\u308C\u305F\u74B0\u5883\u5909\u6570\u30B9\u30CB\u30DA\u30C3\u30C8\u306F\u3042\u308A\u307E\u305B\u3093\u3002+\u3092\u30AF\u30EA\u30C3\u30AF\u3057\u3066\u73FE\u5728\u306E\u8A2D\u5B9A\u3092\u4FDD\u5B58\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
    nameRequired: "\u30B9\u30CB\u30DA\u30C3\u30C8\u306E\u540D\u524D\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044",
    modal: {
      titleEdit: "\u30B9\u30CB\u30DA\u30C3\u30C8\u3092\u7DE8\u96C6",
      titleSave: "\u30B9\u30CB\u30DA\u30C3\u30C8\u3092\u4FDD\u5B58",
      name: "\u540D\u524D",
      namePlaceholder: "\u3053\u306E\u8A2D\u5B9A\u306E\u308F\u304B\u308A\u3084\u3059\u3044\u540D\u524D",
      description: "\u8AAC\u660E",
      descPlaceholder: "\u4EFB\u610F\u306E\u8AAC\u660E",
      envVars: "\u74B0\u5883\u5909\u6570",
      envVarsPlaceholder: "KEY=VALUE\u5F62\u5F0F\u30011\u884C\u306B1\u3064\uFF08export\u30D7\u30EC\u30D5\u30A3\u30C3\u30AF\u30B9\u5BFE\u5FDC\uFF09",
      save: "\u4FDD\u5B58",
      update: "\u66F4\u65B0",
      cancel: "\u30AD\u30E3\u30F3\u30BB\u30EB"
    }
  },
  customContextLimits: {
    name: "\u30AB\u30B9\u30BF\u30E0\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\u5236\u9650",
    desc: "\u30AB\u30B9\u30BF\u30E0\u30E2\u30C7\u30EB\u306E\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\u30A6\u30A3\u30F3\u30C9\u30A6\u30B5\u30A4\u30BA\u3092\u8A2D\u5B9A\u3057\u307E\u3059\u3002\u30C7\u30D5\u30A9\u30EB\u30C8\uFF08200k\u30C8\u30FC\u30AF\u30F3\uFF09\u3092\u4F7F\u7528\u3059\u308B\u5834\u5408\u306F\u7A7A\u6B04\u306E\u307E\u307E\u306B\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
    invalid: "\u7121\u52B9\u306A\u5F62\u5F0F\u3067\u3059\u3002\u4F7F\u7528\uFF1A256k\u30011m\u3001\u307E\u305F\u306F\u6B63\u78BA\u306A\u6570\u5024\uFF081000-10000000\uFF09\u3002"
  },
  advanced: "\u8A73\u7D30\u8A2D\u5B9A",
  show1MModel: {
    name: "1M\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\u30A6\u30A3\u30F3\u30C9\u30A6\u3092\u6301\u3064Sonnet\u3092\u6709\u52B9\u5316",
    desc: "\u30E2\u30C7\u30EB\u30BB\u30EC\u30AF\u30BF\u30FC\u3067\u6A19\u6E96Sonnet\u3092 Sonnet (1M) \u306B\u7F6E\u304D\u63DB\u3048\u307E\u3059\u3002200k\u30C8\u30FC\u30AF\u30F3\u672A\u6E80\u3067\u306F\u540C\u3058\u4FA1\u683C\u3002Max\u30B5\u30D6\u30B9\u30AF\u30EA\u30D7\u30B7\u30E7\u30F3\u304C\u5FC5\u8981\u3067\u3059\u3002"
  },
  enableChrome: {
    name: "Chrome\u62E1\u5F35\u6A5F\u80FD\u3092\u6709\u52B9\u5316",
    desc: "claude-in-chrome\u62E1\u5F35\u6A5F\u80FD\u3092\u901A\u3058\u3066Claude\u304CChrome\u3068\u9023\u643A\u3067\u304D\u308B\u3088\u3046\u306B\u3057\u307E\u3059\u3002\u62E1\u5F35\u6A5F\u80FD\u306E\u30A4\u30F3\u30B9\u30C8\u30FC\u30EB\u304C\u5FC5\u8981\u3067\u3059\u3002\u30BB\u30C3\u30B7\u30E7\u30F3\u306E\u518D\u8D77\u52D5\u304C\u5FC5\u8981\u3067\u3059\u3002"
  },
  maxTabs: {
    name: "\u6700\u5927\u30C1\u30E3\u30C3\u30C8\u30BF\u30D6\u6570",
    desc: "\u540C\u6642\u306B\u958B\u3051\u308B\u6700\u5927\u30C1\u30E3\u30C3\u30C8\u30BF\u30D6\u6570\uFF083-10\uFF09\u3002\u5404\u30BF\u30D6\u306F\u500B\u5225\u306E Claude \u30BB\u30C3\u30B7\u30E7\u30F3\u3092\u4F7F\u7528\u3057\u307E\u3059\u3002",
    warning: "5 \u30BF\u30D6\u3092\u8D85\u3048\u308B\u3068\u30D1\u30D5\u30A9\u30FC\u30DE\u30F3\u30B9\u3084\u30E1\u30E2\u30EA\u4F7F\u7528\u91CF\u306B\u5F71\u97FF\u3059\u308B\u53EF\u80FD\u6027\u304C\u3042\u308A\u307E\u3059\u3002"
  },
  tabBarPosition: {
    name: "\u30BF\u30D6\u30D0\u30FC\u306E\u4F4D\u7F6E",
    desc: "\u30BF\u30D6\u30D0\u30C3\u30B8\u3068\u30A2\u30AF\u30B7\u30E7\u30F3\u30DC\u30BF\u30F3\u306E\u8868\u793A\u4F4D\u7F6E\u3092\u9078\u629E",
    input: "\u5165\u529B\u6B04\u306E\u4E0A\uFF08\u30C7\u30D5\u30A9\u30EB\u30C8\uFF09",
    header: "\u30D8\u30C3\u30C0\u30FC\u5185"
  },
  enableAutoScroll: {
    name: "\u30B9\u30C8\u30EA\u30FC\u30DF\u30F3\u30B0\u4E2D\u306E\u81EA\u52D5\u30B9\u30AF\u30ED\u30FC\u30EB",
    desc: "Claude\u304C\u5FDC\u7B54\u3092\u30B9\u30C8\u30EA\u30FC\u30DF\u30F3\u30B0\u3057\u3066\u3044\u308B\u9593\u3001\u81EA\u52D5\u7684\u306B\u4E0B\u306B\u30B9\u30AF\u30ED\u30FC\u30EB\u3057\u307E\u3059\u3002\u7121\u52B9\u306B\u3059\u308B\u3068\u4E0A\u90E8\u306B\u7559\u307E\u308A\u3001\u6700\u521D\u304B\u3089\u8AAD\u3080\u3053\u3068\u304C\u3067\u304D\u307E\u3059\u3002"
  },
  cliPath: {
    name: "Claude CLI \u30D1\u30B9",
    desc: "Claude Code CLI \u306E\u30AB\u30B9\u30BF\u30E0\u30D1\u30B9\u3002\u7A7A\u6B04\u3067\u81EA\u52D5\u691C\u51FA\u3092\u4F7F\u7528\u3002",
    descWindows: "\u30CD\u30A4\u30C6\u30A3\u30D6\u30A4\u30F3\u30B9\u30C8\u30FC\u30E9\u30FC\u306E\u5834\u5408\u306F claude.exe \u3092\u4F7F\u7528\u3002npm/pnpm/yarn \u3084\u305D\u306E\u4ED6\u306E\u30D1\u30C3\u30B1\u30FC\u30B8\u30DE\u30CD\u30FC\u30B8\u30E3\u30FC\u3067\u306E\u30A4\u30F3\u30B9\u30C8\u30FC\u30EB\u306E\u5834\u5408\u306F cli.js \u30D1\u30B9\u3092\u4F7F\u7528\uFF08claude.cmd \u3067\u306F\u306A\u3044\uFF09\u3002",
    descUnix: '"which claude" \u306E\u51FA\u529B\u3092\u8CBC\u308A\u4ED8\u3051\u3066\u304F\u3060\u3055\u3044 - \u30CD\u30A4\u30C6\u30A3\u30D6\u3068 npm/pnpm/yarn \u30A4\u30F3\u30B9\u30C8\u30FC\u30EB\u306E\u4E21\u65B9\u3067\u52D5\u4F5C\u3057\u307E\u3059\u3002',
    validation: {
      notExist: "\u30D1\u30B9\u304C\u5B58\u5728\u3057\u307E\u305B\u3093",
      isDirectory: "\u30D1\u30B9\u306F\u30C7\u30A3\u30EC\u30AF\u30C8\u30EA\u3067\u30D5\u30A1\u30A4\u30EB\u3067\u306F\u3042\u308A\u307E\u305B\u3093"
    }
  },
  language: {
    name: "\u8A00\u8A9E",
    desc: "\u30D7\u30E9\u30B0\u30A4\u30F3\u30A4\u30F3\u30BF\u30FC\u30D5\u30A7\u30FC\u30B9\u306E\u8868\u793A\u8A00\u8A9E\u3092\u5909\u66F4"
  }
};
var ja_default = {
  common: common5,
  settings: settings5
};

// src/i18n/locales/ko.json
var ko_exports = {};
__export(ko_exports, {
  common: () => common6,
  default: () => ko_default,
  settings: () => settings6
});
var common6 = {
  save: "\uC800\uC7A5",
  cancel: "\uCDE8\uC18C",
  delete: "\uC0AD\uC81C",
  edit: "\uD3B8\uC9D1",
  add: "\uCD94\uAC00",
  remove: "\uC81C\uAC70",
  clear: "\uC9C0\uC6B0\uAE30",
  clearAll: "\uBAA8\uB450 \uC9C0\uC6B0\uAE30",
  loading: "\uB85C\uB529 \uC911",
  error: "\uC624\uB958",
  success: "\uC131\uACF5",
  warning: "\uACBD\uACE0",
  confirm: "\uD655\uC778",
  settings: "\uC124\uC815",
  advanced: "\uACE0\uAE09",
  enabled: "\uD65C\uC131\uD654",
  disabled: "\uBE44\uD65C\uC131\uD654",
  platform: "\uD50C\uB7AB\uD3FC"
};
var settings6 = {
  title: "Claudian \uC124\uC815",
  customization: "\uC0AC\uC6A9\uC790 \uC815\uC758",
  userName: {
    name: "Claudian\uC774 \uB2F9\uC2E0\uC744 \uC5B4\uB5BB\uAC8C \uBD88\uB7EC\uC57C \uD569\uB2C8\uAE4C?",
    desc: "\uAC1C\uC778\uD654\uB41C \uC778\uC0AC\uC5D0 \uC0AC\uC6A9\uD560 \uC774\uB984 (\uBE44\uC6CC\uB450\uBA74 \uC77C\uBC18 \uC778\uC0AC)"
  },
  excludedTags: {
    name: "\uC81C\uC678 \uD0DC\uADF8",
    desc: "\uC774 \uD0DC\uADF8\uAC00 \uD3EC\uD568\uB41C \uB178\uD2B8\uB294 \uC790\uB3D9\uC73C\uB85C \uCEE8\uD14D\uC2A4\uD2B8\uB85C \uB85C\uB4DC\uB418\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4 (\uD55C \uC904\uC5D0 \uD558\uB098, # \uC81C\uC678)"
  },
  mediaFolder: {
    name: "\uBBF8\uB514\uC5B4 \uD3F4\uB354",
    desc: "\uCCA8\uBD80 \uD30C\uC77C/\uC774\uBBF8\uC9C0\uB97C \uC800\uC7A5\uD560 \uD3F4\uB354. \uB178\uD2B8\uAC00 ![[image.jpg]]\uB97C \uC0AC\uC6A9\uD560 \uB54C Claude\uAC00 \uC5EC\uAE30\uC11C \uCC3E\uC2B5\uB2C8\uB2E4. \uBE44\uC6CC\uB450\uBA74 \uC800\uC7A5\uC18C \uB8E8\uD2B8 \uC0AC\uC6A9."
  },
  systemPrompt: {
    name: "\uCEE4\uC2A4\uD140 \uC2DC\uC2A4\uD15C \uD504\uB86C\uD504\uD2B8",
    desc: "\uAE30\uBCF8 \uC2DC\uC2A4\uD15C \uD504\uB86C\uD504\uD2B8\uC5D0 \uCD94\uAC00\uB418\uB294 \uCD94\uAC00 \uC9C0\uCE68"
  },
  autoTitle: {
    name: "\uB300\uD654 \uC81C\uBAA9 \uC790\uB3D9 \uC0DD\uC131",
    desc: "\uCCAB \uBC88\uC9F8 \uC0AC\uC6A9\uC790 \uBA54\uC2DC\uC9C0 \uC804\uC1A1 \uD6C4 \uC790\uB3D9\uC73C\uB85C \uB300\uD654 \uC81C\uBAA9\uC744 \uC0DD\uC131\uD569\uB2C8\uB2E4."
  },
  titleModel: {
    name: "\uC81C\uBAA9 \uC0DD\uC131 \uBAA8\uB378",
    desc: "\uB300\uD654 \uC81C\uBAA9\uC744 \uC790\uB3D9 \uC0DD\uC131\uD558\uB294 \uB370 \uC0AC\uC6A9\uB418\uB294 \uBAA8\uB378.",
    auto: "\uC790\uB3D9 (Haiku)"
  },
  navMappings: {
    name: "Vim \uC2A4\uD0C0\uC77C \uB124\uBE44\uAC8C\uC774\uC158 \uB9E4\uD551",
    desc: '\uD55C \uC904\uC5D0 \uD558\uB098\uC758 \uB9E4\uD551. \uD615\uC2DD: "map <\uD0A4> <\uB3D9\uC791>" (\uB3D9\uC791: scrollUp, scrollDown, focusInput).'
  },
  hotkeys: "\uB2E8\uCD95\uD0A4",
  slashCommands: {
    name: "\uC2AC\uB798\uC2DC \uBA85\uB839\uC5B4",
    desc: "/command\uB85C \uD2B8\uB9AC\uAC70\uB418\uB294 \uCEE4\uC2A4\uD140 \uD504\uB86C\uD504\uD2B8 \uD15C\uD50C\uB9BF\uC744 \uC0DD\uC131\uD569\uB2C8\uB2E4. $ARGUMENTS\uB85C \uBAA8\uB4E0 \uC778\uC790, $1/$2\uB85C \uC704\uCE58 \uC778\uC790, @file\uB85C \uD30C\uC77C \uB0B4\uC6A9, !`bash`\uB85C \uBA85\uB839\uC5B4 \uCD9C\uB825\uC744 \uAC00\uC838\uC62C \uC218 \uC788\uC2B5\uB2C8\uB2E4."
  },
  hiddenSlashCommands: {
    name: "\uC228\uACA8\uC9C4 \uBA85\uB839\uC5B4",
    desc: "\uB4DC\uB86D\uB2E4\uC6B4\uC5D0\uC11C \uD2B9\uC815 \uC2AC\uB798\uC2DC \uBA85\uB839\uC5B4\uB97C \uC228\uAE41\uB2C8\uB2E4. Claudian\uACFC \uAD00\uB828 \uC5C6\uB294 Claude Code \uBA85\uB839\uC5B4\uB97C \uC228\uAE30\uB294 \uB370 \uC720\uC6A9\uD569\uB2C8\uB2E4. \uC55E\uC758 \uC2AC\uB798\uC2DC \uC5C6\uC774 \uD55C \uC904\uC5D0 \uD558\uB098\uC529 \uBA85\uB839\uC5B4 \uC774\uB984\uC744 \uC785\uB825\uD558\uC138\uC694.",
    placeholder: "commit\nbuild\ntest"
  },
  mcpServers: {
    name: "MCP \uC11C\uBC84",
    desc: "\uBAA8\uB378 \uCEE8\uD14D\uC2A4\uD2B8 \uD504\uB85C\uD1A0\uCF5C \uC11C\uBC84\uB97C \uC124\uC815\uD558\uC5EC \uC678\uBD80 \uB3C4\uAD6C\uC640 \uB370\uC774\uD130 \uC18C\uC2A4\uB85C Claude\uC758 \uAE30\uB2A5\uC744 \uD655\uC7A5\uD569\uB2C8\uB2E4. \uCEE8\uD14D\uC2A4\uD2B8 \uC800\uC7A5 \uBAA8\uB4DC \uC11C\uBC84\uB294 @mention\uC73C\uB85C \uD65C\uC131\uD654\uD574\uC57C \uD569\uB2C8\uB2E4."
  },
  plugins: {
    name: "Claude Code \uD50C\uB7EC\uADF8\uC778",
    desc: "~/.claude/plugins\uC5D0\uC11C \uBC1C\uACAC\uB41C Claude Code \uD50C\uB7EC\uADF8\uC778\uC744 \uD65C\uC131\uD654 \uB610\uB294 \uBE44\uD65C\uC131\uD654\uD569\uB2C8\uB2E4. \uD65C\uC131\uD654\uB41C \uD50C\uB7EC\uADF8\uC778\uC740 \uBCFC\uD2B8\uBCC4\uB85C \uC800\uC7A5\uB429\uB2C8\uB2E4."
  },
  safety: "\uBCF4\uC548",
  loadUserSettings: {
    name: "\uC0AC\uC6A9\uC790 Claude \uC124\uC815 \uB85C\uB4DC",
    desc: "~/.claude/settings.json\uC744 \uB85C\uB4DC\uD569\uB2C8\uB2E4. \uD65C\uC131\uD654\uD558\uBA74 \uC0AC\uC6A9\uC790\uC758 Claude Code \uD5C8\uC6A9 \uADDC\uCE59\uC774 \uBCF4\uC548 \uBAA8\uB4DC\uB97C \uC6B0\uD68C\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4."
  },
  enableBlocklist: {
    name: "\uBA85\uB839\uC5B4 \uBE14\uB799\uB9AC\uC2A4\uD2B8 \uD65C\uC131\uD654",
    desc: "\uC7A0\uC7AC\uC801\uC73C\uB85C \uC704\uD5D8\uD55C bash \uBA85\uB839\uC5B4 \uCC28\uB2E8"
  },
  blockedCommands: {
    name: "\uCC28\uB2E8\uB41C \uBA85\uB839\uC5B4 ({platform})",
    desc: "{platform}\uC5D0\uC11C \uCC28\uB2E8\uD560 \uD328\uD134 (\uD55C \uC904\uC5D0 \uD558\uB098). \uC815\uADDC\uC2DD \uC9C0\uC6D0.",
    unixName: "\uCC28\uB2E8\uB41C \uBA85\uB839\uC5B4 (Unix/Git Bash)",
    unixDesc: "Git Bash\uAC00 \uD638\uCD9C\uD560 \uC218 \uC788\uC73C\uBBC0\uB85C Unix \uD328\uD134\uB3C4 Windows\uC5D0\uC11C \uCC28\uB2E8\uB429\uB2C8\uB2E4."
  },
  exportPaths: {
    name: "\uD5C8\uC6A9\uB41C \uB0B4\uBCF4\uB0B4\uAE30 \uACBD\uB85C",
    desc: "\uD30C\uC77C\uC744 \uB0B4\uBCF4\uB0BC \uC218 \uC788\uB294 \uC800\uC7A5\uC18C \uC678\uBD80 \uACBD\uB85C (\uD55C \uC904\uC5D0 \uD558\uB098). ~\uB85C \uD648 \uB514\uB809\uD1A0\uB9AC \uC9C0\uC6D0."
  },
  environment: "\uD658\uACBD",
  customVariables: {
    name: "\uCEE4\uC2A4\uD140 \uBCC0\uC218",
    desc: "Claude SDK \uD658\uACBD \uBCC0\uC218 (KEY=VALUE \uD615\uC2DD, \uD55C \uC904\uC5D0 \uD558\uB098). export \uC811\uB450\uC0AC \uC9C0\uC6D0."
  },
  envSnippets: {
    name: "\uC2A4\uB2C8\uD3AB",
    addBtn: "\uC2A4\uB2C8\uD3AB \uCD94\uAC00",
    noSnippets: "\uC800\uC7A5\uB41C \uD658\uACBD \uBCC0\uC218 \uC2A4\uB2C8\uD3AB\uC774 \uC5C6\uC2B5\uB2C8\uB2E4. +\uB97C \uD074\uB9AD\uD558\uC5EC \uD604\uC7AC \uAD6C\uC131\uC744 \uC800\uC7A5\uD558\uC138\uC694.",
    nameRequired: "\uC2A4\uB2C8\uD3AB \uC774\uB984\uC744 \uC785\uB825\uD558\uC138\uC694",
    modal: {
      titleEdit: "\uC2A4\uB2C8\uD3AB \uD3B8\uC9D1",
      titleSave: "\uC2A4\uB2C8\uD3AB \uC800\uC7A5",
      name: "\uC774\uB984",
      namePlaceholder: "\uC774 \uAD6C\uC131\uC5D0 \uB300\uD55C \uC124\uBA85\uC801\uC778 \uC774\uB984",
      description: "\uC124\uBA85",
      descPlaceholder: "\uC120\uD0DD\uC801 \uC124\uBA85",
      envVars: "\uD658\uACBD \uBCC0\uC218",
      envVarsPlaceholder: "KEY=VALUE \uD615\uC2DD, \uD55C \uC904\uC5D0 \uD558\uB098 (export \uC811\uB450\uC0AC \uC9C0\uC6D0)",
      save: "\uC800\uC7A5",
      update: "\uC5C5\uB370\uC774\uD2B8",
      cancel: "\uCDE8\uC18C"
    }
  },
  customContextLimits: {
    name: "\uC0AC\uC6A9\uC790 \uC815\uC758 \uCEE8\uD14D\uC2A4\uD2B8 \uC81C\uD55C",
    desc: "\uC0AC\uC6A9\uC790 \uC815\uC758 \uBAA8\uB378\uC758 \uCEE8\uD14D\uC2A4\uD2B8 \uCC3D \uD06C\uAE30\uB97C \uC124\uC815\uD569\uB2C8\uB2E4. \uAE30\uBCF8\uAC12(200k \uD1A0\uD070)\uC744 \uC0AC\uC6A9\uD558\uB824\uBA74 \uBE44\uC6CC\uB450\uC138\uC694.",
    invalid: "\uC798\uBABB\uB41C \uD615\uC2DD\uC785\uB2C8\uB2E4. \uC0AC\uC6A9: 256k, 1m \uB610\uB294 \uC815\uD655\uD55C \uC22B\uC790(1000-10000000)."
  },
  advanced: "\uACE0\uAE09",
  show1MModel: {
    name: "1M \uCEE8\uD14D\uC2A4\uD2B8 \uCC3D\uC744 \uAC00\uC9C4 Sonnet \uD65C\uC131\uD654",
    desc: "\uBAA8\uB378 \uC120\uD0DD\uAE30\uC5D0\uC11C \uD45C\uC900 Sonnet\uC744 Sonnet (1M)\uC73C\uB85C \uAD50\uCCB4\uD569\uB2C8\uB2E4. 200k \uD1A0\uD070 \uBBF8\uB9CC\uC5D0\uC11C\uB294 \uB3D9\uC77C\uD55C \uAC00\uACA9. Max \uAD6C\uB3C5\uC774 \uD544\uC694\uD569\uB2C8\uB2E4."
  },
  enableChrome: {
    name: "Chrome \uD655\uC7A5 \uD504\uB85C\uADF8\uB7A8 \uD65C\uC131\uD654",
    desc: "claude-in-chrome \uD655\uC7A5 \uD504\uB85C\uADF8\uB7A8\uC744 \uD1B5\uD574 Claude\uAC00 Chrome\uACFC \uC0C1\uD638\uC791\uC6A9\uD560 \uC218 \uC788\uB3C4\uB85D \uD569\uB2C8\uB2E4. \uD655\uC7A5 \uD504\uB85C\uADF8\uB7A8\uC774 \uC124\uCE58\uB418\uC5B4 \uC788\uC5B4\uC57C \uD569\uB2C8\uB2E4. \uC138\uC158 \uC7AC\uC2DC\uC791\uC774 \uD544\uC694\uD569\uB2C8\uB2E4."
  },
  maxTabs: {
    name: "\uCD5C\uB300 \uCC44\uD305 \uD0ED \uC218",
    desc: "\uB3D9\uC2DC\uC5D0 \uC5F4 \uC218 \uC788\uB294 \uCD5C\uB300 \uCC44\uD305 \uD0ED \uC218(3-10). \uAC01 \uD0ED\uC740 \uBCC4\uB3C4\uC758 Claude \uC138\uC158\uC744 \uC0AC\uC6A9\uD569\uB2C8\uB2E4.",
    warning: "5\uAC1C \uD0ED\uC744 \uCD08\uACFC\uD558\uBA74 \uC131\uB2A5 \uBC0F \uBA54\uBAA8\uB9AC \uC0AC\uC6A9\uB7C9\uC5D0 \uC601\uD5A5\uC744 \uC904 \uC218 \uC788\uC2B5\uB2C8\uB2E4."
  },
  tabBarPosition: {
    name: "\uD0ED \uBC14 \uC704\uCE58",
    desc: "\uD0ED \uBC30\uC9C0\uC640 \uC791\uC5C5 \uBC84\uD2BC\uC758 \uD45C\uC2DC \uC704\uCE58 \uC120\uD0DD",
    input: "\uC785\uB825\uCC3D \uC704(\uAE30\uBCF8\uAC12)",
    header: "\uD5E4\uB354\uC5D0"
  },
  enableAutoScroll: {
    name: "\uC2A4\uD2B8\uB9AC\uBC0D \uC911 \uC790\uB3D9 \uC2A4\uD06C\uB864",
    desc: "Claude\uAC00 \uC751\uB2F5\uC744 \uC2A4\uD2B8\uB9AC\uBC0D\uD558\uB294 \uB3D9\uC548 \uC790\uB3D9\uC73C\uB85C \uC544\uB798\uB85C \uC2A4\uD06C\uB864\uD569\uB2C8\uB2E4. \uBE44\uD65C\uC131\uD654\uD558\uBA74 \uC0C1\uB2E8\uC5D0 \uBA38\uBB3C\uB7EC \uCC98\uC74C\uBD80\uD130 \uC77D\uC744 \uC218 \uC788\uC2B5\uB2C8\uB2E4."
  },
  cliPath: {
    name: "Claude CLI \uACBD\uB85C",
    desc: "Claude Code CLI\uC758 \uC0AC\uC6A9\uC790 \uC815\uC758 \uACBD\uB85C. \uBE44\uC6CC\uB450\uBA74 \uC790\uB3D9 \uAC10\uC9C0 \uC0AC\uC6A9.",
    descWindows: "\uB124\uC774\uD2F0\uBE0C \uC124\uCE58 \uD504\uB85C\uADF8\uB7A8\uC758 \uACBD\uC6B0 claude.exe\uB97C \uC0AC\uC6A9\uD558\uC138\uC694. npm/pnpm/yarn \uB610\uB294 \uAE30\uD0C0 \uD328\uD0A4\uC9C0 \uAD00\uB9AC\uC790 \uC124\uCE58\uC758 \uACBD\uC6B0 cli.js \uACBD\uB85C\uB97C \uC0AC\uC6A9\uD558\uC138\uC694 (claude.cmd\uAC00 \uC544\uB2D8).",
    descUnix: '"which claude"\uC758 \uCD9C\uB825\uC744 \uBD99\uC5EC\uB123\uC73C\uC138\uC694 - \uB124\uC774\uD2F0\uBE0C \uBC0F npm/pnpm/yarn \uC124\uCE58 \uBAA8\uB450\uC5D0\uC11C \uC791\uB3D9\uD569\uB2C8\uB2E4.',
    validation: {
      notExist: "\uACBD\uB85C\uAC00 \uC874\uC7AC\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4",
      isDirectory: "\uACBD\uB85C\uAC00 \uB514\uB809\uD1A0\uB9AC\uC785\uB2C8\uB2E4 \uD30C\uC77C\uC774 \uC544\uB2D9\uB2C8\uB2E4"
    }
  },
  language: {
    name: "\uC5B8\uC5B4",
    desc: "\uD50C\uB7EC\uADF8\uC778 \uC778\uD130\uD398\uC774\uC2A4\uC758 \uD45C\uC2DC \uC5B8\uC5B4 \uBCC0\uACBD"
  }
};
var ko_default = {
  common: common6,
  settings: settings6
};

// src/i18n/locales/pt.json
var pt_exports = {};
__export(pt_exports, {
  common: () => common7,
  default: () => pt_default,
  settings: () => settings7
});
var common7 = {
  save: "Salvar",
  cancel: "Cancelar",
  delete: "Excluir",
  edit: "Editar",
  add: "Adicionar",
  remove: "Remover",
  clear: "Limpar",
  clearAll: "Limpar tudo",
  loading: "Carregando",
  error: "Erro",
  success: "Sucesso",
  warning: "Aviso",
  confirm: "Confirmar",
  settings: "Configura\xE7\xF5es",
  advanced: "Avan\xE7ado",
  enabled: "Ativado",
  disabled: "Desativado",
  platform: "Plataforma"
};
var settings7 = {
  title: "Configura\xE7\xF5es do Claudian",
  customization: "Personaliza\xE7\xE3o",
  userName: {
    name: "Como o Claudian deve cham\xE1-lo?",
    desc: "Seu nome para sauda\xE7\xF5es personalizadas (deixe vazio para sauda\xE7\xF5es gen\xE9ricas)"
  },
  excludedTags: {
    name: "Tags exclu\xEDdas",
    desc: "Notas com estas tags n\xE3o ser\xE3o carregadas automaticamente como contexto (uma por linha, sem #)"
  },
  mediaFolder: {
    name: "Pasta de m\xEDdia",
    desc: "Pasta contendo anexos/imagens. Quando notas usam ![[image.jpg]], Claude procurar\xE1 aqui. Deixe vazio para a raiz do reposit\xF3rio."
  },
  systemPrompt: {
    name: "Prompt de sistema personalizado",
    desc: "Instru\xE7\xF5es adicionais anexadas ao prompt de sistema padr\xE3o"
  },
  autoTitle: {
    name: "Gerar automaticamente t\xEDtulos de conversa",
    desc: "Gera automaticamente t\xEDtulos de conversa ap\xF3s a primeira mensagem do usu\xE1rio."
  },
  titleModel: {
    name: "Modelo de gera\xE7\xE3o de t\xEDtulo",
    desc: "Modelo usado para gerar automaticamente t\xEDtulos de conversa.",
    auto: "Auto (Haiku)"
  },
  navMappings: {
    name: "Mapeamentos de navega\xE7\xE3o estilo Vim",
    desc: 'Um mapeamento por linha. Formato: "map <tecla> <a\xE7\xE3o>" (a\xE7\xF5es: scrollUp, scrollDown, focusInput).'
  },
  hotkeys: "Atalhos",
  slashCommands: {
    name: "Comandos slash",
    desc: "Crie modelos de prompts personalizados acionados por /command. Use $ARGUMENTS para todos os argumentos, $1/$2 para argumentos posicionais, @file para conte\xFAdo de arquivo e !`bash` para sa\xEDda de comando."
  },
  hiddenSlashCommands: {
    name: "Comandos ocultos",
    desc: "Ocultar comandos slash espec\xEDficos do menu suspenso. \xDAtil para ocultar comandos do Claude Code que n\xE3o s\xE3o relevantes para o Claudian. Digite os nomes dos comandos sem a barra inicial, um por linha.",
    placeholder: "commit\nbuild\ntest"
  },
  mcpServers: {
    name: "Servidores MCP",
    desc: "Configure servidores Model Context Protocol para estender as capacidades do Claude com ferramentas e fontes de dados externas. Servidores com modo de salvamento de contexto exigem @mention para ativar."
  },
  plugins: {
    name: "Plugins do Claude Code",
    desc: "Ative ou desative plugins do Claude Code descobertos em ~/.claude/plugins. Plugins ativados s\xE3o armazenados por cofre."
  },
  safety: "Seguran\xE7a",
  loadUserSettings: {
    name: "Carregar configura\xE7\xF5es do usu\xE1rio Claude",
    desc: "Carrega ~/.claude/settings.json. Quando habilitado, as regras de permiss\xE3o do usu\xE1rio podem ignorar o modo seguro."
  },
  enableBlocklist: {
    name: "Habilitar lista negra de comandos",
    desc: "Bloqueia comandos bash potencialmente perigosos"
  },
  blockedCommands: {
    name: "Comandos bloqueados ({platform})",
    desc: "Padr\xF5es para bloquear em {platform} (um por linha). Suporta express\xF5es regulares.",
    unixName: "Comandos bloqueados (Unix/Git Bash)",
    unixDesc: "Padr\xF5es Unix tamb\xE9m bloqueados no Windows porque Git Bash pode invoc\xE1-los."
  },
  exportPaths: {
    name: "Caminhos de exporta\xE7\xE3o permitidos",
    desc: "Caminhos fora do reposit\xF3rio onde arquivos podem ser exportados (um por linha). Suporta ~ para diret\xF3rio home."
  },
  environment: "Ambiente",
  customVariables: {
    name: "Vari\xE1veis personalizadas",
    desc: "Vari\xE1veis de ambiente para Claude SDK (formato KEY=VALUE, uma por linha). Prefixo export suportado."
  },
  envSnippets: {
    name: "Snippets",
    addBtn: "Adicionar snippet",
    noSnippets: "Nenhum snippet de ambiente salvo. Clique em + para salvar sua configura\xE7\xE3o atual.",
    nameRequired: "Por favor, insira um nome para o snippet",
    modal: {
      titleEdit: "Editar snippet",
      titleSave: "Salvar snippet",
      name: "Nome",
      namePlaceholder: "Um nome descritivo para esta configura\xE7\xE3o",
      description: "Descri\xE7\xE3o",
      descPlaceholder: "Descri\xE7\xE3o opcional",
      envVars: "Vari\xE1veis de ambiente",
      envVarsPlaceholder: "Formato KEY=VALUE, uma por linha (prefixo export suportado)",
      save: "Salvar",
      update: "Atualizar",
      cancel: "Cancelar"
    }
  },
  customContextLimits: {
    name: "Limites de contexto personalizados",
    desc: "Defina tamanhos de janela de contexto para seus modelos personalizados. Deixe vazio para usar o padr\xE3o (200k tokens).",
    invalid: "Formato inv\xE1lido. Use: 256k, 1m ou n\xFAmero exato (1000-10000000)."
  },
  advanced: "Avan\xE7ado",
  show1MModel: {
    name: "Habilitar Sonnet com janela de contexto de 1M",
    desc: "Substituir Sonnet padr\xE3o por Sonnet (1M) no seletor de modelos. Mesmo pre\xE7o abaixo de 200k tokens. Requer assinatura Max."
  },
  enableChrome: {
    name: "Habilitar extens\xE3o do Chrome",
    desc: "Permitir que o Claude interaja com o Chrome atrav\xE9s da extens\xE3o claude-in-chrome. Requer que a extens\xE3o esteja instalada. Requer rein\xEDcio de sess\xE3o."
  },
  maxTabs: {
    name: "M\xE1ximo de abas de chat",
    desc: "N\xFAmero m\xE1ximo de abas de chat simult\xE2neas (3-10). Cada aba usa uma sess\xE3o Claude separada.",
    warning: "Mais de 5 abas pode afetar o desempenho e o uso de mem\xF3ria."
  },
  tabBarPosition: {
    name: "Posi\xE7\xE3o da barra de abas",
    desc: "Escolha onde exibir os emblemas de abas e bot\xF5es de a\xE7\xE3o",
    input: "Acima da entrada (padr\xE3o)",
    header: "No cabe\xE7alho"
  },
  enableAutoScroll: {
    name: "Rolagem autom\xE1tica durante streaming",
    desc: "Rolar automaticamente para baixo enquanto o Claude transmite respostas. Desativar para ficar no topo e ler desde o in\xEDcio."
  },
  cliPath: {
    name: "Caminho CLI Claude",
    desc: "Caminho personalizado para Claude Code CLI. Deixe vazio para detec\xE7\xE3o autom\xE1tica.",
    descWindows: "Para o instalador nativo, use claude.exe. Para instala\xE7\xF5es com npm/pnpm/yarn ou outros gerenciadores de pacotes, use o caminho cli.js (n\xE3o claude.cmd).",
    descUnix: 'Cole a sa\xEDda de "which claude" \u2014 funciona tanto para instala\xE7\xF5es nativas quanto npm/pnpm/yarn.',
    validation: {
      notExist: "Caminho n\xE3o existe",
      isDirectory: "Caminho \xE9 um diret\xF3rio, n\xE3o um arquivo"
    }
  },
  language: {
    name: "Idioma",
    desc: "Alterar o idioma de exibi\xE7\xE3o da interface do plugin"
  }
};
var pt_default = {
  common: common7,
  settings: settings7
};

// src/i18n/locales/ru.json
var ru_exports = {};
__export(ru_exports, {
  common: () => common8,
  default: () => ru_default,
  settings: () => settings8
});
var common8 = {
  save: "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C",
  cancel: "\u041E\u0442\u043C\u0435\u043D\u0430",
  delete: "\u0423\u0434\u0430\u043B\u0438\u0442\u044C",
  edit: "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C",
  add: "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C",
  remove: "\u0423\u0434\u0430\u043B\u0438\u0442\u044C",
  clear: "\u041E\u0447\u0438\u0441\u0442\u0438\u0442\u044C",
  clearAll: "\u041E\u0447\u0438\u0441\u0442\u0438\u0442\u044C \u0432\u0441\u0451",
  loading: "\u0417\u0430\u0433\u0440\u0443\u0437\u043A\u0430",
  error: "\u041E\u0448\u0438\u0431\u043A\u0430",
  success: "\u0423\u0441\u043F\u0435\u0445",
  warning: "\u041F\u0440\u0435\u0434\u0443\u043F\u0440\u0435\u0436\u0434\u0435\u043D\u0438\u0435",
  confirm: "\u041F\u043E\u0434\u0442\u0432\u0435\u0440\u0434\u0438\u0442\u044C",
  settings: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438",
  advanced: "\u0414\u043E\u043F\u043E\u043B\u043D\u0438\u0442\u0435\u043B\u044C\u043D\u043E",
  enabled: "\u0412\u043A\u043B\u044E\u0447\u0435\u043D\u043E",
  disabled: "\u041E\u0442\u043A\u043B\u044E\u0447\u0435\u043D\u043E",
  platform: "\u041F\u043B\u0430\u0442\u0444\u043E\u0440\u043C\u0430"
};
var settings8 = {
  title: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 Claudian",
  customization: "\u041F\u0435\u0440\u0441\u043E\u043D\u0430\u043B\u0438\u0437\u0430\u0446\u0438\u044F",
  userName: {
    name: "\u041A\u0430\u043A Claudian \u0434\u043E\u043B\u0436\u0435\u043D \u043E\u0431\u0440\u0430\u0449\u0430\u0442\u044C\u0441\u044F \u043A \u0432\u0430\u043C?",
    desc: "\u0412\u0430\u0448\u0435 \u0438\u043C\u044F \u0434\u043B\u044F \u043F\u0435\u0440\u0441\u043E\u043D\u0430\u043B\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0445 \u043F\u0440\u0438\u0432\u0435\u0442\u0441\u0442\u0432\u0438\u0439 (\u043E\u0441\u0442\u0430\u0432\u044C\u0442\u0435 \u043F\u0443\u0441\u0442\u044B\u043C \u0434\u043B\u044F \u043E\u0431\u0449\u0438\u0445 \u043F\u0440\u0438\u0432\u0435\u0442\u0441\u0442\u0432\u0438\u0439)"
  },
  excludedTags: {
    name: "\u0418\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u043D\u044B\u0435 \u0442\u0435\u0433\u0438",
    desc: "\u0417\u0430\u043C\u0435\u0442\u043A\u0438 \u0441 \u044D\u0442\u0438\u043C\u0438 \u0442\u0435\u0433\u0430\u043C\u0438 \u043D\u0435 \u0431\u0443\u0434\u0443\u0442 \u0430\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438 \u0437\u0430\u0433\u0440\u0443\u0436\u0430\u0442\u044C\u0441\u044F \u043A\u0430\u043A \u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442 (\u043F\u043E \u043E\u0434\u043D\u043E\u043C\u0443 \u0432 \u0441\u0442\u0440\u043E\u043A\u0435, \u0431\u0435\u0437 #)"
  },
  mediaFolder: {
    name: "\u041F\u0430\u043F\u043A\u0430 \u043C\u0435\u0434\u0438\u0430\u0444\u0430\u0439\u043B\u043E\u0432",
    desc: "\u041F\u0430\u043F\u043A\u0430 \u0441 \u0432\u043B\u043E\u0436\u0435\u043D\u0438\u044F\u043C\u0438/\u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F\u043C\u0438. \u041A\u043E\u0433\u0434\u0430 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u044E\u0442 ![[image.jpg]], Claude \u0431\u0443\u0434\u0435\u0442 \u0438\u0441\u043A\u0430\u0442\u044C \u0437\u0434\u0435\u0441\u044C. \u041E\u0441\u0442\u0430\u0432\u044C\u0442\u0435 \u043F\u0443\u0441\u0442\u044B\u043C \u0434\u043B\u044F \u043A\u043E\u0440\u043D\u044F \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0430."
  },
  systemPrompt: {
    name: "\u041F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u0438\u0439 \u0441\u0438\u0441\u0442\u0435\u043C\u043D\u044B\u0439 \u043F\u0440\u043E\u043C\u043F\u0442",
    desc: "\u0414\u043E\u043F\u043E\u043B\u043D\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0435 \u0438\u043D\u0441\u0442\u0440\u0443\u043A\u0446\u0438\u0438, \u0434\u043E\u0431\u0430\u0432\u043B\u044F\u0435\u043C\u044B\u0435 \u043A \u0441\u0438\u0441\u0442\u0435\u043C\u043D\u043E\u043C\u0443 \u043F\u0440\u043E\u043C\u043F\u0442\u0443 \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E"
  },
  autoTitle: {
    name: "\u0410\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438 \u0433\u0435\u043D\u0435\u0440\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0437\u0430\u0433\u043E\u043B\u043E\u0432\u043A\u0438 \u0431\u0435\u0441\u0435\u0434",
    desc: "\u0410\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438 \u0433\u0435\u043D\u0435\u0440\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0437\u0430\u0433\u043E\u043B\u043E\u0432\u043A\u0438 \u0431\u0435\u0441\u0435\u0434 \u043F\u043E\u0441\u043B\u0435 \u043F\u0435\u0440\u0432\u043E\u0433\u043E \u0441\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u044F \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F."
  },
  titleModel: {
    name: "\u041C\u043E\u0434\u0435\u043B\u044C \u0433\u0435\u043D\u0435\u0440\u0430\u0446\u0438\u0438 \u0437\u0430\u0433\u043E\u043B\u043E\u0432\u043A\u043E\u0432",
    desc: "\u041C\u043E\u0434\u0435\u043B\u044C, \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0435\u043C\u0430\u044F \u0434\u043B\u044F \u0430\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u043E\u0439 \u0433\u0435\u043D\u0435\u0440\u0430\u0446\u0438\u0438 \u0437\u0430\u0433\u043E\u043B\u043E\u0432\u043A\u043E\u0432 \u0431\u0435\u0441\u0435\u0434.",
    auto: "\u0410\u0432\u0442\u043E (Haiku)"
  },
  navMappings: {
    name: "\u0421\u043E\u043F\u043E\u0441\u0442\u0430\u0432\u043B\u0435\u043D\u0438\u044F \u043D\u0430\u0432\u0438\u0433\u0430\u0446\u0438\u0438 \u0432 \u0441\u0442\u0438\u043B\u0435 Vim",
    desc: '\u041F\u043E \u043E\u0434\u043D\u043E\u043C\u0443 \u0441\u043E\u043F\u043E\u0441\u0442\u0430\u0432\u043B\u0435\u043D\u0438\u044E \u0432 \u0441\u0442\u0440\u043E\u043A\u0435. \u0424\u043E\u0440\u043C\u0430\u0442: "map <\u043A\u043B\u044E\u0447> <\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435>" (\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044F: scrollUp, scrollDown, focusInput).'
  },
  hotkeys: "\u0413\u043E\u0440\u044F\u0447\u0438\u0435 \u043A\u043B\u0430\u0432\u0438\u0448\u0438",
  slashCommands: {
    name: "\u041A\u043E\u043C\u0430\u043D\u0434\u044B \u0441\u043E \u0441\u043B\u044D\u0448\u0435\u043C",
    desc: "\u0421\u043E\u0437\u0434\u0430\u0432\u0430\u0439\u0442\u0435 \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u0438\u0435 \u0448\u0430\u0431\u043B\u043E\u043D\u044B \u043F\u0440\u043E\u043C\u043F\u0442\u043E\u0432, \u0437\u0430\u043F\u0443\u0441\u043A\u0430\u0435\u043C\u044B\u0435 \u0447\u0435\u0440\u0435\u0437 /command. \u0418\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0439\u0442\u0435 $ARGUMENTS \u0434\u043B\u044F \u0432\u0441\u0435\u0445 \u0430\u0440\u0433\u0443\u043C\u0435\u043D\u0442\u043E\u0432, $1/$2 \u0434\u043B\u044F \u043F\u043E\u0437\u0438\u0446\u0438\u043E\u043D\u043D\u044B\u0445 \u0430\u0440\u0433\u0443\u043C\u0435\u043D\u0442\u043E\u0432, @file \u0434\u043B\u044F \u0441\u043E\u0434\u0435\u0440\u0436\u0438\u043C\u043E\u0433\u043E \u0444\u0430\u0439\u043B\u0430 \u0438 !`bash` \u0434\u043B\u044F \u0432\u044B\u0432\u043E\u0434\u0430 \u043A\u043E\u043C\u0430\u043D\u0434\u044B."
  },
  hiddenSlashCommands: {
    name: "\u0421\u043A\u0440\u044B\u0442\u044B\u0435 \u043A\u043E\u043C\u0430\u043D\u0434\u044B",
    desc: "\u0421\u043A\u0440\u044B\u0442\u044C \u043E\u043F\u0440\u0435\u0434\u0435\u043B\u0451\u043D\u043D\u044B\u0435 \u043A\u043E\u043C\u0430\u043D\u0434\u044B \u0441\u043E \u0441\u043B\u044D\u0448\u0435\u043C \u0438\u0437 \u0432\u044B\u043F\u0430\u0434\u0430\u044E\u0449\u0435\u0433\u043E \u0441\u043F\u0438\u0441\u043A\u0430. \u041F\u043E\u043B\u0435\u0437\u043D\u043E \u0434\u043B\u044F \u0441\u043A\u0440\u044B\u0442\u0438\u044F \u043A\u043E\u043C\u0430\u043D\u0434 Claude Code, \u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u043D\u0435 \u0430\u043A\u0442\u0443\u0430\u043B\u044C\u043D\u044B \u0434\u043B\u044F Claudian. \u0412\u0432\u043E\u0434\u0438\u0442\u0435 \u0438\u043C\u0435\u043D\u0430 \u043A\u043E\u043C\u0430\u043D\u0434 \u0431\u0435\u0437 \u043D\u0430\u0447\u0430\u043B\u044C\u043D\u043E\u0433\u043E \u0441\u043B\u044D\u0448\u0430, \u043F\u043E \u043E\u0434\u043D\u043E\u0439 \u043D\u0430 \u0441\u0442\u0440\u043E\u043A\u0443.",
    placeholder: "commit\nbuild\ntest"
  },
  mcpServers: {
    name: "MCP \u0441\u0435\u0440\u0432\u0435\u0440\u044B",
    desc: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u0442\u0435 \u0441\u0435\u0440\u0432\u0435\u0440\u044B Model Context Protocol \u0434\u043B\u044F \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043D\u0438\u044F \u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E\u0441\u0442\u0435\u0439 Claude \u0441 \u043F\u043E\u043C\u043E\u0449\u044C\u044E \u0432\u043D\u0435\u0448\u043D\u0438\u0445 \u0438\u043D\u0441\u0442\u0440\u0443\u043C\u0435\u043D\u0442\u043E\u0432 \u0438 \u0438\u0441\u0442\u043E\u0447\u043D\u0438\u043A\u043E\u0432 \u0434\u0430\u043D\u043D\u044B\u0445. \u0421\u0435\u0440\u0432\u0435\u0440\u044B \u0441 \u0440\u0435\u0436\u0438\u043C\u043E\u043C \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u044F \u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442\u0430 \u0442\u0440\u0435\u0431\u0443\u044E\u0442 @mention \u0434\u043B\u044F \u0430\u043A\u0442\u0438\u0432\u0430\u0446\u0438\u0438."
  },
  plugins: {
    name: "\u041F\u043B\u0430\u0433\u0438\u043D\u044B Claude Code",
    desc: "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u0435 \u0438\u043B\u0438 \u043E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u0435 \u043F\u043B\u0430\u0433\u0438\u043D\u044B Claude Code \u0438\u0437 ~/.claude/plugins. \u0412\u043A\u043B\u044E\u0447\u0435\u043D\u043D\u044B\u0435 \u043F\u043B\u0430\u0433\u0438\u043D\u044B \u0441\u043E\u0445\u0440\u0430\u043D\u044F\u044E\u0442\u0441\u044F \u0434\u043B\u044F \u043A\u0430\u0436\u0434\u043E\u0433\u043E \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0430."
  },
  safety: "\u0411\u0435\u0437\u043E\u043F\u0430\u0441\u043D\u043E\u0441\u0442\u044C",
  loadUserSettings: {
    name: "\u0417\u0430\u0433\u0440\u0443\u0436\u0430\u0442\u044C \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u0438\u0435 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 Claude",
    desc: "\u0417\u0430\u0433\u0440\u0443\u0436\u0430\u0435\u0442 ~/.claude/settings.json. \u041F\u0440\u0438 \u0432\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u0438 \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u0438\u0435 \u043F\u0440\u0430\u0432\u0438\u043B\u0430 \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043D\u0438\u0439 Claude Code \u043C\u043E\u0433\u0443\u0442 \u043E\u0431\u0445\u043E\u0434\u0438\u0442\u044C \u0431\u0435\u0437\u043E\u043F\u0430\u0441\u043D\u044B\u0439 \u0440\u0435\u0436\u0438\u043C."
  },
  enableBlocklist: {
    name: "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0447\u0435\u0440\u043D\u044B\u0439 \u0441\u043F\u0438\u0441\u043E\u043A \u043A\u043E\u043C\u0430\u043D\u0434",
    desc: "\u0411\u043B\u043E\u043A\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043F\u043E\u0442\u0435\u043D\u0446\u0438\u0430\u043B\u044C\u043D\u043E \u043E\u043F\u0430\u0441\u043D\u044B\u0435 bash \u043A\u043E\u043C\u0430\u043D\u0434\u044B"
  },
  blockedCommands: {
    name: "\u0417\u0430\u0431\u043B\u043E\u043A\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0435 \u043A\u043E\u043C\u0430\u043D\u0434\u044B ({platform})",
    desc: "\u0428\u0430\u0431\u043B\u043E\u043D\u044B \u0434\u043B\u044F \u0431\u043B\u043E\u043A\u0438\u0440\u043E\u0432\u043A\u0438 \u043D\u0430 {platform} (\u043F\u043E \u043E\u0434\u043D\u043E\u043C\u0443 \u0432 \u0441\u0442\u0440\u043E\u043A\u0435). \u041F\u043E\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u044E\u0442\u0441\u044F \u0440\u0435\u0433\u0443\u043B\u044F\u0440\u043D\u044B\u0435 \u0432\u044B\u0440\u0430\u0436\u0435\u043D\u0438\u044F.",
    unixName: "\u0417\u0430\u0431\u043B\u043E\u043A\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0435 \u043A\u043E\u043C\u0430\u043D\u0434\u044B (Unix/Git Bash)",
    unixDesc: "Unix \u0448\u0430\u0431\u043B\u043E\u043D\u044B \u0442\u0430\u043A\u0436\u0435 \u0431\u043B\u043E\u043A\u0438\u0440\u0443\u044E\u0442\u0441\u044F \u043D\u0430 Windows, \u0442\u0430\u043A \u043A\u0430\u043A Git Bash \u043C\u043E\u0436\u0435\u0442 \u0438\u0445 \u0432\u044B\u0437\u044B\u0432\u0430\u0442\u044C."
  },
  exportPaths: {
    name: "\u0420\u0430\u0437\u0440\u0435\u0448\u0435\u043D\u043D\u044B\u0435 \u043F\u0443\u0442\u0438 \u044D\u043A\u0441\u043F\u043E\u0440\u0442\u0430",
    desc: "\u041F\u0443\u0442\u0438 \u0432\u043D\u0435 \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0430, \u043A\u0443\u0434\u0430 \u043C\u043E\u0436\u043D\u043E \u044D\u043A\u0441\u043F\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0444\u0430\u0439\u043B\u044B (\u043F\u043E \u043E\u0434\u043D\u043E\u043C\u0443 \u0432 \u0441\u0442\u0440\u043E\u043A\u0435). \u041F\u043E\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442 ~ \u0434\u043B\u044F \u0434\u043E\u043C\u0430\u0448\u043D\u0435\u0433\u043E \u043A\u0430\u0442\u0430\u043B\u043E\u0433\u0430."
  },
  environment: "\u041E\u043A\u0440\u0443\u0436\u0435\u043D\u0438\u0435",
  customVariables: {
    name: "\u041F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u0438\u0435 \u043F\u0435\u0440\u0435\u043C\u0435\u043D\u043D\u044B\u0435",
    desc: "\u041F\u0435\u0440\u0435\u043C\u0435\u043D\u043D\u044B\u0435 \u043E\u043A\u0440\u0443\u0436\u0435\u043D\u0438\u044F \u0434\u043B\u044F Claude SDK (\u0444\u043E\u0440\u043C\u0430\u0442 KEY=VALUE, \u043F\u043E \u043E\u0434\u043D\u043E\u0439 \u0432 \u0441\u0442\u0440\u043E\u043A\u0435). \u041F\u0440\u0435\u0444\u0438\u043A\u0441 export \u043F\u043E\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442\u0441\u044F."
  },
  envSnippets: {
    name: "\u0421\u043D\u0438\u043F\u043F\u0435\u0442\u044B",
    addBtn: "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0441\u043D\u0438\u043F\u043F\u0435\u0442",
    noSnippets: "\u041D\u0435\u0442 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u043D\u044B\u0445 \u0441\u043D\u0438\u043F\u043F\u0435\u0442\u043E\u0432 \u043E\u043A\u0440\u0443\u0436\u0435\u043D\u0438\u044F. \u041D\u0430\u0436\u043C\u0438\u0442\u0435 +, \u0447\u0442\u043E\u0431\u044B \u0441\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C \u0442\u0435\u043A\u0443\u0449\u0443\u044E \u043A\u043E\u043D\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044E.",
    nameRequired: "\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0432\u0432\u0435\u0434\u0438\u0442\u0435 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u0441\u043D\u0438\u043F\u043F\u0435\u0442\u0430",
    modal: {
      titleEdit: "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0441\u043D\u0438\u043F\u043F\u0435\u0442",
      titleSave: "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C \u0441\u043D\u0438\u043F\u043F\u0435\u0442",
      name: "\u0418\u043C\u044F",
      namePlaceholder: "\u041E\u043F\u0438\u0441\u0430\u0442\u0435\u043B\u044C\u043D\u043E\u0435 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u0434\u043B\u044F \u044D\u0442\u043E\u0439 \u043A\u043E\u043D\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438",
      description: "\u041E\u043F\u0438\u0441\u0430\u043D\u0438\u0435",
      descPlaceholder: "\u041E\u043F\u0446\u0438\u043E\u043D\u0430\u043B\u044C\u043D\u043E\u0435 \u043E\u043F\u0438\u0441\u0430\u043D\u0438\u0435",
      envVars: "\u041F\u0435\u0440\u0435\u043C\u0435\u043D\u043D\u044B\u0435 \u043E\u043A\u0440\u0443\u0436\u0435\u043D\u0438\u044F",
      envVarsPlaceholder: "\u0424\u043E\u0440\u043C\u0430\u0442 KEY=VALUE, \u043F\u043E \u043E\u0434\u043D\u043E\u0439 \u0432 \u0441\u0442\u0440\u043E\u043A\u0435 (\u043F\u0440\u0435\u0444\u0438\u043A\u0441 export \u043F\u043E\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442\u0441\u044F)",
      save: "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C",
      update: "\u041E\u0431\u043D\u043E\u0432\u0438\u0442\u044C",
      cancel: "\u041E\u0442\u043C\u0435\u043D\u0430"
    }
  },
  customContextLimits: {
    name: "\u041F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u0438\u0435 \u043B\u0438\u043C\u0438\u0442\u044B \u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442\u0430",
    desc: "\u0423\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u0435 \u0440\u0430\u0437\u043C\u0435\u0440\u044B \u043E\u043A\u043D\u0430 \u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442\u0430 \u0434\u043B\u044F \u0432\u0430\u0448\u0438\u0445 \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u0438\u0445 \u043C\u043E\u0434\u0435\u043B\u0435\u0439. \u041E\u0441\u0442\u0430\u0432\u044C\u0442\u0435 \u043F\u0443\u0441\u0442\u044B\u043C \u0434\u043B\u044F \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u044F \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u044F \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E (200k \u0442\u043E\u043A\u0435\u043D\u043E\u0432).",
    invalid: "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0444\u043E\u0440\u043C\u0430\u0442. \u0418\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0439\u0442\u0435: 256k, 1m \u0438\u043B\u0438 \u0442\u043E\u0447\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E (1000-10000000)."
  },
  advanced: "\u0414\u043E\u043F\u043E\u043B\u043D\u0438\u0442\u0435\u043B\u044C\u043D\u043E",
  show1MModel: {
    name: "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C Sonnet \u0441 \u043E\u043A\u043D\u043E\u043C \u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442\u0430 1M",
    desc: "\u0417\u0430\u043C\u0435\u043D\u0438\u0442\u044C \u0441\u0442\u0430\u043D\u0434\u0430\u0440\u0442\u043D\u044B\u0439 Sonnet \u043D\u0430 Sonnet (1M) \u0432 \u0432\u044B\u0431\u043E\u0440\u0435 \u043C\u043E\u0434\u0435\u043B\u0435\u0439. \u0422\u0430 \u0436\u0435 \u0446\u0435\u043D\u0430 \u0434\u043E 200k \u0442\u043E\u043A\u0435\u043D\u043E\u0432. \u0422\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044F \u043F\u043E\u0434\u043F\u0438\u0441\u043A\u0430 Max."
  },
  enableChrome: {
    name: "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043D\u0438\u0435 Chrome",
    desc: "\u0420\u0430\u0437\u0440\u0435\u0448\u0438\u0442\u044C Claude \u0432\u0437\u0430\u0438\u043C\u043E\u0434\u0435\u0439\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0441 Chrome \u0447\u0435\u0440\u0435\u0437 \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043D\u0438\u0435 claude-in-chrome. \u0422\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044F \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u043A\u0430 \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043D\u0438\u044F. \u0422\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044F \u043F\u0435\u0440\u0435\u0437\u0430\u043F\u0443\u0441\u043A \u0441\u0435\u0441\u0441\u0438\u0438."
  },
  maxTabs: {
    name: "\u041C\u0430\u043A\u0441\u0438\u043C\u0443\u043C \u0432\u043A\u043B\u0430\u0434\u043E\u043A \u0447\u0430\u0442\u0430",
    desc: "\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u043E\u0435 \u043A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u043E\u0434\u043D\u043E\u0432\u0440\u0435\u043C\u0435\u043D\u043D\u044B\u0445 \u0432\u043A\u043B\u0430\u0434\u043E\u043A \u0447\u0430\u0442\u0430 (3-10). \u041A\u0430\u0436\u0434\u0430\u044F \u0432\u043A\u043B\u0430\u0434\u043A\u0430 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0435\u0442 \u043E\u0442\u0434\u0435\u043B\u044C\u043D\u0443\u044E \u0441\u0435\u0441\u0441\u0438\u044E Claude.",
    warning: "\u0411\u043E\u043B\u0435\u0435 5 \u0432\u043A\u043B\u0430\u0434\u043E\u043A \u043C\u043E\u0436\u0435\u0442 \u043F\u043E\u0432\u043B\u0438\u044F\u0442\u044C \u043D\u0430 \u043F\u0440\u043E\u0438\u0437\u0432\u043E\u0434\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C \u0438 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u0435 \u043F\u0430\u043C\u044F\u0442\u0438."
  },
  tabBarPosition: {
    name: "\u041F\u043E\u043B\u043E\u0436\u0435\u043D\u0438\u0435 \u043F\u0430\u043D\u0435\u043B\u0438 \u0432\u043A\u043B\u0430\u0434\u043E\u043A",
    desc: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435, \u0433\u0434\u0435 \u043E\u0442\u043E\u0431\u0440\u0430\u0436\u0430\u0442\u044C \u0437\u043D\u0430\u0447\u043A\u0438 \u0432\u043A\u043B\u0430\u0434\u043E\u043A \u0438 \u043A\u043D\u043E\u043F\u043A\u0438 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0439",
    input: "\u041D\u0430\u0434 \u043F\u043E\u043B\u0435\u043C \u0432\u0432\u043E\u0434\u0430 (\u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E)",
    header: "\u0412 \u0437\u0430\u0433\u043E\u043B\u043E\u0432\u043A\u0435"
  },
  enableAutoScroll: {
    name: "\u0410\u0432\u0442\u043E\u043F\u0440\u043E\u043A\u0440\u0443\u0442\u043A\u0430 \u0432\u043E \u0432\u0440\u0435\u043C\u044F \u043F\u043E\u0442\u043E\u043A\u043E\u0432\u043E\u0439 \u043F\u0435\u0440\u0435\u0434\u0430\u0447\u0438",
    desc: "\u0410\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438 \u043F\u0440\u043E\u043A\u0440\u0443\u0447\u0438\u0432\u0430\u0442\u044C \u0432\u043D\u0438\u0437, \u043F\u043E\u043A\u0430 Claude \u043F\u0435\u0440\u0435\u0434\u0430\u0435\u0442 \u043E\u0442\u0432\u0435\u0442\u044B. \u041E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u0435, \u0447\u0442\u043E\u0431\u044B \u043E\u0441\u0442\u0430\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430\u0432\u0435\u0440\u0445\u0443 \u0438 \u0447\u0438\u0442\u0430\u0442\u044C \u0441 \u043D\u0430\u0447\u0430\u043B\u0430."
  },
  cliPath: {
    name: "\u041F\u0443\u0442\u044C \u043A CLI Claude",
    desc: "\u041F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u0438\u0439 \u043F\u0443\u0442\u044C \u043A Claude Code CLI. \u041E\u0441\u0442\u0430\u0432\u044C\u0442\u0435 \u043F\u0443\u0441\u0442\u044B\u043C \u0434\u043B\u044F \u0430\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u043E\u0433\u043E \u043E\u043F\u0440\u0435\u0434\u0435\u043B\u0435\u043D\u0438\u044F.",
    descWindows: "\u0414\u043B\u044F \u043D\u0430\u0442\u0438\u0432\u043D\u043E\u0433\u043E \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u0449\u0438\u043A\u0430 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0439\u0442\u0435 claude.exe. \u0414\u043B\u044F \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u043E\u043A \u0447\u0435\u0440\u0435\u0437 npm/pnpm/yarn \u0438\u043B\u0438 \u0434\u0440\u0443\u0433\u0438\u0435 \u043C\u0435\u043D\u0435\u0434\u0436\u0435\u0440\u044B \u043F\u0430\u043A\u0435\u0442\u043E\u0432 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0439\u0442\u0435 \u043F\u0443\u0442\u044C \u043A cli.js (\u043D\u0435 claude.cmd).",
    descUnix: '\u0412\u0441\u0442\u0430\u0432\u044C\u0442\u0435 \u0432\u044B\u0432\u043E\u0434 \u043A\u043E\u043C\u0430\u043D\u0434\u044B "which claude" \u2014 \u0440\u0430\u0431\u043E\u0442\u0430\u0435\u0442 \u043A\u0430\u043A \u0434\u043B\u044F \u043D\u0430\u0442\u0438\u0432\u043D\u044B\u0445 \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u043E\u043A, \u0442\u0430\u043A \u0438 \u0434\u043B\u044F npm/pnpm/yarn.',
    validation: {
      notExist: "\u041F\u0443\u0442\u044C \u043D\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442",
      isDirectory: "\u041F\u0443\u0442\u044C \u044F\u0432\u043B\u044F\u0435\u0442\u0441\u044F \u0434\u0438\u0440\u0435\u043A\u0442\u043E\u0440\u0438\u0435\u0439, \u0430 \u043D\u0435 \u0444\u0430\u0439\u043B\u043E\u043C"
    }
  },
  language: {
    name: "\u042F\u0437\u044B\u043A",
    desc: "\u0418\u0437\u043C\u0435\u043D\u0438\u0442\u044C \u044F\u0437\u044B\u043A \u0438\u043D\u0442\u0435\u0440\u0444\u0435\u0439\u0441\u0430 \u043F\u043B\u0430\u0433\u0438\u043D\u0430"
  }
};
var ru_default = {
  common: common8,
  settings: settings8
};

// src/i18n/locales/zh-CN.json
var zh_CN_exports = {};
__export(zh_CN_exports, {
  common: () => common9,
  default: () => zh_CN_default,
  settings: () => settings9
});
var common9 = {
  save: "\u4FDD\u5B58",
  cancel: "\u53D6\u6D88",
  delete: "\u5220\u9664",
  edit: "\u7F16\u8F91",
  add: "\u6DFB\u52A0",
  remove: "\u79FB\u9664",
  clear: "\u6E05\u9664",
  clearAll: "\u6E05\u9664\u5168\u90E8",
  loading: "\u52A0\u8F7D\u4E2D",
  error: "\u9519\u8BEF",
  success: "\u6210\u529F",
  warning: "\u8B66\u544A",
  confirm: "\u786E\u8BA4",
  settings: "\u8BBE\u7F6E",
  advanced: "\u9AD8\u7EA7",
  enabled: "\u5DF2\u542F\u7528",
  disabled: "\u5DF2\u7981\u7528",
  platform: "\u5E73\u53F0"
};
var settings9 = {
  title: "Claudian \u8BBE\u7F6E",
  customization: "\u4E2A\u6027\u5316\u8BBE\u7F6E",
  userName: {
    name: "Claudian \u5E94\u8BE5\u5982\u4F55\u79F0\u547C\u4F60\uFF1F",
    desc: "\u7528\u4E8E\u4E2A\u6027\u5316\u95EE\u5019\u7684\u7528\u6237\u540D\uFF08\u7559\u7A7A\u4F7F\u7528\u901A\u7528\u95EE\u5019\uFF09"
  },
  excludedTags: {
    name: "\u6392\u9664\u7684\u6807\u7B7E",
    desc: "\u5305\u542B\u8FD9\u4E9B\u6807\u7B7E\u7684\u7B14\u8BB0\u4E0D\u4F1A\u81EA\u52A8\u52A0\u8F7D\u4E3A\u4E0A\u4E0B\u6587\uFF08\u6BCF\u884C\u4E00\u4E2A\uFF0C\u4E0D\u5E26 #\uFF09"
  },
  mediaFolder: {
    name: "\u5A92\u4F53\u6587\u4EF6\u5939",
    desc: "\u5B58\u653E\u9644\u4EF6/\u56FE\u7247\u7684\u6587\u4EF6\u5939\u3002\u5F53\u7B14\u8BB0\u4F7F\u7528 ![[image.jpg]] \u65F6\uFF0CClaude \u4F1A\u5728\u6B64\u67E5\u627E\u3002\u7559\u7A7A\u4F7F\u7528\u4ED3\u5E93\u6839\u76EE\u5F55\u3002"
  },
  systemPrompt: {
    name: "\u81EA\u5B9A\u4E49\u7CFB\u7EDF\u63D0\u793A\u8BCD",
    desc: "\u9644\u52A0\u5230\u9ED8\u8BA4\u7CFB\u7EDF\u63D0\u793A\u8BCD\u7684\u989D\u5916\u6307\u4EE4"
  },
  autoTitle: {
    name: "\u81EA\u52A8\u751F\u6210\u5BF9\u8BDD\u6807\u9898",
    desc: "\u5728\u7528\u6237\u53D1\u9001\u9996\u6761\u6D88\u606F\u540E\u81EA\u52A8\u751F\u6210\u5BF9\u8BDD\u6807\u9898\u3002"
  },
  titleModel: {
    name: "\u6807\u9898\u751F\u6210\u6A21\u578B",
    desc: "\u7528\u4E8E\u81EA\u52A8\u751F\u6210\u5BF9\u8BDD\u6807\u9898\u7684\u6A21\u578B\u3002",
    auto: "\u81EA\u52A8 (Haiku)"
  },
  navMappings: {
    name: "Vim \u98CE\u683C\u5BFC\u822A\u6620\u5C04",
    desc: '\u6BCF\u884C\u4E00\u4E2A\u6620\u5C04\u3002\u683C\u5F0F\uFF1A"map <\u952E> <\u52A8\u4F5C>"\uFF08\u52A8\u4F5C\uFF1AscrollUp, scrollDown, focusInput\uFF09\u3002'
  },
  hotkeys: "\u5FEB\u6377\u952E",
  slashCommands: {
    name: "\u659C\u6760\u547D\u4EE4",
    desc: "\u521B\u5EFA\u7531 /command \u89E6\u53D1\u7684\u81EA\u5B9A\u4E49\u63D0\u793A\u6A21\u677F\u3002\u4F7F\u7528 $ARGUMENTS \u83B7\u53D6\u6240\u6709\u53C2\u6570\uFF0C$1/$2 \u83B7\u53D6\u4F4D\u7F6E\u53C2\u6570\uFF0C@file \u83B7\u53D6\u6587\u4EF6\u5185\u5BB9\uFF0C!`bash` \u83B7\u53D6\u547D\u4EE4\u8F93\u51FA\u3002"
  },
  hiddenSlashCommands: {
    name: "\u9690\u85CF\u547D\u4EE4",
    desc: "\u4ECE\u4E0B\u62C9\u83DC\u5355\u4E2D\u9690\u85CF\u7279\u5B9A\u7684\u659C\u6760\u547D\u4EE4\u3002\u9002\u7528\u4E8E\u9690\u85CF\u4E0E Claudian \u65E0\u5173\u7684 Claude Code \u547D\u4EE4\u3002\u6BCF\u884C\u8F93\u5165\u4E00\u4E2A\u547D\u4EE4\u540D\u79F0\uFF0C\u65E0\u9700\u524D\u5BFC\u659C\u6760\u3002",
    placeholder: "commit\nbuild\ntest"
  },
  mcpServers: {
    name: "MCP \u670D\u52A1\u5668",
    desc: "\u914D\u7F6E\u6A21\u578B\u4E0A\u4E0B\u6587\u534F\u8BAE\u670D\u52A1\u5668\uFF0C\u901A\u8FC7\u5916\u90E8\u5DE5\u5177\u548C\u6570\u636E\u6E90\u6269\u5C55 Claude \u7684\u80FD\u529B\u3002\u542F\u7528\u4E0A\u4E0B\u6587\u4FDD\u5B58\u6A21\u5F0F\u7684\u670D\u52A1\u5668\u9700\u8981 @ \u63D0\u53CA\u624D\u80FD\u6FC0\u6D3B\u3002"
  },
  plugins: {
    name: "Claude Code \u63D2\u4EF6",
    desc: "\u542F\u7528\u6216\u7981\u7528\u4ECE ~/.claude/plugins \u53D1\u73B0\u7684 Claude Code \u63D2\u4EF6\u3002\u542F\u7528\u7684\u63D2\u4EF6\u6309 Vault \u5B58\u50A8\u3002"
  },
  safety: "\u5B89\u5168",
  loadUserSettings: {
    name: "\u52A0\u8F7D\u7528\u6237 Claude \u8BBE\u7F6E",
    desc: "\u52A0\u8F7D ~/.claude/settings.json\u3002\u542F\u7528\u540E\uFF0C\u7528\u6237\u7684 Claude Code \u6743\u9650\u89C4\u5219\u53EF\u80FD\u7ED5\u8FC7\u5B89\u5168\u6A21\u5F0F\u3002"
  },
  enableBlocklist: {
    name: "\u542F\u7528\u547D\u4EE4\u9ED1\u540D\u5355",
    desc: "\u963B\u6B62\u6F5C\u5728\u5371\u9669\u7684 bash \u547D\u4EE4"
  },
  blockedCommands: {
    name: "\u963B\u6B62\u7684\u547D\u4EE4 ({platform})",
    desc: "\u5728 {platform} \u4E0A\u963B\u6B62\u7684\u6A21\u5F0F\uFF08\u6BCF\u884C\u4E00\u4E2A\uFF09\u3002\u652F\u6301\u6B63\u5219\u8868\u8FBE\u5F0F\u3002",
    unixName: "\u963B\u6B62\u7684\u547D\u4EE4 (Unix/Git Bash)",
    unixDesc: "Unix \u6A21\u5F0F\u5728 Windows \u4E0A\u4E5F\u4F1A\u88AB\u963B\u6B62\uFF0C\u56E0\u4E3A Git Bash \u53EF\u4EE5\u8C03\u7528\u5B83\u4EEC\u3002"
  },
  exportPaths: {
    name: "\u5141\u8BB8\u7684\u5BFC\u51FA\u8DEF\u5F84",
    desc: "\u5141\u8BB8\u5BFC\u51FA\u6587\u4EF6\u7684\u4ED3\u5E93\u5916\u90E8\u8DEF\u5F84\uFF08\u6BCF\u884C\u4E00\u4E2A\uFF09\u3002\u652F\u6301 ~ \u8868\u793A\u4E3B\u76EE\u5F55\u3002"
  },
  environment: "\u73AF\u5883",
  customVariables: {
    name: "\u81EA\u5B9A\u4E49\u53D8\u91CF",
    desc: "Claude SDK \u7684\u73AF\u5883\u53D8\u91CF\uFF08KEY=VALUE \u683C\u5F0F\uFF0C\u6BCF\u884C\u4E00\u4E2A\uFF09\u3002\u652F\u6301 export \u524D\u7F00\u3002"
  },
  envSnippets: {
    name: "\u7247\u6BB5",
    addBtn: "\u6DFB\u52A0\u7247\u6BB5",
    noSnippets: "\u5C1A\u65E0\u4FDD\u5B58\u7684\u73AF\u5883\u53D8\u91CF\u7247\u6BB5\u3002\u70B9\u51FB + \u4FDD\u5B58\u5F53\u524D\u914D\u7F6E\u3002",
    nameRequired: "\u8BF7\u8F93\u5165\u7247\u6BB5\u540D\u79F0",
    modal: {
      titleEdit: "\u7F16\u8F91\u7247\u6BB5",
      titleSave: "\u4FDD\u5B58\u7247\u6BB5",
      name: "\u540D\u79F0",
      namePlaceholder: "\u6B64\u914D\u7F6E\u7684\u63CF\u8FF0\u6027\u540D\u79F0",
      description: "\u63CF\u8FF0",
      descPlaceholder: "\u53EF\u9009\u63CF\u8FF0",
      envVars: "\u73AF\u5883\u53D8\u91CF",
      envVarsPlaceholder: "KEY=VALUE \u683C\u5F0F\uFF0C\u6BCF\u884C\u4E00\u4E2A\uFF08\u652F\u6301 export \u524D\u7F00\uFF09",
      save: "\u4FDD\u5B58",
      update: "\u66F4\u65B0",
      cancel: "\u53D6\u6D88"
    }
  },
  customContextLimits: {
    name: "\u81EA\u5B9A\u4E49\u4E0A\u4E0B\u6587\u9650\u5236",
    desc: "\u4E3A\u60A8\u7684\u81EA\u5B9A\u4E49\u6A21\u578B\u8BBE\u7F6E\u4E0A\u4E0B\u6587\u7A97\u53E3\u5927\u5C0F\u3002\u7559\u7A7A\u4F7F\u7528\u9ED8\u8BA4\u503C\uFF08200k \u4EE4\u724C\uFF09\u3002",
    invalid: "\u683C\u5F0F\u65E0\u6548\u3002\u4F7F\u7528\uFF1A256k\u30011m \u6216\u7CBE\u786E\u6570\u91CF\uFF081000-10000000\uFF09\u3002"
  },
  advanced: "\u9AD8\u7EA7",
  show1MModel: {
    name: "\u542F\u7528\u5177\u6709 1M \u4E0A\u4E0B\u6587\u7A97\u53E3\u7684 Sonnet",
    desc: "\u5728\u6A21\u578B\u9009\u62E9\u5668\u4E2D\u5C06\u6807\u51C6 Sonnet \u66FF\u6362\u4E3A Sonnet (1M)\u3002\u5728 200k \u4EE4\u724C\u4EE5\u4E0B\u4EF7\u683C\u76F8\u540C\u3002\u9700\u8981 Max \u8BA2\u9605\u3002"
  },
  enableChrome: {
    name: "\u542F\u7528 Chrome \u6269\u5C55",
    desc: "\u5141\u8BB8 Claude \u901A\u8FC7 claude-in-chrome \u6269\u5C55\u4E0E Chrome \u4EA4\u4E92\u3002\u9700\u8981\u5B89\u88C5\u8BE5\u6269\u5C55\u3002\u9700\u8981\u91CD\u542F\u4F1A\u8BDD\u3002"
  },
  maxTabs: {
    name: "\u6700\u5927\u804A\u5929\u6807\u7B7E\u6570",
    desc: "\u540C\u65F6\u5F00\u542F\u7684\u6700\u5927\u804A\u5929\u6807\u7B7E\u6570\uFF083-10\uFF09\u3002\u6BCF\u4E2A\u6807\u7B7E\u4F7F\u7528\u72EC\u7ACB\u7684 Claude \u4F1A\u8BDD\u3002",
    warning: "\u8D85\u8FC7 5 \u4E2A\u6807\u7B7E\u53EF\u80FD\u4F1A\u5F71\u54CD\u6027\u80FD\u548C\u5185\u5B58\u4F7F\u7528\u3002"
  },
  tabBarPosition: {
    name: "\u6807\u7B7E\u680F\u4F4D\u7F6E",
    desc: "\u9009\u62E9\u6807\u7B7E\u5FBD\u7AE0\u548C\u64CD\u4F5C\u6309\u94AE\u7684\u663E\u793A\u4F4D\u7F6E",
    input: "\u8F93\u5165\u6846\u4E0A\u65B9\uFF08\u9ED8\u8BA4\uFF09",
    header: "\u5728\u6807\u9898\u680F"
  },
  enableAutoScroll: {
    name: "\u6D41\u5F0F\u4F20\u8F93\u65F6\u81EA\u52A8\u6EDA\u52A8",
    desc: "\u5728 Claude \u6D41\u5F0F\u4F20\u8F93\u54CD\u5E94\u65F6\u81EA\u52A8\u6EDA\u52A8\u5230\u5E95\u90E8\u3002\u7981\u7528\u540E\u5C06\u505C\u7559\u5728\u9876\u90E8\uFF0C\u4ECE\u5934\u5F00\u59CB\u9605\u8BFB\u3002"
  },
  cliPath: {
    name: "Claude CLI \u8DEF\u5F84",
    desc: "Claude Code CLI \u7684\u81EA\u5B9A\u4E49\u8DEF\u5F84\u3002\u7559\u7A7A\u4F7F\u7528\u81EA\u52A8\u68C0\u6D4B\u3002",
    descWindows: "\u5BF9\u4E8E\u539F\u751F\u5B89\u88C5\u7A0B\u5E8F\uFF0C\u4F7F\u7528 claude.exe\u3002\u5BF9\u4E8E npm/pnpm/yarn \u6216\u5176\u4ED6\u5305\u7BA1\u7406\u5668\u5B89\u88C5\uFF0C\u4F7F\u7528 cli.js \u8DEF\u5F84\uFF08\u4E0D\u662F claude.cmd\uFF09\u3002",
    descUnix: '\u7C98\u8D34 "which claude" \u7684\u8F93\u51FA - \u9002\u7528\u4E8E\u539F\u751F\u5B89\u88C5\u548C npm/pnpm/yarn \u5B89\u88C5\u3002',
    validation: {
      notExist: "\u8DEF\u5F84\u4E0D\u5B58\u5728",
      isDirectory: "\u8DEF\u5F84\u662F\u76EE\u5F55\uFF0C\u4E0D\u662F\u6587\u4EF6"
    }
  },
  language: {
    name: "\u8BED\u8A00",
    desc: "\u66F4\u6539\u63D2\u4EF6\u754C\u9762\u7684\u663E\u793A\u8BED\u8A00"
  }
};
var zh_CN_default = {
  common: common9,
  settings: settings9
};

// src/i18n/locales/zh-TW.json
var zh_TW_exports = {};
__export(zh_TW_exports, {
  common: () => common10,
  default: () => zh_TW_default,
  settings: () => settings10
});
var common10 = {
  save: "\u4FDD\u5B58",
  cancel: "\u53D6\u6D88",
  delete: "\u522A\u9664",
  edit: "\u7DE8\u8F2F",
  add: "\u6DFB\u52A0",
  remove: "\u79FB\u9664",
  clear: "\u6E05\u9664",
  clearAll: "\u6E05\u9664\u5168\u90E8",
  loading: "\u52A0\u8F09\u4E2D",
  error: "\u932F\u8AA4",
  success: "\u6210\u529F",
  warning: "\u8B66\u544A",
  confirm: "\u78BA\u8A8D",
  settings: "\u8A2D\u7F6E",
  advanced: "\u9AD8\u7D1A",
  enabled: "\u5DF2\u555F\u7528",
  disabled: "\u5DF2\u7981\u7528",
  platform: "\u5E73\u53F0"
};
var settings10 = {
  title: "Claudian \u8A2D\u5B9A",
  customization: "\u500B\u4EBA\u5316\u8A2D\u5B9A",
  userName: {
    name: "Claudian \u61C9\u8A72\u5982\u4F55\u7A31\u547C\u60A8\uFF1F",
    desc: "\u7528\u65BC\u500B\u4EBA\u5316\u554F\u5019\u7684\u4F7F\u7528\u8005\u540D\u7A31\uFF08\u7559\u7A7A\u4F7F\u7528\u901A\u7528\u554F\u5019\uFF09"
  },
  excludedTags: {
    name: "\u6392\u9664\u7684\u6A19\u7C64",
    desc: "\u5305\u542B\u9019\u4E9B\u6A19\u7C64\u7684\u7B46\u8A18\u4E0D\u6703\u81EA\u52D5\u8F09\u5165\u70BA\u4E0A\u4E0B\u6587\uFF08\u6BCF\u884C\u4E00\u500B\uFF0C\u4E0D\u5E36 #\uFF09"
  },
  mediaFolder: {
    name: "\u5A92\u9AD4\u8CC7\u6599\u593E",
    desc: "\u5B58\u653E\u9644\u4EF6/\u5716\u7247\u7684\u8CC7\u6599\u593E\u3002\u7576\u7B46\u8A18\u4F7F\u7528 ![[image.jpg]] \u6642\uFF0CClaude \u6703\u5728\u6B64\u67E5\u627E\u3002\u7559\u7A7A\u4F7F\u7528\u5132\u5B58\u5EAB\u6839\u76EE\u9304\u3002"
  },
  systemPrompt: {
    name: "\u81EA\u8A02\u7CFB\u7D71\u63D0\u793A\u8A5E",
    desc: "\u9644\u52A0\u5230\u9810\u8A2D\u7CFB\u7D71\u63D0\u793A\u8A5E\u7684\u984D\u5916\u6307\u4EE4"
  },
  autoTitle: {
    name: "\u81EA\u52D5\u751F\u6210\u5C0D\u8A71\u6A19\u984C",
    desc: "\u5728\u4F7F\u7528\u8005\u9001\u51FA\u7B2C\u4E00\u5247\u8A0A\u606F\u5F8C\u81EA\u52D5\u751F\u6210\u5C0D\u8A71\u6A19\u984C\u3002"
  },
  titleModel: {
    name: "\u6A19\u984C\u751F\u6210\u6A21\u578B",
    desc: "\u7528\u65BC\u81EA\u52D5\u751F\u6210\u5C0D\u8A71\u6A19\u984C\u7684\u6A21\u578B\u3002",
    auto: "\u81EA\u52D5 (Haiku)"
  },
  navMappings: {
    name: "Vim \u98A8\u683C\u5C0E\u822A\u6620\u5C04",
    desc: '\u6BCF\u884C\u4E00\u500B\u6620\u5C04\u3002\u683C\u5F0F\uFF1A"map <\u9375> <\u52D5\u4F5C>"\uFF08\u52D5\u4F5C\uFF1AscrollUp, scrollDown, focusInput\uFF09\u3002'
  },
  hotkeys: "\u5FEB\u6377\u9375",
  slashCommands: {
    name: "\u659C\u7DDA\u547D\u4EE4",
    desc: "\u5EFA\u7ACB\u7531 /command \u89F8\u767C\u7684\u81EA\u8A02\u63D0\u793A\u7BC4\u672C\u3002\u4F7F\u7528 $ARGUMENTS \u7372\u53D6\u6240\u6709\u53C3\u6578\uFF0C$1/$2 \u7372\u53D6\u4F4D\u7F6E\u53C3\u6578\uFF0C@file \u7372\u53D6\u6A94\u6848\u5167\u5BB9\uFF0C!`bash` \u7372\u53D6\u547D\u4EE4\u8F38\u51FA\u3002"
  },
  hiddenSlashCommands: {
    name: "\u96B1\u85CF\u547D\u4EE4",
    desc: "\u5F9E\u4E0B\u62C9\u9078\u55AE\u4E2D\u96B1\u85CF\u7279\u5B9A\u7684\u659C\u7DDA\u547D\u4EE4\u3002\u9069\u7528\u65BC\u96B1\u85CF\u8207 Claudian \u7121\u95DC\u7684 Claude Code \u547D\u4EE4\u3002\u6BCF\u884C\u8F38\u5165\u4E00\u500B\u547D\u4EE4\u540D\u7A31\uFF0C\u7121\u9700\u524D\u5C0E\u659C\u7DDA\u3002",
    placeholder: "commit\nbuild\ntest"
  },
  mcpServers: {
    name: "MCP \u4F3A\u670D\u5668",
    desc: "\u8A2D\u5B9A\u6A21\u578B\u4E0A\u4E0B\u6587\u5354\u5B9A\u4F3A\u670D\u5668\uFF0C\u900F\u904E\u5916\u90E8\u5DE5\u5177\u548C\u8CC7\u6599\u4F86\u6E90\u64F4\u5C55 Claude \u7684\u80FD\u529B\u3002\u555F\u7528\u4E0A\u4E0B\u6587\u4FDD\u5B58\u6A21\u5F0F\u7684\u4F3A\u670D\u5668\u9700\u8981 @ \u63D0\u53CA\u624D\u80FD\u555F\u7528\u3002"
  },
  plugins: {
    name: "Claude Code \u5916\u639B\u7A0B\u5F0F",
    desc: "\u555F\u7528\u6216\u505C\u7528\u5F9E ~/.claude/plugins \u767C\u73FE\u7684 Claude Code \u5916\u639B\u7A0B\u5F0F\u3002\u5DF2\u555F\u7528\u7684\u5916\u639B\u7A0B\u5F0F\u6309\u5132\u5B58\u5EAB\u5132\u5B58\u3002"
  },
  safety: "\u5B89\u5168",
  loadUserSettings: {
    name: "\u8F09\u5165\u4F7F\u7528\u8005 Claude \u8A2D\u5B9A",
    desc: "\u8F09\u5165 ~/.claude/settings.json\u3002\u555F\u7528\u5F8C\uFF0C\u4F7F\u7528\u8005\u7684 Claude Code \u6B0A\u9650\u898F\u5247\u53EF\u80FD\u7E5E\u904E\u5B89\u5168\u6A21\u5F0F\u3002"
  },
  enableBlocklist: {
    name: "\u555F\u7528\u547D\u4EE4\u9ED1\u540D\u55AE",
    desc: "\u963B\u6B62\u6F5B\u5728\u5371\u96AA\u7684 bash \u547D\u4EE4"
  },
  blockedCommands: {
    name: "\u963B\u6B62\u7684\u547D\u4EE4 ({platform})",
    desc: "\u5728 {platform} \u4E0A\u963B\u6B62\u7684\u6A21\u5F0F\uFF08\u6BCF\u884C\u4E00\u500B\uFF09\u3002\u652F\u63F4\u6B63\u5247\u8868\u793A\u5F0F\u3002",
    unixName: "\u963B\u6B62\u7684\u547D\u4EE4 (Unix/Git Bash)",
    unixDesc: "Unix \u6A21\u5F0F\u5728 Windows \u4E0A\u4E5F\u6703\u88AB\u963B\u6B62\uFF0C\u56E0\u70BA Git Bash \u53EF\u4EE5\u547C\u53EB\u5B83\u5011\u3002"
  },
  exportPaths: {
    name: "\u5141\u8A31\u7684\u532F\u51FA\u8DEF\u5F91",
    desc: "\u5141\u8A31\u532F\u51FA\u6A94\u6848\u7684\u5132\u5B58\u5EAB\u5916\u90E8\u8DEF\u5F91\uFF08\u6BCF\u884C\u4E00\u500B\uFF09\u3002\u652F\u63F4 ~ \u8868\u793A\u4E3B\u76EE\u9304\u3002"
  },
  environment: "\u74B0\u5883",
  customVariables: {
    name: "\u81EA\u8A02\u8B8A\u6578",
    desc: "Claude SDK \u7684\u74B0\u5883\u8B8A\u6578\uFF08KEY=VALUE \u683C\u5F0F\uFF0C\u6BCF\u884C\u4E00\u500B\uFF09\u3002\u652F\u63F4 export \u524D\u7DB4\u3002"
  },
  envSnippets: {
    name: "\u7247\u6BB5",
    addBtn: "\u65B0\u589E\u7247\u6BB5",
    noSnippets: "\u5C1A\u7121\u4FDD\u5B58\u7684\u74B0\u5883\u8B8A\u6578\u7247\u6BB5\u3002\u9EDE\u64CA + \u4FDD\u5B58\u7576\u524D\u914D\u7F6E\u3002",
    nameRequired: "\u8ACB\u8F38\u5165\u7247\u6BB5\u540D\u7A31",
    modal: {
      titleEdit: "\u7DE8\u8F2F\u7247\u6BB5",
      titleSave: "\u4FDD\u5B58\u7247\u6BB5",
      name: "\u540D\u7A31",
      namePlaceholder: "\u6B64\u914D\u7F6E\u7684\u63CF\u8FF0\u6027\u540D\u7A31",
      description: "\u63CF\u8FF0",
      descPlaceholder: "\u53EF\u9078\u63CF\u8FF0",
      envVars: "\u74B0\u5883\u8B8A\u6578",
      envVarsPlaceholder: "KEY=VALUE \u683C\u5F0F\uFF0C\u6BCF\u884C\u4E00\u500B\uFF08\u652F\u63F4 export \u524D\u7DB4\uFF09",
      save: "\u4FDD\u5B58",
      update: "\u66F4\u65B0",
      cancel: "\u53D6\u6D88"
    }
  },
  customContextLimits: {
    name: "\u81EA\u8A02\u4E0A\u4E0B\u6587\u9650\u5236",
    desc: "\u70BA\u60A8\u7684\u81EA\u8A02\u6A21\u578B\u8A2D\u5B9A\u4E0A\u4E0B\u6587\u8996\u7A97\u5927\u5C0F\u3002\u7559\u7A7A\u4F7F\u7528\u9810\u8A2D\u503C\uFF08200k \u6B0A\u6756\uFF09\u3002",
    invalid: "\u683C\u5F0F\u7121\u6548\u3002\u4F7F\u7528\uFF1A256k\u30011m \u6216\u7CBE\u78BA\u6578\u91CF\uFF081000-10000000\uFF09\u3002"
  },
  advanced: "\u9032\u968E",
  show1MModel: {
    name: "\u555F\u7528\u5177\u6709 1M \u4E0A\u4E0B\u6587\u8996\u7A97\u7684 Sonnet",
    desc: "\u5728\u6A21\u578B\u9078\u64C7\u5668\u4E2D\u5C07\u6A19\u6E96 Sonnet \u66FF\u63DB\u70BA Sonnet (1M)\u3002\u5728 200k \u6B0A\u6756\u4EE5\u4E0B\u50F9\u683C\u76F8\u540C\u3002\u9700\u8981 Max \u8A02\u95B1\u3002"
  },
  enableChrome: {
    name: "\u555F\u7528 Chrome \u64F4\u5145\u529F\u80FD",
    desc: "\u5141\u8A31 Claude \u900F\u904E claude-in-chrome \u64F4\u5145\u529F\u80FD\u8207 Chrome \u4E92\u52D5\u3002\u9700\u8981\u5B89\u88DD\u8A72\u64F4\u5145\u529F\u80FD\u3002\u9700\u8981\u91CD\u65B0\u555F\u52D5\u5DE5\u4F5C\u968E\u6BB5\u3002"
  },
  maxTabs: {
    name: "\u6700\u5927\u804A\u5929\u6A19\u7C64\u6578",
    desc: "\u540C\u6642\u958B\u555F\u7684\u6700\u5927\u804A\u5929\u6A19\u7C64\u6578\uFF083-10\uFF09\u3002\u6BCF\u500B\u6A19\u7C64\u4F7F\u7528\u7368\u7ACB\u7684 Claude \u5C0D\u8A71\u3002",
    warning: "\u8D85\u904E 5 \u500B\u6A19\u7C64\u53EF\u80FD\u6703\u5F71\u97FF\u6548\u80FD\u548C\u8A18\u61B6\u9AD4\u4F7F\u7528\u3002"
  },
  tabBarPosition: {
    name: "\u6A19\u7C64\u5217\u4F4D\u7F6E",
    desc: "\u9078\u64C7\u6A19\u7C64\u5FBD\u7AE0\u548C\u64CD\u4F5C\u6309\u9215\u7684\u986F\u793A\u4F4D\u7F6E",
    input: "\u8F38\u5165\u6846\u4E0A\u65B9\uFF08\u9810\u8A2D\uFF09",
    header: "\u5728\u6A19\u984C\u5217"
  },
  enableAutoScroll: {
    name: "\u4E32\u6D41\u50B3\u8F38\u6642\u81EA\u52D5\u6372\u52D5",
    desc: "\u5728 Claude \u4E32\u6D41\u50B3\u8F38\u56DE\u61C9\u6642\u81EA\u52D5\u6372\u52D5\u5230\u5E95\u90E8\u3002\u505C\u7528\u5F8C\u5C07\u505C\u7559\u5728\u9802\u90E8\uFF0C\u5F9E\u982D\u958B\u59CB\u95B1\u8B80\u3002"
  },
  cliPath: {
    name: "Claude CLI \u8DEF\u5F91",
    desc: "Claude Code CLI \u7684\u81EA\u8A02\u8DEF\u5F91\u3002\u7559\u7A7A\u4F7F\u7528\u81EA\u52D5\u6AA2\u6E2C\u3002",
    descWindows: "\u5C0D\u65BC\u539F\u751F\u5B89\u88DD\u7A0B\u5F0F\uFF0C\u4F7F\u7528 claude.exe\u3002\u5C0D\u65BC npm/pnpm/yarn \u6216\u5176\u4ED6\u5957\u4EF6\u7BA1\u7406\u5668\u5B89\u88DD\uFF0C\u4F7F\u7528 cli.js \u8DEF\u5F91\uFF08\u4E0D\u662F claude.cmd\uFF09\u3002",
    descUnix: '\u8CBC\u4E0A "which claude" \u7684\u8F38\u51FA - \u9069\u7528\u65BC\u539F\u751F\u5B89\u88DD\u548C npm/pnpm/yarn \u5B89\u88DD\u3002',
    validation: {
      notExist: "\u8DEF\u5F91\u4E0D\u5B58\u5728",
      isDirectory: "\u8DEF\u5F91\u662F\u76EE\u9304\uFF0C\u4E0D\u662F\u6A94\u6848"
    }
  },
  language: {
    name: "\u8A9E\u8A00",
    desc: "\u66F4\u6539\u63D2\u4EF6\u4ECB\u9762\u7684\u986F\u793A\u8A9E\u8A00"
  }
};
var zh_TW_default = {
  common: common10,
  settings: settings10
};

// src/i18n/i18n.ts
var translations = {
  en: en_exports,
  "zh-CN": zh_CN_exports,
  "zh-TW": zh_TW_exports,
  ja: ja_exports,
  ko: ko_exports,
  de: de_exports,
  fr: fr_exports,
  es: es_exports,
  ru: ru_exports,
  pt: pt_exports
};
var DEFAULT_LOCALE = "en";
var currentLocale = DEFAULT_LOCALE;
function t(key, params) {
  const dict = translations[currentLocale];
  const keys = key.split(".");
  let value = dict;
  for (const k of keys) {
    if (value && typeof value === "object" && k in value) {
      value = value[k];
    } else {
      if (currentLocale !== DEFAULT_LOCALE) {
        return tFallback(key, params);
      }
      return key;
    }
  }
  if (typeof value !== "string") {
    return key;
  }
  if (params) {
    return value.replace(/\{(\w+)\}/g, (_, param) => {
      var _a, _b;
      return (_b = (_a = params[param]) == null ? void 0 : _a.toString()) != null ? _b : `{${param}}`;
    });
  }
  return value;
}
function tFallback(key, params) {
  const dict = translations[DEFAULT_LOCALE];
  const keys = key.split(".");
  let value = dict;
  for (const k of keys) {
    if (value && typeof value === "object" && k in value) {
      value = value[k];
    } else {
      return key;
    }
  }
  if (typeof value !== "string") {
    return key;
  }
  if (params) {
    return value.replace(/\{(\w+)\}/g, (_, param) => {
      var _a, _b;
      return (_b = (_a = params[param]) == null ? void 0 : _a.toString()) != null ? _b : `{${param}}`;
    });
  }
  return value;
}
function setLocale(locale) {
  if (!translations[locale]) {
    return false;
  }
  currentLocale = locale;
  return true;
}
function getAvailableLocales() {
  return Object.keys(translations);
}
function getLocaleDisplayName(locale) {
  const names = {
    "en": "English",
    "zh-CN": "\u7B80\u4F53\u4E2D\u6587",
    "zh-TW": "\u7E41\u9AD4\u4E2D\u6587",
    "ja": "\u65E5\u672C\u8A9E",
    "ko": "\uD55C\uAD6D\uC5B4",
    "de": "Deutsch",
    "fr": "Fran\xE7ais",
    "es": "Espa\xF1ol",
    "ru": "\u0420\u0443\u0441\u0441\u043A\u0438\u0439",
    "pt": "Portugu\xEAs"
  };
  return names[locale] || locale;
}

// src/features/settings/keyboardNavigation.ts
var NAV_ACTIONS = ["scrollUp", "scrollDown", "focusInput"];
var buildNavMappingText = (settings11) => {
  return [
    `map ${settings11.scrollUpKey} scrollUp`,
    `map ${settings11.scrollDownKey} scrollDown`,
    `map ${settings11.focusInputKey} focusInput`
  ].join("\n");
};
var parseNavMappings = (value) => {
  const parsed = {};
  const usedKeys = /* @__PURE__ */ new Map();
  const lines = value.split("\n");
  for (const rawLine of lines) {
    const line = rawLine.trim();
    if (!line) continue;
    const parts = line.split(/\s+/);
    if (parts.length !== 3 || parts[0] !== "map") {
      return { error: 'Each line must follow "map <key> <action>"' };
    }
    const key = parts[1];
    const action = parts[2];
    if (!NAV_ACTIONS.includes(action)) {
      return { error: `Unknown action: ${parts[2]}` };
    }
    if (key.length !== 1) {
      return { error: `Key must be a single character for ${action}` };
    }
    const normalizedKey = key.toLowerCase();
    if (usedKeys.has(normalizedKey)) {
      return { error: "Navigation keys must be unique" };
    }
    if (parsed[action]) {
      return { error: `Duplicate mapping for ${action}` };
    }
    usedKeys.set(normalizedKey, action);
    parsed[action] = key;
  }
  const missing = NAV_ACTIONS.filter((action) => !parsed[action]);
  if (missing.length > 0) {
    return { error: `Missing mapping for ${missing.join(", ")}` };
  }
  return { settings: parsed };
};

// src/features/settings/ui/EnvSnippetManager.ts
var import_obsidian22 = require("obsidian");
var EnvSnippetModal = class extends import_obsidian22.Modal {
  constructor(app, plugin, snippet, onSave) {
    super(app);
    this.plugin = plugin;
    this.snippet = snippet;
    this.onSave = onSave;
  }
  onOpen() {
    const { contentEl } = this;
    this.setTitle(this.snippet ? t("settings.envSnippets.modal.titleEdit") : t("settings.envSnippets.modal.titleSave"));
    this.modalEl.addClass("claudian-env-snippet-modal");
    let nameEl;
    let descEl;
    let envVarsEl;
    const contextLimitInputs = /* @__PURE__ */ new Map();
    let contextLimitsContainer = null;
    const handleKeyDown = (e2) => {
      if (e2.key === "Enter" && !e2.isComposing) {
        e2.preventDefault();
        saveSnippet();
      } else if (e2.key === "Escape" && !e2.isComposing) {
        e2.preventDefault();
        this.close();
      }
    };
    const saveSnippet = () => {
      var _a;
      const name = nameEl.value.trim();
      if (!name) {
        new import_obsidian22.Notice(t("settings.envSnippets.nameRequired"));
        return;
      }
      const contextLimits = {};
      for (const [modelId, input] of contextLimitInputs) {
        const value = input.value.trim();
        if (value) {
          const parsed = parseContextLimit(value);
          if (parsed !== null) {
            contextLimits[modelId] = parsed;
          }
        }
      }
      const snippet = {
        id: ((_a = this.snippet) == null ? void 0 : _a.id) || `snippet-${Date.now()}`,
        name,
        description: descEl.value.trim(),
        envVars: envVarsEl.value,
        contextLimits: Object.keys(contextLimits).length > 0 ? contextLimits : void 0
      };
      this.onSave(snippet);
      this.close();
    };
    const renderContextLimitFields = () => {
      var _a, _b, _c;
      if (!contextLimitsContainer) return;
      contextLimitsContainer.empty();
      contextLimitInputs.clear();
      const envVars = parseEnvironmentVariables(envVarsEl.value);
      const uniqueModelIds = getCustomModelIds(envVars);
      if (uniqueModelIds.size === 0) {
        contextLimitsContainer.style.display = "none";
        return;
      }
      contextLimitsContainer.style.display = "block";
      const existingLimits = (_c = (_b = (_a = this.snippet) == null ? void 0 : _a.contextLimits) != null ? _b : this.plugin.settings.customContextLimits) != null ? _c : {};
      contextLimitsContainer.createEl("div", {
        text: t("settings.customContextLimits.name"),
        cls: "setting-item-name"
      });
      contextLimitsContainer.createEl("div", {
        text: t("settings.customContextLimits.desc"),
        cls: "setting-item-description"
      });
      for (const modelId of uniqueModelIds) {
        const row = contextLimitsContainer.createDiv({ cls: "claudian-snippet-limit-row" });
        row.createSpan({ text: modelId, cls: "claudian-snippet-limit-model" });
        row.createSpan({ cls: "claudian-snippet-limit-spacer" });
        const input = row.createEl("input", {
          type: "text",
          placeholder: "200k",
          cls: "claudian-snippet-limit-input"
        });
        input.value = existingLimits[modelId] ? formatContextLimit(existingLimits[modelId]) : "";
        contextLimitInputs.set(modelId, input);
      }
    };
    new import_obsidian22.Setting(contentEl).setName(t("settings.envSnippets.modal.name")).setDesc(t("settings.envSnippets.modal.namePlaceholder")).addText((text) => {
      var _a;
      nameEl = text.inputEl;
      text.setValue(((_a = this.snippet) == null ? void 0 : _a.name) || "");
      text.inputEl.addEventListener("keydown", handleKeyDown);
    });
    new import_obsidian22.Setting(contentEl).setName(t("settings.envSnippets.modal.description")).setDesc(t("settings.envSnippets.modal.descPlaceholder")).addText((text) => {
      var _a;
      descEl = text.inputEl;
      text.setValue(((_a = this.snippet) == null ? void 0 : _a.description) || "");
      text.inputEl.addEventListener("keydown", handleKeyDown);
    });
    const envVarsSetting = new import_obsidian22.Setting(contentEl).setName(t("settings.envSnippets.modal.envVars")).setDesc(t("settings.envSnippets.modal.envVarsPlaceholder")).addTextArea((text) => {
      var _a, _b;
      envVarsEl = text.inputEl;
      const envVarsToShow = (_b = (_a = this.snippet) == null ? void 0 : _a.envVars) != null ? _b : this.plugin.settings.environmentVariables;
      text.setValue(envVarsToShow);
      text.inputEl.rows = 8;
      text.inputEl.addEventListener("blur", () => renderContextLimitFields());
    });
    envVarsSetting.settingEl.addClass("claudian-env-snippet-setting");
    envVarsSetting.controlEl.addClass("claudian-env-snippet-control");
    contextLimitsContainer = contentEl.createDiv({ cls: "claudian-snippet-context-limits" });
    renderContextLimitFields();
    const buttonContainer = contentEl.createDiv({ cls: "claudian-snippet-buttons" });
    const cancelBtn = buttonContainer.createEl("button", {
      text: t("settings.envSnippets.modal.cancel"),
      cls: "claudian-cancel-btn"
    });
    cancelBtn.addEventListener("click", () => this.close());
    const saveBtn = buttonContainer.createEl("button", {
      text: this.snippet ? t("settings.envSnippets.modal.update") : t("settings.envSnippets.modal.save"),
      cls: "claudian-save-btn"
    });
    saveBtn.addEventListener("click", () => saveSnippet());
    setTimeout(() => nameEl == null ? void 0 : nameEl.focus(), 50);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var EnvSnippetManager = class {
  constructor(containerEl, plugin, onContextLimitsChange) {
    this.containerEl = containerEl;
    this.plugin = plugin;
    this.onContextLimitsChange = onContextLimitsChange;
    this.render();
  }
  render() {
    this.containerEl.empty();
    const headerEl = this.containerEl.createDiv({ cls: "claudian-snippet-header" });
    headerEl.createSpan({ text: t("settings.envSnippets.name"), cls: "claudian-snippet-label" });
    const saveBtn = headerEl.createEl("button", {
      cls: "claudian-settings-action-btn",
      attr: { "aria-label": t("settings.envSnippets.addBtn") }
    });
    (0, import_obsidian22.setIcon)(saveBtn, "plus");
    saveBtn.addEventListener("click", () => this.saveCurrentEnv());
    const snippets = this.plugin.settings.envSnippets;
    if (snippets.length === 0) {
      const emptyEl = this.containerEl.createDiv({ cls: "claudian-snippet-empty" });
      emptyEl.setText(t("settings.envSnippets.noSnippets"));
      return;
    }
    const listEl = this.containerEl.createDiv({ cls: "claudian-snippet-list" });
    for (const snippet of snippets) {
      const itemEl = listEl.createDiv({ cls: "claudian-snippet-item" });
      const infoEl = itemEl.createDiv({ cls: "claudian-snippet-info" });
      const nameEl = infoEl.createDiv({ cls: "claudian-snippet-name" });
      nameEl.setText(snippet.name);
      if (snippet.description) {
        const descEl = infoEl.createDiv({ cls: "claudian-snippet-description" });
        descEl.setText(snippet.description);
      }
      const actionsEl = itemEl.createDiv({ cls: "claudian-snippet-actions" });
      const restoreBtn = actionsEl.createEl("button", {
        cls: "claudian-settings-action-btn",
        attr: { "aria-label": "Insert" }
      });
      (0, import_obsidian22.setIcon)(restoreBtn, "clipboard-paste");
      restoreBtn.addEventListener("click", async () => {
        try {
          await this.insertSnippet(snippet);
        } catch (e2) {
          new import_obsidian22.Notice("Failed to insert snippet");
        }
      });
      const editBtn = actionsEl.createEl("button", {
        cls: "claudian-settings-action-btn",
        attr: { "aria-label": "Edit" }
      });
      (0, import_obsidian22.setIcon)(editBtn, "pencil");
      editBtn.addEventListener("click", () => {
        this.editSnippet(snippet);
      });
      const deleteBtn = actionsEl.createEl("button", {
        cls: "claudian-settings-action-btn claudian-settings-delete-btn",
        attr: { "aria-label": "Delete" }
      });
      (0, import_obsidian22.setIcon)(deleteBtn, "trash-2");
      deleteBtn.addEventListener("click", async () => {
        try {
          if (confirm(`Delete environment snippet "${snippet.name}"?`)) {
            await this.deleteSnippet(snippet);
          }
        } catch (e2) {
          new import_obsidian22.Notice("Failed to delete snippet");
        }
      });
    }
  }
  async saveCurrentEnv() {
    const modal = new EnvSnippetModal(
      this.plugin.app,
      this.plugin,
      null,
      async (snippet) => {
        this.plugin.settings.envSnippets.push(snippet);
        await this.plugin.saveSettings();
        this.render();
        new import_obsidian22.Notice(`Environment snippet "${snippet.name}" saved`);
      }
    );
    modal.open();
  }
  async insertSnippet(snippet) {
    var _a, _b;
    const snippetContent = snippet.envVars.trim();
    const envTextarea = document.querySelector(".claudian-settings-env-textarea");
    if (envTextarea) {
      envTextarea.value = snippetContent;
    } else {
      this.render();
    }
    await this.plugin.applyEnvironmentVariables(snippetContent);
    if (snippet.contextLimits) {
      this.plugin.settings.customContextLimits = {
        ...this.plugin.settings.customContextLimits,
        ...snippet.contextLimits
      };
    }
    await this.plugin.saveSettings();
    (_a = this.onContextLimitsChange) == null ? void 0 : _a.call(this);
    const view = (_b = this.plugin.app.workspace.getLeavesOfType("claudian-view")[0]) == null ? void 0 : _b.view;
    view == null ? void 0 : view.refreshModelSelector();
  }
  editSnippet(snippet) {
    const modal = new EnvSnippetModal(
      this.plugin.app,
      this.plugin,
      snippet,
      async (updatedSnippet) => {
        const index = this.plugin.settings.envSnippets.findIndex((s) => s.id === snippet.id);
        if (index !== -1) {
          this.plugin.settings.envSnippets[index] = updatedSnippet;
          await this.plugin.saveSettings();
          this.render();
          new import_obsidian22.Notice(`Environment snippet "${updatedSnippet.name}" updated`);
        }
      }
    );
    modal.open();
  }
  async deleteSnippet(snippet) {
    this.plugin.settings.envSnippets = this.plugin.settings.envSnippets.filter((s) => s.id !== snippet.id);
    await this.plugin.saveSettings();
    this.render();
    new import_obsidian22.Notice(`Environment snippet "${snippet.name}" deleted`);
  }
  refresh() {
    this.render();
  }
};

// src/features/settings/ui/McpSettingsManager.ts
var import_obsidian25 = require("obsidian");

// src/features/settings/ui/McpServerModal.ts
var import_obsidian23 = require("obsidian");
var McpServerModal = class extends import_obsidian23.Modal {
  constructor(app, plugin, existingServer, onSave, initialType, prefillConfig) {
    super(app);
    this.serverName = "";
    this.serverType = "stdio";
    this.enabled = DEFAULT_MCP_SERVER.enabled;
    this.contextSaving = DEFAULT_MCP_SERVER.contextSaving;
    this.command = "";
    this.env = "";
    this.url = "";
    this.headers = "";
    this.typeFieldsEl = null;
    this.nameInputEl = null;
    this.plugin = plugin;
    this.existingServer = existingServer;
    this.onSave = onSave;
    if (existingServer) {
      this.serverName = existingServer.name;
      this.serverType = getMcpServerType(existingServer.config);
      this.enabled = existingServer.enabled;
      this.contextSaving = existingServer.contextSaving;
      this.initFromConfig(existingServer.config);
    } else if (prefillConfig) {
      this.serverName = prefillConfig.name;
      this.serverType = getMcpServerType(prefillConfig.config);
      this.initFromConfig(prefillConfig.config);
    } else if (initialType) {
      this.serverType = initialType;
    }
  }
  initFromConfig(config) {
    const type = getMcpServerType(config);
    if (type === "stdio") {
      const stdioConfig = config;
      if (stdioConfig.args && stdioConfig.args.length > 0) {
        this.command = stdioConfig.command + " " + stdioConfig.args.join(" ");
      } else {
        this.command = stdioConfig.command;
      }
      this.env = this.envRecordToString(stdioConfig.env);
    } else {
      const urlConfig = config;
      this.url = urlConfig.url;
      this.headers = this.envRecordToString(urlConfig.headers);
    }
  }
  onOpen() {
    this.setTitle(this.existingServer ? "Edit MCP Server" : "Add MCP Server");
    this.modalEl.addClass("claudian-mcp-modal");
    const { contentEl } = this;
    new import_obsidian23.Setting(contentEl).setName("Server name").setDesc("Unique identifier for this server").addText((text) => {
      this.nameInputEl = text.inputEl;
      text.setValue(this.serverName);
      text.setPlaceholder("my-mcp-server");
      text.onChange((value) => {
        this.serverName = value;
      });
      text.inputEl.addEventListener("keydown", (e2) => this.handleKeyDown(e2));
    });
    new import_obsidian23.Setting(contentEl).setName("Type").setDesc("Server connection type").addDropdown((dropdown) => {
      dropdown.addOption("stdio", "stdio (local command)");
      dropdown.addOption("sse", "sse (Server-Sent Events)");
      dropdown.addOption("http", "http (HTTP endpoint)");
      dropdown.setValue(this.serverType);
      dropdown.onChange((value) => {
        this.serverType = value;
        this.renderTypeFields();
      });
    });
    this.typeFieldsEl = contentEl.createDiv({ cls: "claudian-mcp-type-fields" });
    this.renderTypeFields();
    new import_obsidian23.Setting(contentEl).setName("Enabled").setDesc("Whether this server is active").addToggle((toggle) => {
      toggle.setValue(this.enabled);
      toggle.onChange((value) => {
        this.enabled = value;
      });
    });
    new import_obsidian23.Setting(contentEl).setName("Context-saving mode").setDesc("Hide tools from agent unless @-mentioned (saves context window)").addToggle((toggle) => {
      toggle.setValue(this.contextSaving);
      toggle.onChange((value) => {
        this.contextSaving = value;
      });
    });
    const buttonContainer = contentEl.createDiv({ cls: "claudian-mcp-buttons" });
    const cancelBtn = buttonContainer.createEl("button", {
      text: "Cancel",
      cls: "claudian-cancel-btn"
    });
    cancelBtn.addEventListener("click", () => this.close());
    const saveBtn = buttonContainer.createEl("button", {
      text: this.existingServer ? "Update" : "Add",
      cls: "claudian-save-btn mod-cta"
    });
    saveBtn.addEventListener("click", () => this.save());
  }
  renderTypeFields() {
    if (!this.typeFieldsEl) return;
    this.typeFieldsEl.empty();
    if (this.serverType === "stdio") {
      this.renderStdioFields();
    } else {
      this.renderUrlFields();
    }
  }
  renderStdioFields() {
    if (!this.typeFieldsEl) return;
    const cmdSetting = new import_obsidian23.Setting(this.typeFieldsEl).setName("Command").setDesc("Full command with arguments");
    cmdSetting.settingEl.addClass("claudian-mcp-cmd-setting");
    const cmdTextarea = cmdSetting.controlEl.createEl("textarea", {
      cls: "claudian-mcp-cmd-textarea"
    });
    cmdTextarea.value = this.command;
    cmdTextarea.placeholder = "docker exec -i mcp-server python -m src.server";
    cmdTextarea.rows = 2;
    cmdTextarea.addEventListener("input", () => {
      this.command = cmdTextarea.value;
    });
    const envSetting = new import_obsidian23.Setting(this.typeFieldsEl).setName("Environment variables").setDesc("KEY=VALUE per line (optional)");
    envSetting.settingEl.addClass("claudian-mcp-env-setting");
    const envTextarea = envSetting.controlEl.createEl("textarea", {
      cls: "claudian-mcp-env-textarea"
    });
    envTextarea.value = this.env;
    envTextarea.placeholder = "API_KEY=your-key";
    envTextarea.rows = 2;
    envTextarea.addEventListener("input", () => {
      this.env = envTextarea.value;
    });
  }
  renderUrlFields() {
    if (!this.typeFieldsEl) return;
    new import_obsidian23.Setting(this.typeFieldsEl).setName("URL").setDesc(this.serverType === "sse" ? "SSE endpoint URL" : "HTTP endpoint URL").addText((text) => {
      text.setValue(this.url);
      text.setPlaceholder("http://localhost:3000/sse");
      text.onChange((value) => {
        this.url = value;
      });
      text.inputEl.addEventListener("keydown", (e2) => this.handleKeyDown(e2));
    });
    const headersSetting = new import_obsidian23.Setting(this.typeFieldsEl).setName("Headers").setDesc("HTTP headers (KEY=VALUE per line)");
    headersSetting.settingEl.addClass("claudian-mcp-env-setting");
    const headersTextarea = headersSetting.controlEl.createEl("textarea", {
      cls: "claudian-mcp-env-textarea"
    });
    headersTextarea.value = this.headers;
    headersTextarea.placeholder = "Authorization=Bearer token\nContent-Type=application/json";
    headersTextarea.rows = 3;
    headersTextarea.addEventListener("input", () => {
      this.headers = headersTextarea.value;
    });
  }
  handleKeyDown(e2) {
    if (e2.key === "Enter" && !e2.shiftKey && !e2.isComposing) {
      e2.preventDefault();
      this.save();
    } else if (e2.key === "Escape" && !e2.isComposing) {
      e2.preventDefault();
      this.close();
    }
  }
  save() {
    var _a, _b, _c;
    const name = this.serverName.trim();
    if (!name) {
      new import_obsidian23.Notice("Please enter a server name");
      (_a = this.nameInputEl) == null ? void 0 : _a.focus();
      return;
    }
    if (!/^[a-zA-Z0-9._-]+$/.test(name)) {
      new import_obsidian23.Notice("Server name can only contain letters, numbers, dots, hyphens, and underscores");
      (_b = this.nameInputEl) == null ? void 0 : _b.focus();
      return;
    }
    let config;
    if (this.serverType === "stdio") {
      const fullCommand = this.command.trim();
      if (!fullCommand) {
        new import_obsidian23.Notice("Please enter a command");
        return;
      }
      const { cmd, args } = parseCommand(fullCommand);
      const stdioConfig = { command: cmd };
      if (args.length > 0) {
        stdioConfig.args = args;
      }
      const env = this.parseEnvString(this.env);
      if (Object.keys(env).length > 0) {
        stdioConfig.env = env;
      }
      config = stdioConfig;
    } else {
      const url = this.url.trim();
      if (!url) {
        new import_obsidian23.Notice("Please enter a URL");
        return;
      }
      if (this.serverType === "sse") {
        const sseConfig = { type: "sse", url };
        const headers = this.parseEnvString(this.headers);
        if (Object.keys(headers).length > 0) {
          sseConfig.headers = headers;
        }
        config = sseConfig;
      } else {
        const httpConfig = { type: "http", url };
        const headers = this.parseEnvString(this.headers);
        if (Object.keys(headers).length > 0) {
          httpConfig.headers = headers;
        }
        config = httpConfig;
      }
    }
    const server = {
      name,
      config,
      enabled: this.enabled,
      contextSaving: this.contextSaving,
      disabledTools: (_c = this.existingServer) == null ? void 0 : _c.disabledTools
    };
    this.onSave(server);
    this.close();
  }
  parseEnvString(envStr) {
    const result = {};
    if (!envStr.trim()) return result;
    for (const line of envStr.split("\n")) {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith("#")) continue;
      const eqIndex = trimmed.indexOf("=");
      if (eqIndex === -1) continue;
      const key = trimmed.substring(0, eqIndex).trim();
      const value = trimmed.substring(eqIndex + 1).trim();
      if (key) {
        result[key] = value;
      }
    }
    return result;
  }
  envRecordToString(env) {
    if (!env) return "";
    return Object.entries(env).map(([key, value]) => `${key}=${value}`).join("\n");
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/features/settings/ui/McpTestModal.ts
var import_obsidian24 = require("obsidian");
function formatToggleError(error) {
  if (!(error instanceof Error)) return "Failed to update tool setting";
  const msg = error.message.toLowerCase();
  if (msg.includes("permission") || msg.includes("eacces")) {
    return "Permission denied. Check .claude/ folder permissions.";
  }
  if (msg.includes("enospc") || msg.includes("disk full") || msg.includes("no space")) {
    return "Disk full. Free up space and try again.";
  }
  if (msg.includes("json") || msg.includes("syntax")) {
    return "Config file corrupted. Check .claude/mcp.json";
  }
  return error.message || "Failed to update tool setting";
}
var McpTestModal = class extends import_obsidian24.Modal {
  constructor(app, serverName, initialDisabledTools, onToolToggle, onBulkToggle) {
    super(app);
    this.result = null;
    this.loading = true;
    this.contentEl_ = null;
    this.toolToggles = /* @__PURE__ */ new Map();
    this.toolElements = /* @__PURE__ */ new Map();
    this.toggleAllBtn = null;
    this.pendingToggle = false;
    this.serverName = serverName;
    this.disabledTools = new Set(
      (initialDisabledTools != null ? initialDisabledTools : []).map((tool) => tool.trim()).filter((tool) => tool.length > 0)
    );
    this.onToolToggle = onToolToggle;
    this.onBulkToggle = onBulkToggle;
  }
  onOpen() {
    this.setTitle(`Verify: ${this.serverName}`);
    this.modalEl.addClass("claudian-mcp-test-modal");
    this.contentEl_ = this.contentEl;
    this.renderLoading();
  }
  setResult(result) {
    this.result = result;
    this.loading = false;
    this.render();
  }
  setError(error) {
    this.result = { success: false, tools: [], error };
    this.loading = false;
    this.render();
  }
  renderLoading() {
    if (!this.contentEl_) return;
    this.contentEl_.empty();
    const loadingEl = this.contentEl_.createDiv({ cls: "claudian-mcp-test-loading" });
    const spinnerEl = loadingEl.createDiv({ cls: "claudian-mcp-test-spinner" });
    spinnerEl.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83"/>
    </svg>`;
    loadingEl.createSpan({ text: "Connecting to MCP server..." });
  }
  render() {
    if (!this.contentEl_) return;
    this.contentEl_.empty();
    if (!this.result) {
      this.renderLoading();
      return;
    }
    const statusEl = this.contentEl_.createDiv({ cls: "claudian-mcp-test-status" });
    const iconEl = statusEl.createSpan({ cls: "claudian-mcp-test-icon" });
    if (this.result.success) {
      (0, import_obsidian24.setIcon)(iconEl, "check-circle");
      iconEl.addClass("success");
    } else {
      (0, import_obsidian24.setIcon)(iconEl, "x-circle");
      iconEl.addClass("error");
    }
    const textEl = statusEl.createSpan({ cls: "claudian-mcp-test-text" });
    if (this.result.success) {
      let statusText = "Connected successfully";
      if (this.result.serverName) {
        statusText += ` to ${this.result.serverName}`;
        if (this.result.serverVersion) {
          statusText += ` v${this.result.serverVersion}`;
        }
      }
      textEl.setText(statusText);
    } else {
      textEl.setText("Connection failed");
    }
    if (this.result.error) {
      const errorEl = this.contentEl_.createDiv({ cls: "claudian-mcp-test-error" });
      errorEl.setText(this.result.error);
    }
    this.toolToggles.clear();
    this.toolElements.clear();
    if (this.result.tools.length > 0) {
      const toolsSection = this.contentEl_.createDiv({ cls: "claudian-mcp-test-tools" });
      const toolsHeader = toolsSection.createDiv({ cls: "claudian-mcp-test-tools-header" });
      toolsHeader.setText(`Available Tools (${this.result.tools.length})`);
      const toolsList = toolsSection.createDiv({ cls: "claudian-mcp-test-tools-list" });
      for (const tool of this.result.tools) {
        this.renderTool(toolsList, tool);
      }
    } else if (this.result.success) {
      const noToolsEl = this.contentEl_.createDiv({ cls: "claudian-mcp-test-no-tools" });
      noToolsEl.setText("No tools information available. Tools will be loaded when used in chat.");
    }
    const buttonContainer = this.contentEl_.createDiv({ cls: "claudian-mcp-test-buttons" });
    if (this.result.tools.length > 0 && this.onToolToggle) {
      this.toggleAllBtn = buttonContainer.createEl("button", {
        cls: "claudian-mcp-toggle-all-btn"
      });
      this.updateToggleAllButton();
      this.toggleAllBtn.addEventListener("click", () => this.handleToggleAll());
    }
    const closeBtn = buttonContainer.createEl("button", {
      text: "Close",
      cls: "mod-cta"
    });
    closeBtn.addEventListener("click", () => this.close());
  }
  renderTool(container, tool) {
    const toolEl = container.createDiv({ cls: "claudian-mcp-test-tool" });
    const headerEl = toolEl.createDiv({ cls: "claudian-mcp-test-tool-header" });
    const iconEl = headerEl.createSpan({ cls: "claudian-mcp-test-tool-icon" });
    (0, import_obsidian24.setIcon)(iconEl, "wrench");
    const nameEl = headerEl.createSpan({ cls: "claudian-mcp-test-tool-name" });
    nameEl.setText(tool.name);
    const toggleEl = headerEl.createDiv({ cls: "claudian-mcp-test-tool-toggle" });
    const toggleContainer = toggleEl.createDiv({ cls: "checkbox-container" });
    const checkbox = toggleContainer.createEl("input", {
      type: "checkbox",
      attr: { tabindex: "0" }
    });
    const isEnabled = !this.disabledTools.has(tool.name);
    checkbox.checked = isEnabled;
    toggleContainer.toggleClass("is-enabled", isEnabled);
    this.updateToolState(toolEl, isEnabled);
    this.toolToggles.set(tool.name, { checkbox, container: toggleContainer });
    this.toolElements.set(tool.name, toolEl);
    if (!this.onToolToggle) {
      checkbox.disabled = true;
    } else {
      toggleContainer.addEventListener("click", (e2) => {
        e2.preventDefault();
        e2.stopPropagation();
        if (checkbox.disabled) return;
        checkbox.checked = !checkbox.checked;
        this.handleToolToggle(tool.name, checkbox, toggleContainer);
      });
    }
    if (tool.description) {
      const descEl = toolEl.createDiv({ cls: "claudian-mcp-test-tool-desc" });
      descEl.setText(tool.description);
    }
  }
  async handleToolToggle(toolName, checkbox, container) {
    var _a;
    const toolEl = this.toolElements.get(toolName);
    if (!toolEl) return;
    const wasDisabled = this.disabledTools.has(toolName);
    const nextDisabled = !checkbox.checked;
    if (nextDisabled) {
      this.disabledTools.add(toolName);
    } else {
      this.disabledTools.delete(toolName);
    }
    container.toggleClass("is-enabled", !nextDisabled);
    this.updateToolState(toolEl, !nextDisabled);
    this.updateToggleAllButton();
    checkbox.disabled = true;
    try {
      await ((_a = this.onToolToggle) == null ? void 0 : _a.call(this, toolName, !nextDisabled));
    } catch (error) {
      if (nextDisabled) {
        this.disabledTools.delete(toolName);
      } else {
        this.disabledTools.add(toolName);
      }
      checkbox.checked = !wasDisabled;
      container.toggleClass("is-enabled", !wasDisabled);
      this.updateToolState(toolEl, !wasDisabled);
      this.updateToggleAllButton();
      new import_obsidian24.Notice(formatToggleError(error));
    } finally {
      checkbox.disabled = false;
    }
  }
  updateToolState(toolEl, enabled) {
    toolEl.toggleClass("claudian-mcp-test-tool-disabled", !enabled);
  }
  updateToggleAllButton() {
    if (!this.toggleAllBtn || !this.result) return;
    const allEnabled = this.disabledTools.size === 0;
    const allDisabled = this.disabledTools.size === this.result.tools.length;
    if (allEnabled) {
      this.toggleAllBtn.setText("Disable All");
      this.toggleAllBtn.toggleClass("is-destructive", true);
    } else {
      this.toggleAllBtn.setText(allDisabled ? "Enable All" : "Enable All");
      this.toggleAllBtn.toggleClass("is-destructive", false);
    }
  }
  async handleToggleAll() {
    if (!this.result || this.pendingToggle || !this.onBulkToggle) return;
    const allEnabled = this.disabledTools.size === 0;
    const previousDisabled = new Set(this.disabledTools);
    const newDisabledTools = allEnabled ? this.result.tools.map((t2) => t2.name) : [];
    this.pendingToggle = true;
    if (this.toggleAllBtn) this.toggleAllBtn.disabled = true;
    for (const { checkbox } of this.toolToggles.values()) {
      checkbox.disabled = true;
    }
    this.disabledTools = new Set(newDisabledTools);
    for (const tool of this.result.tools) {
      const toggle = this.toolToggles.get(tool.name);
      const toolEl = this.toolElements.get(tool.name);
      if (!toggle || !toolEl) continue;
      const isEnabled = !this.disabledTools.has(tool.name);
      toggle.checkbox.checked = isEnabled;
      toggle.container.toggleClass("is-enabled", isEnabled);
      this.updateToolState(toolEl, isEnabled);
    }
    this.updateToggleAllButton();
    try {
      await this.onBulkToggle(newDisabledTools);
    } catch (error) {
      this.disabledTools = previousDisabled;
      for (const tool of this.result.tools) {
        const toggle = this.toolToggles.get(tool.name);
        const toolEl = this.toolElements.get(tool.name);
        if (!toggle || !toolEl) continue;
        const isEnabled = !this.disabledTools.has(tool.name);
        toggle.checkbox.checked = isEnabled;
        toggle.container.toggleClass("is-enabled", isEnabled);
        this.updateToolState(toolEl, isEnabled);
      }
      this.updateToggleAllButton();
      new import_obsidian24.Notice(formatToggleError(error));
    }
    for (const { checkbox } of this.toolToggles.values()) {
      checkbox.disabled = false;
    }
    this.pendingToggle = false;
    if (this.toggleAllBtn) this.toggleAllBtn.disabled = false;
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/features/settings/ui/McpSettingsManager.ts
var McpSettingsManager = class {
  constructor(containerEl, plugin) {
    this.servers = [];
    this.containerEl = containerEl;
    this.plugin = plugin;
    this.loadAndRender();
  }
  /**
   * Broadcasts MCP reload to all open Claudian views.
   * With multiple views open (split workspace), each view's tabs need to reload MCP config.
   */
  async broadcastMcpReloadToAllViews() {
    var _a;
    const views = this.plugin.getAllViews();
    for (const view of views) {
      await ((_a = view.getTabManager()) == null ? void 0 : _a.broadcastToAllTabs(
        (service) => service.reloadMcpServers()
      ));
    }
  }
  async loadAndRender() {
    this.servers = await this.plugin.storage.mcp.load();
    this.render();
  }
  render() {
    this.containerEl.empty();
    const headerEl = this.containerEl.createDiv({ cls: "claudian-mcp-header" });
    headerEl.createSpan({ text: "MCP Servers", cls: "claudian-mcp-label" });
    const addContainer = headerEl.createDiv({ cls: "claudian-mcp-add-container" });
    const addBtn = addContainer.createEl("button", {
      cls: "claudian-settings-action-btn",
      attr: { "aria-label": "Add" }
    });
    (0, import_obsidian25.setIcon)(addBtn, "plus");
    const dropdown = addContainer.createDiv({ cls: "claudian-mcp-add-dropdown" });
    const stdioOption = dropdown.createDiv({ cls: "claudian-mcp-add-option" });
    (0, import_obsidian25.setIcon)(stdioOption.createSpan({ cls: "claudian-mcp-add-option-icon" }), "terminal");
    stdioOption.createSpan({ text: "stdio (local command)" });
    stdioOption.addEventListener("click", () => {
      dropdown.removeClass("is-visible");
      this.openModal(null, "stdio");
    });
    const httpOption = dropdown.createDiv({ cls: "claudian-mcp-add-option" });
    (0, import_obsidian25.setIcon)(httpOption.createSpan({ cls: "claudian-mcp-add-option-icon" }), "globe");
    httpOption.createSpan({ text: "http / sse (remote)" });
    httpOption.addEventListener("click", () => {
      dropdown.removeClass("is-visible");
      this.openModal(null, "http");
    });
    const importOption = dropdown.createDiv({ cls: "claudian-mcp-add-option" });
    (0, import_obsidian25.setIcon)(importOption.createSpan({ cls: "claudian-mcp-add-option-icon" }), "clipboard-paste");
    importOption.createSpan({ text: "Import from clipboard" });
    importOption.addEventListener("click", () => {
      dropdown.removeClass("is-visible");
      this.importFromClipboard();
    });
    addBtn.addEventListener("click", (e2) => {
      e2.stopPropagation();
      dropdown.toggleClass("is-visible", !dropdown.hasClass("is-visible"));
    });
    document.addEventListener("click", () => {
      dropdown.removeClass("is-visible");
    });
    if (this.servers.length === 0) {
      const emptyEl = this.containerEl.createDiv({ cls: "claudian-mcp-empty" });
      emptyEl.setText('No MCP servers configured. Click "Add" to add one.');
      return;
    }
    const listEl = this.containerEl.createDiv({ cls: "claudian-mcp-list" });
    for (const server of this.servers) {
      this.renderServerItem(listEl, server);
    }
  }
  renderServerItem(listEl, server) {
    const itemEl = listEl.createDiv({ cls: "claudian-mcp-item" });
    if (!server.enabled) {
      itemEl.addClass("claudian-mcp-item-disabled");
    }
    const statusEl = itemEl.createDiv({ cls: "claudian-mcp-status" });
    statusEl.addClass(
      server.enabled ? "claudian-mcp-status-enabled" : "claudian-mcp-status-disabled"
    );
    const infoEl = itemEl.createDiv({ cls: "claudian-mcp-info" });
    const nameRow = infoEl.createDiv({ cls: "claudian-mcp-name-row" });
    const nameEl = nameRow.createSpan({ cls: "claudian-mcp-name" });
    nameEl.setText(server.name);
    const serverType = getMcpServerType(server.config);
    const typeEl = nameRow.createSpan({ cls: "claudian-mcp-type-badge" });
    typeEl.setText(serverType);
    if (server.contextSaving) {
      const csEl = nameRow.createSpan({ cls: "claudian-mcp-context-saving-badge" });
      csEl.setText("@");
      csEl.setAttribute("title", "Context-saving: mention with @" + server.name + " to enable");
    }
    const previewEl = infoEl.createDiv({ cls: "claudian-mcp-preview" });
    if (server.description) {
      previewEl.setText(server.description);
    } else {
      previewEl.setText(this.getServerPreview(server, serverType));
    }
    const actionsEl = itemEl.createDiv({ cls: "claudian-mcp-actions" });
    const testBtn = actionsEl.createEl("button", {
      cls: "claudian-mcp-action-btn",
      attr: { "aria-label": "Verify (show tools)" }
    });
    (0, import_obsidian25.setIcon)(testBtn, "zap");
    testBtn.addEventListener("click", () => this.testServer(server));
    const toggleBtn = actionsEl.createEl("button", {
      cls: "claudian-mcp-action-btn",
      attr: { "aria-label": server.enabled ? "Disable" : "Enable" }
    });
    (0, import_obsidian25.setIcon)(toggleBtn, server.enabled ? "toggle-right" : "toggle-left");
    toggleBtn.addEventListener("click", () => this.toggleServer(server));
    const editBtn = actionsEl.createEl("button", {
      cls: "claudian-mcp-action-btn",
      attr: { "aria-label": "Edit" }
    });
    (0, import_obsidian25.setIcon)(editBtn, "pencil");
    editBtn.addEventListener("click", () => this.openModal(server));
    const deleteBtn = actionsEl.createEl("button", {
      cls: "claudian-mcp-action-btn claudian-mcp-delete-btn",
      attr: { "aria-label": "Delete" }
    });
    (0, import_obsidian25.setIcon)(deleteBtn, "trash-2");
    deleteBtn.addEventListener("click", () => this.deleteServer(server));
  }
  async testServer(server) {
    const modal = new McpTestModal(
      this.plugin.app,
      server.name,
      server.disabledTools,
      async (toolName, enabled) => {
        await this.updateDisabledTool(server, toolName, enabled);
      },
      async (disabledTools) => {
        await this.updateAllDisabledTools(server, disabledTools);
      }
    );
    modal.open();
    try {
      const result = await testMcpServer(server);
      modal.setResult(result);
    } catch (error) {
      modal.setError(error instanceof Error ? error.message : "Verification failed");
    }
  }
  /** Rolls back on save failure; warns on reload failure (since save succeeded). */
  async updateServerDisabledTools(server, newDisabledTools) {
    const previous = server.disabledTools ? [...server.disabledTools] : void 0;
    server.disabledTools = newDisabledTools;
    try {
      await this.plugin.storage.mcp.save(this.servers);
    } catch (error) {
      server.disabledTools = previous;
      throw error;
    }
    try {
      await this.broadcastMcpReloadToAllViews();
    } catch (e2) {
      new import_obsidian25.Notice("Setting saved but reload failed. Changes will apply on next session.");
    }
  }
  async updateDisabledTool(server, toolName, enabled) {
    var _a;
    const disabledTools = new Set((_a = server.disabledTools) != null ? _a : []);
    if (enabled) {
      disabledTools.delete(toolName);
    } else {
      disabledTools.add(toolName);
    }
    await this.updateServerDisabledTools(
      server,
      disabledTools.size > 0 ? Array.from(disabledTools) : void 0
    );
  }
  async updateAllDisabledTools(server, disabledTools) {
    await this.updateServerDisabledTools(
      server,
      disabledTools.length > 0 ? disabledTools : void 0
    );
  }
  getServerPreview(server, type) {
    var _a;
    if (type === "stdio") {
      const config = server.config;
      const args = ((_a = config.args) == null ? void 0 : _a.join(" ")) || "";
      return args ? `${config.command} ${args}` : config.command;
    } else {
      const config = server.config;
      return config.url;
    }
  }
  openModal(existing, initialType) {
    const modal = new McpServerModal(
      this.plugin.app,
      this.plugin,
      existing,
      async (server) => {
        await this.saveServer(server, existing);
      },
      initialType
    );
    modal.open();
  }
  async importFromClipboard() {
    try {
      const text = await navigator.clipboard.readText();
      if (!text.trim()) {
        new import_obsidian25.Notice("Clipboard is empty");
        return;
      }
      const parsed = McpStorage.tryParseClipboardConfig(text);
      if (!parsed || parsed.servers.length === 0) {
        new import_obsidian25.Notice("No valid MCP configuration found in clipboard");
        return;
      }
      if (parsed.needsName || parsed.servers.length === 1) {
        const server = parsed.servers[0];
        const type = getMcpServerType(server.config);
        const modal = new McpServerModal(
          this.plugin.app,
          this.plugin,
          null,
          async (savedServer) => {
            await this.saveServer(savedServer, null);
          },
          type,
          server
          // Pre-fill with parsed config
        );
        modal.open();
        if (parsed.needsName) {
          new import_obsidian25.Notice("Enter a name for the server");
        }
        return;
      }
      await this.importServers(parsed.servers);
    } catch (e2) {
      new import_obsidian25.Notice("Failed to read clipboard");
    }
  }
  async saveServer(server, existing) {
    if (existing) {
      const index = this.servers.findIndex((s) => s.name === existing.name);
      if (index !== -1) {
        if (server.name !== existing.name) {
          const conflict = this.servers.find((s) => s.name === server.name);
          if (conflict) {
            new import_obsidian25.Notice(`Server "${server.name}" already exists`);
            return;
          }
        }
        this.servers[index] = server;
      }
    } else {
      const conflict = this.servers.find((s) => s.name === server.name);
      if (conflict) {
        new import_obsidian25.Notice(`Server "${server.name}" already exists`);
        return;
      }
      this.servers.push(server);
    }
    await this.plugin.storage.mcp.save(this.servers);
    await this.broadcastMcpReloadToAllViews();
    this.render();
    new import_obsidian25.Notice(existing ? `MCP server "${server.name}" updated` : `MCP server "${server.name}" added`);
  }
  async importServers(servers) {
    const added = [];
    const skipped = [];
    for (const server of servers) {
      const name = server.name.trim();
      if (!name || !/^[a-zA-Z0-9._-]+$/.test(name)) {
        skipped.push(server.name || "<unnamed>");
        continue;
      }
      const conflict = this.servers.find((s) => s.name === name);
      if (conflict) {
        skipped.push(name);
        continue;
      }
      this.servers.push({
        name,
        config: server.config,
        enabled: DEFAULT_MCP_SERVER.enabled,
        contextSaving: DEFAULT_MCP_SERVER.contextSaving
      });
      added.push(name);
    }
    if (added.length === 0) {
      new import_obsidian25.Notice("No new MCP servers imported");
      return;
    }
    await this.plugin.storage.mcp.save(this.servers);
    await this.broadcastMcpReloadToAllViews();
    this.render();
    let message = `Imported ${added.length} MCP server${added.length > 1 ? "s" : ""}`;
    if (skipped.length > 0) {
      message += ` (${skipped.length} skipped)`;
    }
    new import_obsidian25.Notice(message);
  }
  async toggleServer(server) {
    server.enabled = !server.enabled;
    await this.plugin.storage.mcp.save(this.servers);
    await this.broadcastMcpReloadToAllViews();
    this.render();
    new import_obsidian25.Notice(`MCP server "${server.name}" ${server.enabled ? "enabled" : "disabled"}`);
  }
  async deleteServer(server) {
    if (!confirm(`Delete MCP server "${server.name}"?`)) {
      return;
    }
    this.servers = this.servers.filter((s) => s.name !== server.name);
    await this.plugin.storage.mcp.save(this.servers);
    await this.broadcastMcpReloadToAllViews();
    this.render();
    new import_obsidian25.Notice(`MCP server "${server.name}" deleted`);
  }
  /** Refresh the server list (call after external changes). */
  refresh() {
    this.loadAndRender();
  }
};

// src/features/settings/ui/PluginSettingsManager.ts
var import_obsidian26 = require("obsidian");
var PluginSettingsManager = class {
  constructor(containerEl, plugin) {
    this.containerEl = containerEl;
    this.plugin = plugin;
    this.render();
  }
  render() {
    this.containerEl.empty();
    const headerEl = this.containerEl.createDiv({ cls: "claudian-plugin-header" });
    headerEl.createSpan({ text: "Claude Code Plugins", cls: "claudian-plugin-label" });
    const refreshBtn = headerEl.createEl("button", {
      cls: "claudian-settings-action-btn",
      attr: { "aria-label": "Refresh" }
    });
    (0, import_obsidian26.setIcon)(refreshBtn, "refresh-cw");
    refreshBtn.addEventListener("click", () => this.refreshPlugins());
    const plugins = this.plugin.pluginManager.getPlugins();
    if (plugins.length === 0) {
      const emptyEl = this.containerEl.createDiv({ cls: "claudian-plugin-empty" });
      emptyEl.setText("No Claude Code plugins installed. Install plugins via the Claude CLI.");
      return;
    }
    const projectLocalPlugins = plugins.filter((p2) => p2.scope === "project" || p2.scope === "local");
    const userPlugins = plugins.filter((p2) => p2.scope === "user");
    const listEl = this.containerEl.createDiv({ cls: "claudian-plugin-list" });
    if (projectLocalPlugins.length > 0) {
      const sectionHeader = listEl.createDiv({ cls: "claudian-plugin-section-header" });
      sectionHeader.setText("Project Plugins");
      for (const plugin of projectLocalPlugins) {
        this.renderPluginItem(listEl, plugin);
      }
    }
    if (userPlugins.length > 0) {
      const sectionHeader = listEl.createDiv({ cls: "claudian-plugin-section-header" });
      sectionHeader.setText("User Plugins");
      for (const plugin of userPlugins) {
        this.renderPluginItem(listEl, plugin);
      }
    }
  }
  renderPluginItem(listEl, plugin) {
    const itemEl = listEl.createDiv({ cls: "claudian-plugin-item" });
    if (!plugin.enabled) {
      itemEl.addClass("claudian-plugin-item-disabled");
    }
    if (plugin.status !== "available") {
      itemEl.addClass("claudian-plugin-item-error");
    }
    const statusEl = itemEl.createDiv({ cls: "claudian-plugin-status" });
    if (plugin.status !== "available") {
      statusEl.addClass("claudian-plugin-status-error");
    } else if (plugin.enabled) {
      statusEl.addClass("claudian-plugin-status-enabled");
    } else {
      statusEl.addClass("claudian-plugin-status-disabled");
    }
    const infoEl = itemEl.createDiv({ cls: "claudian-plugin-info" });
    const nameRow = infoEl.createDiv({ cls: "claudian-plugin-name-row" });
    const nameEl = nameRow.createSpan({ cls: "claudian-plugin-name" });
    nameEl.setText(plugin.name);
    const scopeEl = nameRow.createSpan({ cls: "claudian-plugin-scope-badge" });
    scopeEl.setText(this.getScopeLabel(plugin.scope));
    if (plugin.status !== "available") {
      const errorEl = nameRow.createSpan({ cls: "claudian-plugin-error-badge" });
      errorEl.setText(plugin.status === "unavailable" ? "Unavailable" : "Invalid");
    }
    const previewEl = infoEl.createDiv({ cls: "claudian-plugin-preview" });
    if (plugin.error) {
      previewEl.setText(plugin.error);
      previewEl.addClass("claudian-plugin-preview-error");
    } else if (plugin.description) {
      previewEl.setText(plugin.description);
    } else {
      previewEl.setText(plugin.id);
    }
    const actionsEl = itemEl.createDiv({ cls: "claudian-plugin-actions" });
    if (plugin.status === "available") {
      const toggleBtn = actionsEl.createEl("button", {
        cls: "claudian-plugin-action-btn",
        attr: { "aria-label": plugin.enabled ? "Disable" : "Enable" }
      });
      (0, import_obsidian26.setIcon)(toggleBtn, plugin.enabled ? "toggle-right" : "toggle-left");
      toggleBtn.addEventListener("click", () => this.togglePlugin(plugin.id));
    }
  }
  getScopeLabel(scope) {
    switch (scope) {
      case "user":
        return "User";
      case "project":
        return "Project";
      case "local":
        return "Local";
    }
  }
  async togglePlugin(pluginId) {
    var _a;
    const plugin = this.plugin.pluginManager.getPlugins().find((p2) => p2.id === pluginId);
    const wasEnabled = (_a = plugin == null ? void 0 : plugin.enabled) != null ? _a : false;
    try {
      await this.plugin.pluginManager.togglePlugin(pluginId);
      this.plugin.loadPluginSlashCommands();
      await this.plugin.agentManager.loadAgents();
      const view = this.plugin.getView();
      const tabManager = view == null ? void 0 : view.getTabManager();
      if (tabManager) {
        try {
          await tabManager.broadcastToAllTabs(
            async (service) => {
              await service.ensureReady({ force: true });
            }
          );
        } catch (e2) {
          new import_obsidian26.Notice("Plugin toggled, but some tabs failed to restart.");
        }
      }
      if (plugin) {
        new import_obsidian26.Notice(`Plugin "${plugin.name}" ${wasEnabled ? "disabled" : "enabled"}`);
      }
    } catch (err) {
      await this.plugin.pluginManager.togglePlugin(pluginId);
      const message = err instanceof Error ? err.message : "Unknown error";
      new import_obsidian26.Notice(`Failed to toggle plugin: ${message}`);
    } finally {
      this.render();
    }
  }
  async refreshPlugins() {
    try {
      await this.plugin.pluginManager.loadPlugins();
      this.plugin.loadPluginSlashCommands();
      await this.plugin.agentManager.loadAgents();
      new import_obsidian26.Notice("Plugin list refreshed");
    } catch (err) {
      const message = err instanceof Error ? err.message : "Unknown error";
      new import_obsidian26.Notice(`Failed to refresh plugins: ${message}`);
    } finally {
      this.render();
    }
  }
  refresh() {
    this.render();
  }
};

// src/features/settings/ui/SlashCommandSettings.ts
var import_obsidian27 = require("obsidian");
function isUserCommand(cmd) {
  return !cmd.id.startsWith("plugin-");
}
var SlashCommandModal = class extends import_obsidian27.Modal {
  constructor(app, plugin, existingCmd, onSave) {
    super(app);
    this.plugin = plugin;
    this.existingCmd = existingCmd;
    this.onSave = onSave;
  }
  onOpen() {
    this.setTitle(this.existingCmd ? "Edit Slash Command" : "Add Slash Command");
    this.modalEl.addClass("claudian-slash-modal");
    const { contentEl } = this;
    let nameInput;
    let descInput;
    let hintInput;
    let modelInput;
    let toolsInput;
    new import_obsidian27.Setting(contentEl).setName("Command name").setDesc('The name used after / (e.g., "review" for /review)').addText((text) => {
      var _a;
      nameInput = text.inputEl;
      text.setValue(((_a = this.existingCmd) == null ? void 0 : _a.name) || "").setPlaceholder("review-code");
    });
    new import_obsidian27.Setting(contentEl).setName("Description").setDesc("Optional description shown in dropdown").addText((text) => {
      var _a;
      descInput = text.inputEl;
      text.setValue(((_a = this.existingCmd) == null ? void 0 : _a.description) || "");
    });
    new import_obsidian27.Setting(contentEl).setName("Argument hint").setDesc('Placeholder text for arguments (e.g., "[file] [focus]")').addText((text) => {
      var _a;
      hintInput = text.inputEl;
      text.setValue(((_a = this.existingCmd) == null ? void 0 : _a.argumentHint) || "");
    });
    new import_obsidian27.Setting(contentEl).setName("Model override").setDesc("Optional model to use for this command").addText((text) => {
      var _a;
      modelInput = text.inputEl;
      text.setValue(((_a = this.existingCmd) == null ? void 0 : _a.model) || "").setPlaceholder("claude-sonnet-4-5");
    });
    new import_obsidian27.Setting(contentEl).setName("Allowed tools").setDesc("Comma-separated list of tools to allow (empty = all)").addText((text) => {
      var _a, _b;
      toolsInput = text.inputEl;
      text.setValue(((_b = (_a = this.existingCmd) == null ? void 0 : _a.allowedTools) == null ? void 0 : _b.join(", ")) || "");
    });
    new import_obsidian27.Setting(contentEl).setName("Prompt template").setDesc("Use $ARGUMENTS, $1, $2, @file, !`bash`");
    const contentArea = contentEl.createEl("textarea", {
      cls: "claudian-slash-content-area",
      attr: {
        rows: "10",
        placeholder: "Review this code for:\n$ARGUMENTS\n\n@$1"
      }
    });
    const initialContent = this.existingCmd ? parseSlashCommandContent(this.existingCmd.content).promptContent : "";
    contentArea.value = initialContent;
    const buttonContainer = contentEl.createDiv({ cls: "claudian-slash-modal-buttons" });
    const cancelBtn = buttonContainer.createEl("button", {
      text: "Cancel",
      cls: "claudian-cancel-btn"
    });
    cancelBtn.addEventListener("click", () => this.close());
    const saveBtn = buttonContainer.createEl("button", {
      text: "Save",
      cls: "claudian-save-btn"
    });
    saveBtn.addEventListener("click", async () => {
      var _a;
      const name = nameInput.value.trim();
      if (!name) {
        new import_obsidian27.Notice("Command name is required");
        return;
      }
      const content = contentArea.value;
      if (!content.trim()) {
        new import_obsidian27.Notice("Prompt template is required");
        return;
      }
      if (!/^[a-zA-Z0-9_/-]+$/.test(name)) {
        new import_obsidian27.Notice("Command name can only contain letters, numbers, hyphens, underscores, and slashes");
        return;
      }
      const existing = this.plugin.settings.slashCommands.find(
        (c3) => {
          var _a2;
          return c3.name.toLowerCase() === name.toLowerCase() && c3.id !== ((_a2 = this.existingCmd) == null ? void 0 : _a2.id);
        }
      );
      if (existing) {
        new import_obsidian27.Notice(`A command named "/${name}" already exists`);
        return;
      }
      const parsed = parseSlashCommandContent(content);
      const promptContent = parsed.promptContent;
      const cmd = {
        id: ((_a = this.existingCmd) == null ? void 0 : _a.id) || `cmd-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`,
        name,
        description: descInput.value.trim() || parsed.description || void 0,
        argumentHint: hintInput.value.trim() || parsed.argumentHint || void 0,
        model: modelInput.value.trim() || parsed.model || void 0,
        allowedTools: toolsInput.value.trim() ? toolsInput.value.split(",").map((s) => s.trim()).filter(Boolean) : parsed.allowedTools && parsed.allowedTools.length > 0 ? parsed.allowedTools : void 0,
        content: promptContent
      };
      this.onSave(cmd);
      this.close();
    });
    const handleKeyDown = (e2) => {
      if (e2.key === "Escape") {
        e2.preventDefault();
        this.close();
      }
    };
    contentEl.addEventListener("keydown", handleKeyDown);
  }
  onClose() {
    this.contentEl.empty();
  }
};
var SlashCommandSettings = class {
  constructor(containerEl, plugin) {
    this.containerEl = containerEl;
    this.plugin = plugin;
    this.render();
  }
  render() {
    this.containerEl.empty();
    const headerEl = this.containerEl.createDiv({ cls: "claudian-slash-header" });
    headerEl.createSpan({ text: "Slash Commands", cls: "claudian-slash-label" });
    const actionsEl = headerEl.createDiv({ cls: "claudian-slash-header-actions" });
    const importBtn = actionsEl.createEl("button", {
      cls: "claudian-settings-action-btn",
      attr: { "aria-label": "Import" }
    });
    (0, import_obsidian27.setIcon)(importBtn, "download");
    importBtn.addEventListener("click", () => this.importCommands());
    const exportBtn = actionsEl.createEl("button", {
      cls: "claudian-settings-action-btn",
      attr: { "aria-label": "Export" }
    });
    (0, import_obsidian27.setIcon)(exportBtn, "upload");
    exportBtn.addEventListener("click", () => this.exportCommands());
    const addBtn = actionsEl.createEl("button", {
      cls: "claudian-settings-action-btn",
      attr: { "aria-label": "Add" }
    });
    (0, import_obsidian27.setIcon)(addBtn, "plus");
    addBtn.addEventListener("click", () => this.openCommandModal(null));
    const commands = this.plugin.settings.slashCommands.filter(isUserCommand);
    if (commands.length === 0) {
      const emptyEl = this.containerEl.createDiv({ cls: "claudian-slash-empty-state" });
      emptyEl.setText('No slash commands configured. Click "Add" to create one.');
      return;
    }
    const listEl = this.containerEl.createDiv({ cls: "claudian-slash-list" });
    for (const cmd of commands) {
      this.renderCommandItem(listEl, cmd);
    }
  }
  renderCommandItem(listEl, cmd) {
    const itemEl = listEl.createDiv({ cls: "claudian-slash-item-settings" });
    const infoEl = itemEl.createDiv({ cls: "claudian-slash-info" });
    const headerRow = infoEl.createDiv({ cls: "claudian-slash-item-header" });
    const nameEl = headerRow.createSpan({ cls: "claudian-slash-item-name" });
    nameEl.setText(`/${cmd.name}`);
    if (cmd.argumentHint) {
      const hintEl = headerRow.createSpan({ cls: "claudian-slash-item-hint" });
      hintEl.setText(cmd.argumentHint);
    }
    if (cmd.description) {
      const descEl = infoEl.createDiv({ cls: "claudian-slash-item-desc" });
      descEl.setText(cmd.description);
    }
    const actionsEl = itemEl.createDiv({ cls: "claudian-slash-item-actions" });
    const editBtn = actionsEl.createEl("button", {
      cls: "claudian-settings-action-btn",
      attr: { "aria-label": "Edit" }
    });
    (0, import_obsidian27.setIcon)(editBtn, "pencil");
    editBtn.addEventListener("click", () => this.openCommandModal(cmd));
    const deleteBtn = actionsEl.createEl("button", {
      cls: "claudian-settings-action-btn claudian-settings-delete-btn",
      attr: { "aria-label": "Delete" }
    });
    (0, import_obsidian27.setIcon)(deleteBtn, "trash-2");
    deleteBtn.addEventListener("click", async () => {
      try {
        await this.deleteCommand(cmd);
      } catch (e2) {
        new import_obsidian27.Notice("Failed to delete slash command");
      }
    });
  }
  openCommandModal(existingCmd) {
    const modal = new SlashCommandModal(
      this.plugin.app,
      this.plugin,
      existingCmd,
      async (cmd) => {
        await this.saveCommand(cmd, existingCmd);
      }
    );
    modal.open();
  }
  async saveCommand(cmd, existing) {
    await this.plugin.storage.commands.save(cmd);
    if (existing && existing.name !== cmd.name) {
      await this.plugin.storage.commands.delete(existing.id);
    }
    await this.reloadCommands();
    this.render();
    new import_obsidian27.Notice(`Slash command "/${cmd.name}" ${existing ? "updated" : "created"}`);
  }
  async deleteCommand(cmd) {
    await this.plugin.storage.commands.delete(cmd.id);
    await this.reloadCommands();
    this.render();
    new import_obsidian27.Notice(`Slash command "/${cmd.name}" deleted`);
  }
  async reloadCommands() {
    const commands = await this.plugin.storage.commands.loadAll();
    this.plugin.settings.slashCommands = commands;
  }
  exportCommands() {
    const commands = this.plugin.settings.slashCommands.filter(isUserCommand);
    if (commands.length === 0) {
      new import_obsidian27.Notice("No slash commands to export");
      return;
    }
    const json = JSON.stringify(commands, null, 2);
    const blob = new Blob([json], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "claudian-slash-commands.json";
    a.click();
    URL.revokeObjectURL(url);
    new import_obsidian27.Notice(`Exported ${commands.length} slash command(s)`);
  }
  importCommands() {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = ".json";
    input.addEventListener("change", async (e2) => {
      var _a;
      const file = (_a = e2.target.files) == null ? void 0 : _a[0];
      if (!file) return;
      try {
        const text = await file.text();
        const commands = JSON.parse(text);
        if (!Array.isArray(commands)) {
          throw new Error("Invalid format: expected an array");
        }
        const existingCommands = await this.plugin.storage.commands.loadAll();
        const existingNames = new Set(existingCommands.map((c3) => c3.name.toLowerCase()));
        let imported = 0;
        for (const cmd of commands) {
          if (!cmd.name || !cmd.content) {
            continue;
          }
          if (typeof cmd.name !== "string" || typeof cmd.content !== "string") {
            continue;
          }
          if (!/^[a-zA-Z0-9_/:-]+$/.test(cmd.name)) {
            continue;
          }
          cmd.id = `cmd-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
          if (cmd.allowedTools && !Array.isArray(cmd.allowedTools)) {
            cmd.allowedTools = void 0;
          }
          if (Array.isArray(cmd.allowedTools)) {
            cmd.allowedTools = cmd.allowedTools.filter((t2) => typeof t2 === "string" && t2.trim().length > 0);
            if (cmd.allowedTools.length === 0) {
              cmd.allowedTools = void 0;
            }
          }
          if (cmd.description && typeof cmd.description !== "string") {
            cmd.description = void 0;
          }
          if (cmd.argumentHint && typeof cmd.argumentHint !== "string") {
            cmd.argumentHint = void 0;
          }
          if (cmd.model && typeof cmd.model !== "string") {
            cmd.model = void 0;
          }
          const parsed = parseSlashCommandContent(cmd.content);
          cmd.description = cmd.description || parsed.description;
          cmd.argumentHint = cmd.argumentHint || parsed.argumentHint;
          cmd.model = cmd.model || parsed.model;
          cmd.allowedTools = cmd.allowedTools || parsed.allowedTools;
          cmd.content = parsed.promptContent;
          if (existingNames.has(cmd.name.toLowerCase())) {
            continue;
          }
          await this.plugin.storage.commands.save(cmd);
          existingNames.add(cmd.name.toLowerCase());
          imported++;
        }
        await this.reloadCommands();
        this.render();
        new import_obsidian27.Notice(`Imported ${imported} slash command(s)`);
      } catch (e3) {
        new import_obsidian27.Notice("Failed to import slash commands. Check file format.");
      }
    });
    input.click();
  }
  refresh() {
    this.render();
  }
};

// src/features/settings/ClaudianSettings.ts
function formatHotkey(hotkey) {
  const isMac = navigator.platform.includes("Mac");
  const modMap = isMac ? { Mod: "\u2318", Ctrl: "\u2303", Alt: "\u2325", Shift: "\u21E7", Meta: "\u2318" } : { Mod: "Ctrl", Ctrl: "Ctrl", Alt: "Alt", Shift: "Shift", Meta: "Win" };
  const mods = hotkey.modifiers.map((m) => modMap[m] || m);
  const key = hotkey.key.length === 1 ? hotkey.key.toUpperCase() : hotkey.key;
  return isMac ? [...mods, key].join("") : [...mods, key].join("+");
}
function openHotkeySettings(app) {
  const setting = app.setting;
  setting.open();
  setting.openTabById("hotkeys");
  setTimeout(() => {
    var _a, _b, _c;
    const tab = setting.activeTab;
    if (tab) {
      const searchEl = (_b = tab.searchInputEl) != null ? _b : (_a = tab.searchComponent) == null ? void 0 : _a.inputEl;
      if (searchEl) {
        searchEl.value = "Claudian";
        (_c = tab.updateHotkeyVisibility) == null ? void 0 : _c.call(tab);
      }
    }
  }, 100);
}
function getHotkeyForCommand(app, commandId) {
  var _a, _b;
  const hotkeyManager = app.hotkeyManager;
  if (!hotkeyManager) return null;
  const customHotkeys = (_a = hotkeyManager.customKeys) == null ? void 0 : _a[commandId];
  const defaultHotkeys = (_b = hotkeyManager.defaultKeys) == null ? void 0 : _b[commandId];
  const hotkeys = (customHotkeys == null ? void 0 : customHotkeys.length) > 0 ? customHotkeys : defaultHotkeys;
  if (!hotkeys || hotkeys.length === 0) return null;
  return hotkeys.map(formatHotkey).join(", ");
}
function addHotkeySettingRow(containerEl, app, commandId, translationPrefix) {
  const hotkey = getHotkeyForCommand(app, commandId);
  new import_obsidian28.Setting(containerEl).setName(t(`${translationPrefix}.name`)).setDesc(hotkey ? t(`${translationPrefix}.descWithKey`, { hotkey }) : t(`${translationPrefix}.descNoKey`)).addButton(
    (button) => button.setButtonText(hotkey ? t(`${translationPrefix}.btnChange`) : t(`${translationPrefix}.btnSet`)).onClick(() => openHotkeySettings(app))
  );
}
var ClaudianSettingTab = class extends import_obsidian28.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.contextLimitsContainer = null;
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass("claudian-settings");
    setLocale(this.plugin.settings.locale);
    new import_obsidian28.Setting(containerEl).setName(t("settings.language.name")).setDesc(t("settings.language.desc")).addDropdown((dropdown) => {
      const locales = getAvailableLocales();
      for (const locale of locales) {
        dropdown.addOption(locale, getLocaleDisplayName(locale));
      }
      dropdown.setValue(this.plugin.settings.locale).onChange(async (value) => {
        if (!setLocale(value)) {
          dropdown.setValue(this.plugin.settings.locale);
          return;
        }
        this.plugin.settings.locale = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    new import_obsidian28.Setting(containerEl).setName(t("settings.customization")).setHeading();
    new import_obsidian28.Setting(containerEl).setName(t("settings.userName.name")).setDesc(t("settings.userName.desc")).addText((text) => {
      text.setPlaceholder(t("settings.userName.name")).setValue(this.plugin.settings.userName).onChange(async (value) => {
        this.plugin.settings.userName = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.addEventListener("blur", () => this.restartServiceForPromptChange());
    });
    new import_obsidian28.Setting(containerEl).setName(t("settings.excludedTags.name")).setDesc(t("settings.excludedTags.desc")).addTextArea((text) => {
      text.setPlaceholder("system\nprivate\ndraft").setValue(this.plugin.settings.excludedTags.join("\n")).onChange(async (value) => {
        this.plugin.settings.excludedTags = value.split(/\r?\n/).map((s) => s.trim().replace(/^#/, "")).filter((s) => s.length > 0);
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 4;
      text.inputEl.cols = 30;
    });
    new import_obsidian28.Setting(containerEl).setName(t("settings.mediaFolder.name")).setDesc(t("settings.mediaFolder.desc")).addText((text) => {
      text.setPlaceholder("attachments").setValue(this.plugin.settings.mediaFolder).onChange(async (value) => {
        this.plugin.settings.mediaFolder = value.trim();
        await this.plugin.saveSettings();
      });
      text.inputEl.addClass("claudian-settings-media-input");
      text.inputEl.addEventListener("blur", () => this.restartServiceForPromptChange());
    });
    new import_obsidian28.Setting(containerEl).setName(t("settings.systemPrompt.name")).setDesc(t("settings.systemPrompt.desc")).addTextArea((text) => {
      text.setPlaceholder(t("settings.systemPrompt.name")).setValue(this.plugin.settings.systemPrompt).onChange(async (value) => {
        this.plugin.settings.systemPrompt = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 6;
      text.inputEl.cols = 50;
      text.inputEl.addEventListener("blur", () => this.restartServiceForPromptChange());
    });
    new import_obsidian28.Setting(containerEl).setName(t("settings.enableAutoScroll.name")).setDesc(t("settings.enableAutoScroll.desc")).addToggle(
      (toggle) => {
        var _a;
        return toggle.setValue((_a = this.plugin.settings.enableAutoScroll) != null ? _a : true).onChange(async (value) => {
          this.plugin.settings.enableAutoScroll = value;
          await this.plugin.saveSettings();
        });
      }
    );
    new import_obsidian28.Setting(containerEl).setName(t("settings.autoTitle.name")).setDesc(t("settings.autoTitle.desc")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableAutoTitleGeneration).onChange(async (value) => {
        this.plugin.settings.enableAutoTitleGeneration = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.enableAutoTitleGeneration) {
      new import_obsidian28.Setting(containerEl).setName(t("settings.titleModel.name")).setDesc(t("settings.titleModel.desc")).addDropdown((dropdown) => {
        dropdown.addOption("", t("settings.titleModel.auto"));
        const envVars = parseEnvironmentVariables(this.plugin.settings.environmentVariables);
        const customModels = getModelsFromEnvironment(envVars);
        const models = customModels.length > 0 ? customModels : DEFAULT_CLAUDE_MODELS;
        for (const model of models) {
          dropdown.addOption(model.value, model.label);
        }
        dropdown.setValue(this.plugin.settings.titleGenerationModel || "").onChange(async (value) => {
          this.plugin.settings.titleGenerationModel = value;
          await this.plugin.saveSettings();
        });
      });
    }
    new import_obsidian28.Setting(containerEl).setName(t("settings.navMappings.name")).setDesc(t("settings.navMappings.desc")).addTextArea((text) => {
      let pendingValue = buildNavMappingText(this.plugin.settings.keyboardNavigation);
      let saveTimeout = null;
      const commitValue = async (showError) => {
        if (saveTimeout !== null) {
          window.clearTimeout(saveTimeout);
          saveTimeout = null;
        }
        const result = parseNavMappings(pendingValue);
        if (!result.settings) {
          if (showError) {
            new import_obsidian28.Notice(`${t("common.error")}: ${result.error}`);
            pendingValue = buildNavMappingText(this.plugin.settings.keyboardNavigation);
            text.setValue(pendingValue);
          }
          return;
        }
        this.plugin.settings.keyboardNavigation.scrollUpKey = result.settings.scrollUp;
        this.plugin.settings.keyboardNavigation.scrollDownKey = result.settings.scrollDown;
        this.plugin.settings.keyboardNavigation.focusInputKey = result.settings.focusInput;
        await this.plugin.saveSettings();
        pendingValue = buildNavMappingText(this.plugin.settings.keyboardNavigation);
        text.setValue(pendingValue);
      };
      const scheduleSave = () => {
        if (saveTimeout !== null) {
          window.clearTimeout(saveTimeout);
        }
        saveTimeout = window.setTimeout(() => {
          void commitValue(false);
        }, 500);
      };
      text.setPlaceholder("map w scrollUp\nmap s scrollDown\nmap i focusInput").setValue(pendingValue).onChange((value) => {
        pendingValue = value;
        scheduleSave();
      });
      text.inputEl.rows = 3;
      text.inputEl.addEventListener("blur", async () => {
        await commitValue(true);
      });
    });
    new import_obsidian28.Setting(containerEl).setName(t("settings.tabBarPosition.name")).setDesc(t("settings.tabBarPosition.desc")).addDropdown((dropdown) => {
      var _a;
      dropdown.addOption("input", t("settings.tabBarPosition.input")).addOption("header", t("settings.tabBarPosition.header")).setValue((_a = this.plugin.settings.tabBarPosition) != null ? _a : "input").onChange(async (value) => {
        this.plugin.settings.tabBarPosition = value;
        await this.plugin.saveSettings();
        for (const leaf of this.plugin.app.workspace.getLeavesOfType("claudian-view")) {
          if (leaf.view instanceof ClaudianView) {
            leaf.view.updateLayoutForPosition();
          }
        }
      });
    });
    new import_obsidian28.Setting(containerEl).setName(t("settings.hotkeys")).setHeading();
    addHotkeySettingRow(containerEl, this.app, "claudian:inline-edit", "settings.inlineEditHotkey");
    addHotkeySettingRow(containerEl, this.app, "claudian:open-view", "settings.openChatHotkey");
    addHotkeySettingRow(containerEl, this.app, "claudian:new-session", "settings.newSessionHotkey");
    addHotkeySettingRow(containerEl, this.app, "claudian:new-tab", "settings.newTabHotkey");
    addHotkeySettingRow(containerEl, this.app, "claudian:close-current-tab", "settings.closeTabHotkey");
    new import_obsidian28.Setting(containerEl).setName(t("settings.slashCommands.name")).setHeading();
    const slashCommandsDesc = containerEl.createDiv({ cls: "claudian-slash-settings-desc" });
    slashCommandsDesc.createEl("p", {
      text: t("settings.slashCommands.desc"),
      cls: "setting-item-description"
    });
    const slashCommandsContainer = containerEl.createDiv({ cls: "claudian-slash-commands-container" });
    new SlashCommandSettings(slashCommandsContainer, this.plugin);
    new import_obsidian28.Setting(containerEl).setName(t("settings.hiddenSlashCommands.name")).setDesc(t("settings.hiddenSlashCommands.desc")).addTextArea((text) => {
      text.setPlaceholder(t("settings.hiddenSlashCommands.placeholder")).setValue((this.plugin.settings.hiddenSlashCommands || []).join("\n")).onChange(async (value) => {
        var _a;
        this.plugin.settings.hiddenSlashCommands = value.split(/\r?\n/).map((s) => s.trim().replace(/^\//, "")).filter((s) => s.length > 0);
        await this.plugin.saveSettings();
        (_a = this.plugin.getView()) == null ? void 0 : _a.updateHiddenSlashCommands();
      });
      text.inputEl.rows = 4;
      text.inputEl.cols = 30;
    });
    new import_obsidian28.Setting(containerEl).setName(t("settings.mcpServers.name")).setHeading();
    const mcpDesc = containerEl.createDiv({ cls: "claudian-mcp-settings-desc" });
    mcpDesc.createEl("p", {
      text: t("settings.mcpServers.desc"),
      cls: "setting-item-description"
    });
    const mcpContainer = containerEl.createDiv({ cls: "claudian-mcp-container" });
    new McpSettingsManager(mcpContainer, this.plugin);
    new import_obsidian28.Setting(containerEl).setName(t("settings.plugins.name")).setHeading();
    const pluginsDesc = containerEl.createDiv({ cls: "claudian-plugin-settings-desc" });
    pluginsDesc.createEl("p", {
      text: t("settings.plugins.desc"),
      cls: "setting-item-description"
    });
    const pluginsContainer = containerEl.createDiv({ cls: "claudian-plugins-container" });
    new PluginSettingsManager(pluginsContainer, this.plugin);
    new import_obsidian28.Setting(containerEl).setName(t("settings.safety")).setHeading();
    new import_obsidian28.Setting(containerEl).setName(t("settings.loadUserSettings.name")).setDesc(t("settings.loadUserSettings.desc")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.loadUserClaudeSettings).onChange(async (value) => {
        this.plugin.settings.loadUserClaudeSettings = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian28.Setting(containerEl).setName(t("settings.enableBlocklist.name")).setDesc(t("settings.enableBlocklist.desc")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableBlocklist).onChange(async (value) => {
        this.plugin.settings.enableBlocklist = value;
        await this.plugin.saveSettings();
      })
    );
    const platformKey = getCurrentPlatformKey();
    const isWindows2 = platformKey === "windows";
    const platformLabel = isWindows2 ? "Windows" : "Unix";
    new import_obsidian28.Setting(containerEl).setName(t("settings.blockedCommands.name", { platform: platformLabel })).setDesc(t("settings.blockedCommands.desc", { platform: platformLabel })).addTextArea((text) => {
      const placeholder = isWindows2 ? "del /s /q\nrd /s /q\nRemove-Item -Recurse -Force" : "rm -rf\nchmod 777\nmkfs";
      text.setPlaceholder(placeholder).setValue(this.plugin.settings.blockedCommands[platformKey].join("\n")).onChange(async (value) => {
        this.plugin.settings.blockedCommands[platformKey] = value.split(/\r?\n/).map((s) => s.trim()).filter((s) => s.length > 0);
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 6;
      text.inputEl.cols = 40;
    });
    if (isWindows2) {
      new import_obsidian28.Setting(containerEl).setName(t("settings.blockedCommands.unixName")).setDesc(t("settings.blockedCommands.unixDesc")).addTextArea((text) => {
        text.setPlaceholder("rm -rf\nchmod 777\nmkfs").setValue(this.plugin.settings.blockedCommands.unix.join("\n")).onChange(async (value) => {
          this.plugin.settings.blockedCommands.unix = value.split(/\r?\n/).map((s) => s.trim()).filter((s) => s.length > 0);
          await this.plugin.saveSettings();
        });
        text.inputEl.rows = 4;
        text.inputEl.cols = 40;
      });
    }
    new import_obsidian28.Setting(containerEl).setName(t("settings.exportPaths.name")).setDesc(t("settings.exportPaths.desc")).addTextArea((text) => {
      const placeholder = process.platform === "win32" ? "~/Desktop\n~/Downloads\n%TEMP%" : "~/Desktop\n~/Downloads\n/tmp";
      text.setPlaceholder(placeholder).setValue(this.plugin.settings.allowedExportPaths.join("\n")).onChange(async (value) => {
        this.plugin.settings.allowedExportPaths = value.split(/\r?\n/).map((s) => s.trim()).filter((s) => s.length > 0);
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 4;
      text.inputEl.cols = 40;
      text.inputEl.addEventListener("blur", () => this.restartServiceForPromptChange());
    });
    new import_obsidian28.Setting(containerEl).setName(t("settings.environment")).setHeading();
    new import_obsidian28.Setting(containerEl).setName(t("settings.customVariables.name")).setDesc(t("settings.customVariables.desc")).addTextArea((text) => {
      text.setPlaceholder("ANTHROPIC_API_KEY=your-key\nANTHROPIC_BASE_URL=https://api.example.com\nANTHROPIC_MODEL=custom-model").setValue(this.plugin.settings.environmentVariables);
      text.inputEl.rows = 6;
      text.inputEl.cols = 50;
      text.inputEl.addClass("claudian-settings-env-textarea");
      text.inputEl.addEventListener("blur", async () => {
        await this.plugin.applyEnvironmentVariables(text.inputEl.value);
        this.renderContextLimitsSection();
      });
    });
    this.contextLimitsContainer = containerEl.createDiv({ cls: "claudian-context-limits-container" });
    this.renderContextLimitsSection();
    const envSnippetsContainer = containerEl.createDiv({ cls: "claudian-env-snippets-container" });
    new EnvSnippetManager(envSnippetsContainer, this.plugin, () => {
      this.renderContextLimitsSection();
    });
    new import_obsidian28.Setting(containerEl).setName(t("settings.advanced")).setHeading();
    new import_obsidian28.Setting(containerEl).setName(t("settings.show1MModel.name")).setDesc(t("settings.show1MModel.desc")).addToggle(
      (toggle) => {
        var _a;
        return toggle.setValue((_a = this.plugin.settings.show1MModel) != null ? _a : false).onChange(async (value) => {
          var _a2;
          this.plugin.settings.show1MModel = value;
          await this.plugin.saveSettings();
          const view = (_a2 = this.plugin.app.workspace.getLeavesOfType("claudian-view")[0]) == null ? void 0 : _a2.view;
          view == null ? void 0 : view.refreshModelSelector();
        });
      }
    );
    new import_obsidian28.Setting(containerEl).setName(t("settings.enableChrome.name")).setDesc(t("settings.enableChrome.desc")).addToggle(
      (toggle) => {
        var _a;
        return toggle.setValue((_a = this.plugin.settings.enableChrome) != null ? _a : false).onChange(async (value) => {
          this.plugin.settings.enableChrome = value;
          await this.plugin.saveSettings();
        });
      }
    );
    const maxTabsSetting = new import_obsidian28.Setting(containerEl).setName(t("settings.maxTabs.name")).setDesc(t("settings.maxTabs.desc"));
    const maxTabsWarningEl = containerEl.createDiv({ cls: "claudian-max-tabs-warning" });
    maxTabsWarningEl.style.color = "var(--text-warning)";
    maxTabsWarningEl.style.fontSize = "0.85em";
    maxTabsWarningEl.style.marginTop = "-0.5em";
    maxTabsWarningEl.style.marginBottom = "0.5em";
    maxTabsWarningEl.style.display = "none";
    maxTabsWarningEl.setText(t("settings.maxTabs.warning"));
    const updateMaxTabsWarning = (value) => {
      maxTabsWarningEl.style.display = value > 5 ? "block" : "none";
    };
    maxTabsSetting.addSlider((slider) => {
      var _a, _b;
      slider.setLimits(3, 10, 1).setValue((_a = this.plugin.settings.maxTabs) != null ? _a : 3).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.maxTabs = value;
        await this.plugin.saveSettings();
        updateMaxTabsWarning(value);
      });
      updateMaxTabsWarning((_b = this.plugin.settings.maxTabs) != null ? _b : 3);
    });
    const hostnameKey = getHostnameKey();
    const platformDesc = process.platform === "win32" ? t("settings.cliPath.descWindows") : t("settings.cliPath.descUnix");
    const cliPathDescription = `${t("settings.cliPath.desc")} ${platformDesc}`;
    const cliPathSetting = new import_obsidian28.Setting(containerEl).setName(`${t("settings.cliPath.name")} (${hostnameKey})`).setDesc(cliPathDescription);
    const validationEl = containerEl.createDiv({ cls: "claudian-cli-path-validation" });
    validationEl.style.color = "var(--text-error)";
    validationEl.style.fontSize = "0.85em";
    validationEl.style.marginTop = "-0.5em";
    validationEl.style.marginBottom = "0.5em";
    validationEl.style.display = "none";
    const validatePath = (value) => {
      const trimmed = value.trim();
      if (!trimmed) return null;
      const expandedPath = expandHomePath(trimmed);
      if (!fs7.existsSync(expandedPath)) {
        return t("settings.cliPath.validation.notExist");
      }
      const stat = fs7.statSync(expandedPath);
      if (!stat.isFile()) {
        return t("settings.cliPath.validation.isDirectory");
      }
      return null;
    };
    cliPathSetting.addText((text) => {
      var _a;
      const placeholder = process.platform === "win32" ? "D:\\nodejs\\node_global\\node_modules\\@anthropic-ai\\claude-code\\cli.js" : "/usr/local/lib/node_modules/@anthropic-ai/claude-code/cli.js";
      const currentValue = ((_a = this.plugin.settings.claudeCliPathsByHost) == null ? void 0 : _a[hostnameKey]) || "";
      text.setPlaceholder(placeholder).setValue(currentValue).onChange(async (value) => {
        var _a2, _b;
        const error = validatePath(value);
        if (error) {
          validationEl.setText(error);
          validationEl.style.display = "block";
          text.inputEl.style.borderColor = "var(--text-error)";
        } else {
          validationEl.style.display = "none";
          text.inputEl.style.borderColor = "";
        }
        const trimmed = value.trim();
        if (!this.plugin.settings.claudeCliPathsByHost) {
          this.plugin.settings.claudeCliPathsByHost = {};
        }
        this.plugin.settings.claudeCliPathsByHost[hostnameKey] = trimmed;
        await this.plugin.saveSettings();
        (_a2 = this.plugin.cliResolver) == null ? void 0 : _a2.reset();
        const view = this.plugin.getView();
        await ((_b = view == null ? void 0 : view.getTabManager()) == null ? void 0 : _b.broadcastToAllTabs(
          (service) => Promise.resolve(service.cleanup())
        ));
      });
      text.inputEl.addClass("claudian-settings-cli-path-input");
      text.inputEl.style.width = "100%";
      const initialError = validatePath(currentValue);
      if (initialError) {
        validationEl.setText(initialError);
        validationEl.style.display = "block";
        text.inputEl.style.borderColor = "var(--text-error)";
      }
    });
  }
  renderContextLimitsSection() {
    var _a;
    const container = this.contextLimitsContainer;
    if (!container) return;
    container.empty();
    const envVars = parseEnvironmentVariables(this.plugin.settings.environmentVariables);
    const uniqueModelIds = getCustomModelIds(envVars);
    if (uniqueModelIds.size === 0) {
      return;
    }
    const headerEl = container.createDiv({ cls: "claudian-context-limits-header" });
    headerEl.createSpan({ text: t("settings.customContextLimits.name"), cls: "claudian-context-limits-label" });
    const descEl = container.createDiv({ cls: "claudian-context-limits-desc" });
    descEl.setText(t("settings.customContextLimits.desc"));
    const listEl = container.createDiv({ cls: "claudian-context-limits-list" });
    for (const modelId of uniqueModelIds) {
      const currentValue = (_a = this.plugin.settings.customContextLimits) == null ? void 0 : _a[modelId];
      const itemEl = listEl.createDiv({ cls: "claudian-context-limits-item" });
      const nameEl = itemEl.createDiv({ cls: "claudian-context-limits-model" });
      nameEl.setText(modelId);
      const inputWrapper = itemEl.createDiv({ cls: "claudian-context-limits-input-wrapper" });
      const inputEl = inputWrapper.createEl("input", {
        type: "text",
        placeholder: "200k",
        cls: "claudian-context-limits-input",
        value: currentValue ? formatContextLimit(currentValue) : ""
      });
      const validationEl = inputWrapper.createDiv({ cls: "claudian-context-limit-validation" });
      inputEl.addEventListener("input", async () => {
        const trimmed = inputEl.value.trim();
        if (!this.plugin.settings.customContextLimits) {
          this.plugin.settings.customContextLimits = {};
        }
        if (!trimmed) {
          delete this.plugin.settings.customContextLimits[modelId];
          validationEl.style.display = "none";
          inputEl.classList.remove("claudian-input-error");
        } else {
          const parsed = parseContextLimit(trimmed);
          if (parsed === null) {
            validationEl.setText(t("settings.customContextLimits.invalid"));
            validationEl.style.display = "block";
            inputEl.classList.add("claudian-input-error");
            return;
          }
          this.plugin.settings.customContextLimits[modelId] = parsed;
          validationEl.style.display = "none";
          inputEl.classList.remove("claudian-input-error");
        }
        await this.plugin.saveSettings();
      });
    }
  }
  async restartServiceForPromptChange() {
    const view = this.plugin.getView();
    const tabManager = view == null ? void 0 : view.getTabManager();
    if (!tabManager) return;
    try {
      await tabManager.broadcastToAllTabs(
        async (service) => {
          await service.ensureReady({ force: true });
        }
      );
    } catch (e2) {
    }
  }
};

// src/utils/claudeCli.ts
var fs8 = __toESM(require("fs"));
var ClaudeCliResolver = class {
  constructor() {
    this.resolvedPath = null;
    this.lastHostnamePath = "";
    this.lastLegacyPath = "";
    this.lastEnvText = "";
    // Cache hostname since it doesn't change during a session
    this.cachedHostname = getHostnameKey();
  }
  /**
   * Resolves CLI path with priority: hostname-specific -> legacy -> auto-detect.
   * @param hostnamePaths Per-device CLI paths keyed by hostname (preferred)
   * @param legacyPath Legacy claudeCliPath (for backwards compatibility)
   * @param envText Environment variables text
   */
  resolve(hostnamePaths, legacyPath, envText) {
    var _a;
    const hostnameKey = this.cachedHostname;
    const hostnamePath = ((_a = hostnamePaths == null ? void 0 : hostnamePaths[hostnameKey]) != null ? _a : "").trim();
    const normalizedLegacy = (legacyPath != null ? legacyPath : "").trim();
    const normalizedEnv = envText != null ? envText : "";
    if (this.resolvedPath && hostnamePath === this.lastHostnamePath && normalizedLegacy === this.lastLegacyPath && normalizedEnv === this.lastEnvText) {
      return this.resolvedPath;
    }
    this.lastHostnamePath = hostnamePath;
    this.lastLegacyPath = normalizedLegacy;
    this.lastEnvText = normalizedEnv;
    this.resolvedPath = resolveClaudeCliPath(hostnamePath, normalizedLegacy, normalizedEnv);
    return this.resolvedPath;
  }
  reset() {
    this.resolvedPath = null;
    this.lastHostnamePath = "";
    this.lastLegacyPath = "";
    this.lastEnvText = "";
  }
};
function resolveClaudeCliPath(hostnamePath, legacyPath, envText) {
  const trimmedHostname = (hostnamePath != null ? hostnamePath : "").trim();
  if (trimmedHostname) {
    try {
      const expandedPath = expandHomePath(trimmedHostname);
      if (fs8.existsSync(expandedPath)) {
        const stat = fs8.statSync(expandedPath);
        if (stat.isFile()) {
          return expandedPath;
        }
      }
    } catch (e2) {
    }
  }
  const trimmedLegacy = (legacyPath != null ? legacyPath : "").trim();
  if (trimmedLegacy) {
    try {
      const expandedPath = expandHomePath(trimmedLegacy);
      if (fs8.existsSync(expandedPath)) {
        const stat = fs8.statSync(expandedPath);
        if (stat.isFile()) {
          return expandedPath;
        }
      }
    } catch (e2) {
    }
  }
  const customEnv = parseEnvironmentVariables(envText || "");
  return findClaudeCLIPath(customEnv.PATH);
}

// src/utils/sdkSession.ts
var import_fs3 = require("fs");
var fs9 = __toESM(require("fs/promises"));
var os5 = __toESM(require("os"));
var path9 = __toESM(require("path"));
function encodeVaultPathForSDK(vaultPath) {
  const absolutePath = path9.resolve(vaultPath);
  return absolutePath.replace(/[^a-zA-Z0-9]/g, "-");
}
function getSDKProjectsPath() {
  return path9.join(os5.homedir(), ".claude", "projects");
}
function isValidSessionId(sessionId) {
  if (!sessionId || sessionId.length === 0 || sessionId.length > 128) {
    return false;
  }
  if (sessionId.includes("..") || sessionId.includes("/") || sessionId.includes("\\")) {
    return false;
  }
  return /^[a-zA-Z0-9_-]+$/.test(sessionId);
}
function getSDKSessionPath(vaultPath, sessionId) {
  if (!isValidSessionId(sessionId)) {
    throw new Error(`Invalid session ID: ${sessionId}`);
  }
  const projectsPath = getSDKProjectsPath();
  const encodedVault = encodeVaultPathForSDK(vaultPath);
  return path9.join(projectsPath, encodedVault, `${sessionId}.jsonl`);
}
function sdkSessionExists(vaultPath, sessionId) {
  try {
    const sessionPath = getSDKSessionPath(vaultPath, sessionId);
    return (0, import_fs3.existsSync)(sessionPath);
  } catch (e2) {
    return false;
  }
}
async function deleteSDKSession(vaultPath, sessionId) {
  try {
    const sessionPath = getSDKSessionPath(vaultPath, sessionId);
    if (!(0, import_fs3.existsSync)(sessionPath)) return;
    await fs9.unlink(sessionPath);
  } catch (e2) {
  }
}
async function readSDKSession(vaultPath, sessionId) {
  try {
    const sessionPath = getSDKSessionPath(vaultPath, sessionId);
    if (!(0, import_fs3.existsSync)(sessionPath)) {
      return { messages: [], skippedLines: 0 };
    }
    const content = await fs9.readFile(sessionPath, "utf-8");
    const lines = content.split("\n").filter((line) => line.trim());
    const messages = [];
    let skippedLines = 0;
    for (const line of lines) {
      try {
        const msg = JSON.parse(line);
        messages.push(msg);
      } catch (e2) {
        skippedLines++;
      }
    }
    return { messages, skippedLines };
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : String(error);
    return { messages: [], skippedLines: 0, error: errorMsg };
  }
}
function extractTextContent(content) {
  if (!content) return "";
  if (typeof content === "string") return content;
  return content.filter(
    (block) => block.type === "text" && typeof block.text === "string"
  ).map((block) => block.text).join("\n");
}
function isRebuiltContextContent(textContent) {
  if (!/^(User|Assistant):\s/.test(textContent)) return false;
  return textContent.includes("\n\nUser:") || textContent.includes("\n\nAssistant:") || textContent.includes("\n\nA:");
}
function extractDisplayContent(textContent) {
  return extractContentBeforeXmlContext(textContent);
}
function extractImages(content) {
  if (!content || typeof content === "string") return void 0;
  const imageBlocks = content.filter(
    (block) => {
      var _a;
      return block.type === "image" && !!((_a = block.source) == null ? void 0 : _a.data);
    }
  );
  if (imageBlocks.length === 0) return void 0;
  return imageBlocks.map((block, index) => ({
    id: `sdk-img-${Date.now()}-${index}`,
    name: `image-${index + 1}`,
    mediaType: block.source.media_type,
    data: block.source.data,
    size: Math.ceil(block.source.data.length * 0.75),
    // Approximate original size from base64
    source: "paste"
  }));
}
function extractToolCalls(content, toolResults) {
  var _a;
  if (!content || typeof content === "string") return void 0;
  const toolUses = content.filter(
    (block) => block.type === "tool_use" && !!block.id && !!block.name
  );
  if (toolUses.length === 0) return void 0;
  const results = toolResults != null ? toolResults : /* @__PURE__ */ new Map();
  if (!toolResults) {
    for (const block of content) {
      if (block.type === "tool_result" && block.tool_use_id) {
        const resultContent = typeof block.content === "string" ? block.content : JSON.stringify(block.content);
        results.set(block.tool_use_id, {
          content: resultContent,
          isError: (_a = block.is_error) != null ? _a : false
        });
      }
    }
  }
  return toolUses.map((block) => {
    var _a2;
    const result = results.get(block.id);
    return {
      id: block.id,
      name: block.name,
      input: (_a2 = block.input) != null ? _a2 : {},
      status: result ? result.isError ? "error" : "completed" : "completed",
      result: result == null ? void 0 : result.content,
      isExpanded: false
    };
  });
}
function mapContentBlocks(content) {
  if (!content || typeof content === "string") return void 0;
  const blocks = [];
  for (const block of content) {
    switch (block.type) {
      case "text":
        if (block.text && block.text.trim()) {
          blocks.push({ type: "text", content: block.text.trim() });
        }
        break;
      case "thinking":
        if (block.thinking) {
          blocks.push({ type: "thinking", content: block.thinking });
        }
        break;
      case "tool_use":
        if (block.id) {
          blocks.push({ type: "tool_use", toolId: block.id });
        }
        break;
    }
  }
  return blocks.length > 0 ? blocks : void 0;
}
function parseSDKMessageToChat(sdkMsg, toolResults) {
  var _a;
  if (sdkMsg.type === "file-history-snapshot") return null;
  if (sdkMsg.type === "system") return null;
  if (sdkMsg.type === "result") return null;
  if (sdkMsg.type !== "user" && sdkMsg.type !== "assistant") return null;
  const content = (_a = sdkMsg.message) == null ? void 0 : _a.content;
  const textContent = extractTextContent(content);
  const images = sdkMsg.type === "user" ? extractImages(content) : void 0;
  const hasToolUse = Array.isArray(content) && content.some((b3) => b3.type === "tool_use");
  const hasImages = images && images.length > 0;
  if (!textContent && !hasToolUse && !hasImages && (!content || typeof content === "string")) return null;
  const timestamp = sdkMsg.timestamp ? new Date(sdkMsg.timestamp).getTime() : Date.now();
  const displayContent = sdkMsg.type === "user" ? extractDisplayContent(textContent) : void 0;
  const isInterrupt = sdkMsg.type === "user" && (textContent === "[Request interrupted by user]" || textContent === "[Request interrupted by user for tool use]");
  const isRebuiltContext = sdkMsg.type === "user" && isRebuiltContextContent(textContent);
  return {
    id: sdkMsg.uuid || `sdk-${timestamp}-${Math.random().toString(36).slice(2)}`,
    role: sdkMsg.type,
    content: textContent,
    displayContent,
    timestamp,
    toolCalls: sdkMsg.type === "assistant" ? extractToolCalls(content, toolResults) : void 0,
    contentBlocks: sdkMsg.type === "assistant" ? mapContentBlocks(content) : void 0,
    images,
    ...isInterrupt && { isInterrupt: true },
    ...isRebuiltContext && { isRebuiltContext: true }
  };
}
function collectToolResults(sdkMessages) {
  var _a, _b;
  const results = /* @__PURE__ */ new Map();
  for (const sdkMsg of sdkMessages) {
    const content = (_a = sdkMsg.message) == null ? void 0 : _a.content;
    if (!content || typeof content === "string") continue;
    for (const block of content) {
      if (block.type === "tool_result" && block.tool_use_id) {
        const resultContent = typeof block.content === "string" ? block.content : JSON.stringify(block.content);
        results.set(block.tool_use_id, {
          content: resultContent,
          isError: (_b = block.is_error) != null ? _b : false
        });
      }
    }
  }
  return results;
}
function collectStructuredPatchResults(sdkMessages) {
  var _a;
  const results = /* @__PURE__ */ new Map();
  for (const sdkMsg of sdkMessages) {
    if (sdkMsg.type !== "user" || !sdkMsg.toolUseResult) continue;
    const content = (_a = sdkMsg.message) == null ? void 0 : _a.content;
    if (!content || typeof content === "string") continue;
    for (const block of content) {
      if (block.type === "tool_result" && block.tool_use_id) {
        results.set(block.tool_use_id, sdkMsg.toolUseResult);
      }
    }
  }
  return results;
}
function isSystemInjectedMessage(sdkMsg) {
  if (sdkMsg.type !== "user") return false;
  return "toolUseResult" in sdkMsg || "sourceToolUseID" in sdkMsg || !!sdkMsg.isMeta;
}
function mergeAssistantMessage(target, source) {
  if (source.content) {
    if (target.content) {
      target.content = target.content + "\n\n" + source.content;
    } else {
      target.content = source.content;
    }
  }
  if (source.toolCalls) {
    target.toolCalls = [...target.toolCalls || [], ...source.toolCalls];
  }
  if (source.contentBlocks) {
    target.contentBlocks = [...target.contentBlocks || [], ...source.contentBlocks];
  }
}
async function loadSDKSessionMessages(vaultPath, sessionId) {
  const result = await readSDKSession(vaultPath, sessionId);
  if (result.error) {
    return { messages: [], skippedLines: result.skippedLines, error: result.error };
  }
  const toolResults = collectToolResults(result.messages);
  const toolUseResults = collectStructuredPatchResults(result.messages);
  const chatMessages = [];
  let pendingAssistant = null;
  for (const sdkMsg of result.messages) {
    if (isSystemInjectedMessage(sdkMsg)) continue;
    const chatMsg = parseSDKMessageToChat(sdkMsg, toolResults);
    if (!chatMsg) continue;
    if (chatMsg.role === "assistant") {
      if (pendingAssistant) {
        mergeAssistantMessage(pendingAssistant, chatMsg);
      } else {
        pendingAssistant = chatMsg;
      }
    } else {
      if (pendingAssistant) {
        chatMessages.push(pendingAssistant);
        pendingAssistant = null;
      }
      chatMessages.push(chatMsg);
    }
  }
  if (pendingAssistant) {
    chatMessages.push(pendingAssistant);
  }
  if (toolUseResults.size > 0) {
    for (const msg of chatMessages) {
      if (msg.role !== "assistant" || !msg.toolCalls) continue;
      for (const toolCall of msg.toolCalls) {
        const toolUseResult = toolUseResults.get(toolCall.id);
        if (toolUseResult && !toolCall.diffData) {
          toolCall.diffData = extractDiffData(toolUseResult, toolCall);
        }
      }
    }
  }
  chatMessages.sort((a, b3) => a.timestamp - b3.timestamp);
  return { messages: chatMessages, skippedLines: result.skippedLines };
}

// src/main.ts
var ClaudianPlugin = class extends import_obsidian29.Plugin {
  constructor() {
    super(...arguments);
    this.conversations = [];
    this.runtimeEnvironmentVariables = "";
  }
  async onload() {
    await this.loadSettings();
    this.cliResolver = new ClaudeCliResolver();
    const mcpManager = new McpServerManager(this.storage.mcp);
    this.mcpService = new McpService(mcpManager);
    await this.mcpService.loadServers();
    const vaultPath = this.app.vault.adapter.basePath;
    const pluginStorage = new PluginStorage(vaultPath);
    this.pluginManager = new PluginManager(pluginStorage, this.storage.ccSettings);
    await this.pluginManager.loadEnabledState();
    await this.pluginManager.loadPlugins();
    this.agentManager = new AgentManager(vaultPath, this.pluginManager);
    await this.agentManager.loadAgents();
    this.loadPluginSlashCommands();
    this.registerView(
      VIEW_TYPE_CLAUDIAN,
      (leaf) => new ClaudianView(leaf, this)
    );
    this.addRibbonIcon("bot", "Open Claudian", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-view",
      name: "Open chat view",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "inline-edit",
      name: "Inline edit",
      editorCallback: async (editor, view) => {
        var _a;
        const selectedText = editor.getSelection();
        const notePath = ((_a = view.file) == null ? void 0 : _a.path) || "unknown";
        let editContext;
        if (selectedText.trim()) {
          editContext = { mode: "selection", selectedText };
        } else {
          const cursor = editor.getCursor();
          const cursorContext = buildCursorContext(
            (line) => editor.getLine(line),
            editor.lineCount(),
            cursor.line,
            cursor.ch
          );
          editContext = { mode: "cursor", cursorContext };
        }
        const modal = new InlineEditModal(this.app, this, editContext, notePath);
        const result = await modal.openAndWait();
        if (result.decision === "accept" && result.editedText !== void 0) {
          new import_obsidian29.Notice(editContext.mode === "cursor" ? "Inserted" : "Edit applied");
        }
      }
    });
    this.addCommand({
      id: "new-tab",
      name: "New tab",
      checkCallback: (checking) => {
        const leaf = this.app.workspace.getLeavesOfType(VIEW_TYPE_CLAUDIAN)[0];
        if (!leaf) return false;
        const view = leaf.view;
        const tabManager = view.getTabManager();
        if (!tabManager) return false;
        if (!tabManager.canCreateTab()) return false;
        if (!checking) {
          tabManager.createTab();
        }
        return true;
      }
    });
    this.addCommand({
      id: "new-session",
      name: "New session (in current tab)",
      checkCallback: (checking) => {
        const leaf = this.app.workspace.getLeavesOfType(VIEW_TYPE_CLAUDIAN)[0];
        if (!leaf) return false;
        const view = leaf.view;
        const tabManager = view.getTabManager();
        if (!tabManager) return false;
        const activeTab = tabManager.getActiveTab();
        if (!activeTab) return false;
        if (activeTab.state.isStreaming) return false;
        if (!checking) {
          tabManager.createNewConversation();
        }
        return true;
      }
    });
    this.addCommand({
      id: "close-current-tab",
      name: "Close current tab",
      checkCallback: (checking) => {
        const leaf = this.app.workspace.getLeavesOfType(VIEW_TYPE_CLAUDIAN)[0];
        if (!leaf) return false;
        const view = leaf.view;
        const tabManager = view.getTabManager();
        if (!tabManager) return false;
        if (!checking) {
          const activeTabId = tabManager.getActiveTabId();
          if (activeTabId) {
            tabManager.closeTab(activeTabId);
          }
        }
        return true;
      }
    });
    this.addSettingTab(new ClaudianSettingTab(this.app, this));
  }
  async onunload() {
    for (const view of this.getAllViews()) {
      const tabManager = view.getTabManager();
      if (tabManager) {
        const state = tabManager.getPersistedState();
        await this.storage.setTabManagerState(state);
      }
    }
  }
  /** Opens the Claudian sidebar view, creating it if necessary. */
  async activateView() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(VIEW_TYPE_CLAUDIAN)[0];
    if (!leaf) {
      const rightLeaf = workspace.getRightLeaf(false);
      if (rightLeaf) {
        await rightLeaf.setViewState({
          type: VIEW_TYPE_CLAUDIAN,
          active: true
        });
        leaf = rightLeaf;
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  /** Loads settings and conversations from persistent storage. */
  async loadSettings() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
    this.storage = new StorageService(this);
    const { claudian } = await this.storage.initialize();
    const slashCommands = await this.storage.commands.loadAll();
    this.settings = {
      ...DEFAULT_SETTINGS,
      ...claudian,
      slashCommands
    };
    (_b = (_a = this.settings).claudeCliPathsByHost) != null ? _b : _a.claudeCliPathsByHost = {};
    const hostname2 = getHostnameKey();
    let didMigrateCliPath = false;
    if (!this.settings.claudeCliPathsByHost[hostname2]) {
      const platformPaths = this.settings.claudeCliPaths;
      const migratedPath = ((_c = platformPaths == null ? void 0 : platformPaths[getCliPlatformKey()]) == null ? void 0 : _c.trim()) || ((_d = this.settings.claudeCliPath) == null ? void 0 : _d.trim());
      if (migratedPath) {
        this.settings.claudeCliPathsByHost[hostname2] = migratedPath;
        this.settings.claudeCliPath = "";
        didMigrateCliPath = true;
      }
    }
    delete this.settings.claudeCliPaths;
    const { conversations: legacyConversations, failedCount } = await this.storage.sessions.loadAllConversations();
    const legacyIds = new Set(legacyConversations.map((c3) => c3.id));
    for (const conversation of legacyConversations) {
      const meta = await this.storage.sessions.loadMetadata(conversation.id);
      if (!meta) continue;
      conversation.isNative = true;
      conversation.title = (_e = meta.title) != null ? _e : conversation.title;
      conversation.titleGenerationStatus = (_f = meta.titleGenerationStatus) != null ? _f : conversation.titleGenerationStatus;
      conversation.createdAt = (_g = meta.createdAt) != null ? _g : conversation.createdAt;
      conversation.updatedAt = (_h = meta.updatedAt) != null ? _h : conversation.updatedAt;
      conversation.lastResponseAt = (_i = meta.lastResponseAt) != null ? _i : conversation.lastResponseAt;
      if (meta.sessionId !== void 0) {
        conversation.sessionId = meta.sessionId;
      }
      conversation.currentNote = (_j = meta.currentNote) != null ? _j : conversation.currentNote;
      conversation.externalContextPaths = (_k = meta.externalContextPaths) != null ? _k : conversation.externalContextPaths;
      conversation.enabledMcpServers = (_l = meta.enabledMcpServers) != null ? _l : conversation.enabledMcpServers;
      conversation.usage = (_m = meta.usage) != null ? _m : conversation.usage;
      if (meta.sdkSessionId !== void 0) {
        conversation.sdkSessionId = meta.sdkSessionId;
      } else if (conversation.sdkSessionId === void 0 && conversation.sessionId) {
        conversation.sdkSessionId = conversation.sessionId;
      }
      conversation.previousSdkSessionIds = (_n = meta.previousSdkSessionIds) != null ? _n : conversation.previousSdkSessionIds;
      conversation.legacyCutoffAt = (_o = meta.legacyCutoffAt) != null ? _o : conversation.legacyCutoffAt;
    }
    const nativeMetadata = await this.storage.sessions.listNativeMetadata();
    const nativeConversations = nativeMetadata.filter((meta) => !legacyIds.has(meta.id)).map((meta) => {
      const resumeSessionId = meta.sessionId !== void 0 ? meta.sessionId : meta.id;
      const sdkSessionId = meta.sdkSessionId !== void 0 ? meta.sdkSessionId : resumeSessionId != null ? resumeSessionId : void 0;
      return {
        id: meta.id,
        title: meta.title,
        createdAt: meta.createdAt,
        updatedAt: meta.updatedAt,
        lastResponseAt: meta.lastResponseAt,
        sessionId: resumeSessionId,
        sdkSessionId,
        previousSdkSessionIds: meta.previousSdkSessionIds,
        messages: [],
        // Messages are in SDK storage, loaded on demand
        currentNote: meta.currentNote,
        externalContextPaths: meta.externalContextPaths,
        enabledMcpServers: meta.enabledMcpServers,
        usage: meta.usage,
        titleGenerationStatus: meta.titleGenerationStatus,
        legacyCutoffAt: meta.legacyCutoffAt,
        isNative: true,
        subagentData: meta.subagentData
        // Preserve for applying to loaded messages
      };
    });
    this.conversations = [...legacyConversations, ...nativeConversations].sort(
      (a, b3) => {
        var _a2, _b2;
        return ((_a2 = b3.lastResponseAt) != null ? _a2 : b3.updatedAt) - ((_b2 = a.lastResponseAt) != null ? _b2 : a.updatedAt);
      }
    );
    if (failedCount > 0) {
      new import_obsidian29.Notice(`Failed to load ${failedCount} conversation${failedCount > 1 ? "s" : ""}`);
    }
    setLocale(this.settings.locale);
    const backfilledConversations = this.backfillConversationResponseTimestamps();
    this.runtimeEnvironmentVariables = this.settings.environmentVariables || "";
    const { changed, invalidatedConversations } = this.reconcileModelWithEnvironment(this.runtimeEnvironmentVariables);
    if (changed || didMigrateCliPath) {
      await this.saveSettings();
    }
    const conversationsToSave = /* @__PURE__ */ new Set([...backfilledConversations, ...invalidatedConversations]);
    for (const conv of conversationsToSave) {
      if (conv.isNative) {
        await this.storage.sessions.saveMetadata(
          this.storage.sessions.toSessionMetadata(conv)
        );
      } else {
        await this.storage.sessions.saveConversation(conv);
      }
    }
  }
  backfillConversationResponseTimestamps() {
    const updated = [];
    for (const conv of this.conversations) {
      if (conv.lastResponseAt != null) continue;
      if (!conv.messages || conv.messages.length === 0) continue;
      for (let i2 = conv.messages.length - 1; i2 >= 0; i2--) {
        const msg = conv.messages[i2];
        if (msg.role === "assistant") {
          conv.lastResponseAt = msg.timestamp;
          updated.push(conv);
          break;
        }
      }
    }
    return updated;
  }
  /** Persists settings to storage. */
  async saveSettings() {
    const {
      slashCommands: _,
      ...settingsToSave
    } = this.settings;
    await this.storage.saveClaudianSettings(settingsToSave);
  }
  /**
   * Loads slash commands from enabled plugins and merges them with vault commands.
   * Plugin commands are namespaced with the plugin name (e.g., "plugin-name:command").
   */
  loadPluginSlashCommands() {
    const vaultCommands = this.settings.slashCommands.filter(
      (cmd) => !cmd.id.startsWith("plugin-")
    );
    const pluginPaths = this.pluginManager.getPluginCommandPaths();
    const pluginCommands = pluginPaths.flatMap(
      ({ pluginName, commandsPath }) => loadPluginCommands(commandsPath, pluginName)
    );
    this.settings.slashCommands = [...vaultCommands, ...pluginCommands];
  }
  /** Updates and persists environment variables, restarting processes to apply changes. */
  async applyEnvironmentVariables(envText) {
    var _a, _b, _c;
    const envChanged = envText !== this.runtimeEnvironmentVariables;
    this.settings.environmentVariables = envText;
    if (!envChanged) {
      await this.saveSettings();
      return;
    }
    this.runtimeEnvironmentVariables = envText;
    const { changed, invalidatedConversations } = this.reconcileModelWithEnvironment(envText);
    await this.saveSettings();
    if (invalidatedConversations.length > 0) {
      for (const conv of invalidatedConversations) {
        if (conv.isNative) {
          await this.storage.sessions.saveMetadata(
            this.storage.sessions.toSessionMetadata(conv)
          );
        } else {
          await this.storage.sessions.saveConversation(conv);
        }
      }
    }
    const view = this.getView();
    const tabManager = view == null ? void 0 : view.getTabManager();
    if (tabManager) {
      for (const tab of tabManager.getAllTabs()) {
        if (tab.state.isStreaming) {
          (_a = tab.controllers.inputController) == null ? void 0 : _a.cancelStreaming();
        }
      }
      let failedTabs = 0;
      if (changed) {
        for (const tab of tabManager.getAllTabs()) {
          if (!tab.service || !tab.serviceInitialized) {
            continue;
          }
          try {
            const externalContextPaths = (_c = (_b = tab.ui.externalContextSelector) == null ? void 0 : _b.getExternalContexts()) != null ? _c : [];
            tab.service.resetSession();
            await tab.service.ensureReady({ externalContextPaths });
          } catch (e2) {
            failedTabs++;
          }
        }
      } else {
        try {
          await tabManager.broadcastToAllTabs(
            async (service) => {
              await service.ensureReady({ force: true });
            }
          );
        } catch (e2) {
          failedTabs++;
        }
      }
      if (failedTabs > 0) {
        new import_obsidian29.Notice(`Environment changes applied, but ${failedTabs} tab(s) failed to restart.`);
      }
    }
    view == null ? void 0 : view.refreshModelSelector();
    const noticeText = changed ? "Environment variables applied. Sessions will be rebuilt on next message." : "Environment variables applied.";
    new import_obsidian29.Notice(noticeText);
  }
  /** Returns the runtime environment variables (fixed at plugin load). */
  getActiveEnvironmentVariables() {
    return this.runtimeEnvironmentVariables;
  }
  getResolvedClaudeCliPath() {
    return this.cliResolver.resolve(
      this.settings.claudeCliPathsByHost,
      // Per-device paths (preferred)
      this.settings.claudeCliPath,
      // Legacy path (fallback)
      this.getActiveEnvironmentVariables()
    );
  }
  getDefaultModelValues() {
    return DEFAULT_CLAUDE_MODELS.map((m) => m.value);
  }
  getPreferredCustomModel(envVars, customModels) {
    const envPreferred = getCurrentModelFromEnvironment(envVars);
    if (envPreferred && customModels.some((m) => m.value === envPreferred)) {
      return envPreferred;
    }
    return customModels[0].value;
  }
  /** Computes a hash of model and provider base URL environment variables for change detection. */
  computeEnvHash(envText) {
    const envVars = parseEnvironmentVariables(envText || "");
    const modelKeys = [
      "ANTHROPIC_MODEL",
      "ANTHROPIC_DEFAULT_OPUS_MODEL",
      "ANTHROPIC_DEFAULT_SONNET_MODEL",
      "ANTHROPIC_DEFAULT_HAIKU_MODEL"
    ];
    const providerKeys = [
      "ANTHROPIC_BASE_URL"
    ];
    const allKeys = [...modelKeys, ...providerKeys];
    const relevantPairs = allKeys.filter((key) => envVars[key]).map((key) => `${key}=${envVars[key]}`).sort().join("|");
    return relevantPairs;
  }
  /**
   * Reconciles model with environment.
   * Returns { changed, invalidatedConversations } where changed indicates if
   * settings were modified (requiring save), and invalidatedConversations lists
   * conversations that had their sessionId cleared (also requiring save).
   */
  reconcileModelWithEnvironment(envText) {
    const currentHash = this.computeEnvHash(envText);
    const savedHash = this.settings.lastEnvHash || "";
    if (currentHash === savedHash) {
      return { changed: false, invalidatedConversations: [] };
    }
    const invalidatedConversations = [];
    for (const conv of this.conversations) {
      if (conv.sessionId) {
        conv.sessionId = null;
        invalidatedConversations.push(conv);
      }
    }
    const envVars = parseEnvironmentVariables(envText || "");
    const customModels = getModelsFromEnvironment(envVars);
    if (customModels.length > 0) {
      this.settings.model = this.getPreferredCustomModel(envVars, customModels);
    } else {
      this.settings.model = DEFAULT_CLAUDE_MODELS[0].value;
    }
    this.settings.lastEnvHash = currentHash;
    return { changed: true, invalidatedConversations };
  }
  generateConversationId() {
    return `conv-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
  }
  generateDefaultTitle() {
    const now = /* @__PURE__ */ new Date();
    return now.toLocaleString(void 0, {
      month: "short",
      day: "numeric",
      hour: "2-digit",
      minute: "2-digit"
    });
  }
  getConversationPreview(conv) {
    const firstUserMsg = conv.messages.find((m) => m.role === "user");
    if (!firstUserMsg) {
      return conv.isNative ? "SDK session" : "New conversation";
    }
    return firstUserMsg.content.substring(0, 50) + (firstUserMsg.content.length > 50 ? "..." : "");
  }
  async loadSdkMessagesForConversation(conversation) {
    var _a;
    if (!conversation.isNative || conversation.sdkMessagesLoaded) return;
    const vaultPath = getVaultPath(this.app);
    if (!vaultPath) return;
    const allSessionIds = [
      ...conversation.previousSdkSessionIds || [],
      (_a = conversation.sdkSessionId) != null ? _a : conversation.sessionId
    ].filter((id) => !!id);
    if (allSessionIds.length === 0) return;
    const allSdkMessages = [];
    let missingSessionCount = 0;
    let errorCount = 0;
    let successCount = 0;
    for (const sessionId of allSessionIds) {
      if (!sdkSessionExists(vaultPath, sessionId)) {
        missingSessionCount++;
        continue;
      }
      const result = await loadSDKSessionMessages(vaultPath, sessionId);
      if (result.error) {
        errorCount++;
        continue;
      }
      successCount++;
      allSdkMessages.push(...result.messages);
    }
    const allSessionsMissing = missingSessionCount === allSessionIds.length;
    const hasLoadErrors = errorCount > 0 && successCount === 0 && !allSessionsMissing;
    if (hasLoadErrors) {
      return;
    }
    const filteredSdkMessages = allSdkMessages.filter((msg) => !msg.isRebuiltContext);
    const afterCutoff = conversation.legacyCutoffAt != null ? filteredSdkMessages.filter((msg) => msg.timestamp > conversation.legacyCutoffAt) : filteredSdkMessages;
    const merged = this.dedupeMessages([
      ...conversation.messages,
      ...afterCutoff
    ]).sort((a, b3) => a.timestamp - b3.timestamp);
    if (conversation.subagentData) {
      this.applySubagentData(merged, conversation.subagentData);
    }
    conversation.messages = merged;
    conversation.sdkMessagesLoaded = true;
  }
  /**
   * Applies cached subagentData to messages.
   * Restores subagent info so Task tools can show tool count and status.
   * Also updates contentBlocks to properly identify Task tools as subagents.
   */
  applySubagentData(messages, subagentData) {
    var _a;
    for (const msg of messages) {
      if (msg.role !== "assistant") continue;
      for (const [subagentId, subagent] of Object.entries(subagentData)) {
        if (!msg.subagents) {
          msg.subagents = [];
        }
        const hasSubagentBlock = (_a = msg.contentBlocks) == null ? void 0 : _a.some(
          (b3) => b3.type === "subagent" && b3.subagentId === subagentId || b3.type === "tool_use" && b3.toolId === subagentId
        );
        if (!hasSubagentBlock) continue;
        const existingIdx = msg.subagents.findIndex((s) => s.id === subagentId);
        if (existingIdx === -1) {
          msg.subagents.push(subagent);
        } else {
          msg.subagents[existingIdx] = subagent;
        }
        if (msg.contentBlocks) {
          for (let i2 = 0; i2 < msg.contentBlocks.length; i2++) {
            const block = msg.contentBlocks[i2];
            if (block.type === "tool_use" && block.toolId === subagentId) {
              msg.contentBlocks[i2] = {
                type: "subagent",
                subagentId,
                mode: subagent.mode
              };
            } else if (block.type === "subagent" && block.subagentId === subagentId && !block.mode) {
              block.mode = subagent.mode;
            }
          }
        }
      }
    }
  }
  dedupeMessages(messages) {
    const seen = /* @__PURE__ */ new Set();
    const result = [];
    for (const message of messages) {
      if (seen.has(message.id)) continue;
      seen.add(message.id);
      result.push(message);
    }
    return result;
  }
  /**
   * Creates a new conversation and sets it as active.
   *
   * New conversations always use SDK-native storage.
   * The session ID may be captured after the first SDK response.
   */
  async createConversation(sessionId) {
    const conversationId = sessionId != null ? sessionId : this.generateConversationId();
    const conversation = {
      id: conversationId,
      title: this.generateDefaultTitle(),
      createdAt: Date.now(),
      updatedAt: Date.now(),
      sessionId: sessionId != null ? sessionId : null,
      sdkSessionId: sessionId != null ? sessionId : void 0,
      messages: [],
      isNative: true
    };
    this.conversations.unshift(conversation);
    await this.storage.sessions.saveMetadata(
      this.storage.sessions.toSessionMetadata(conversation)
    );
    return conversation;
  }
  /**
   * Switches to an existing conversation by ID.
   *
   * For native sessions, loads messages from SDK storage if not already loaded.
   */
  async switchConversation(id) {
    const conversation = this.conversations.find((c3) => c3.id === id);
    if (!conversation) return null;
    await this.loadSdkMessagesForConversation(conversation);
    return conversation;
  }
  /**
   * Deletes a conversation and resets any tabs using it.
   *
   * For native sessions, deletes the metadata file and SDK session file.
   * For legacy sessions, deletes the JSONL file.
   */
  async deleteConversation(id) {
    var _a, _b, _c;
    const index = this.conversations.findIndex((c3) => c3.id === id);
    if (index === -1) return;
    const conversation = this.conversations[index];
    this.conversations.splice(index, 1);
    const vaultPath = getVaultPath(this.app);
    const sdkSessionId = (_a = conversation.sdkSessionId) != null ? _a : conversation.sessionId;
    if (vaultPath && sdkSessionId) {
      await deleteSDKSession(vaultPath, sdkSessionId);
    }
    if (conversation.isNative) {
      await this.storage.sessions.deleteMetadata(id);
    } else {
      await this.storage.sessions.deleteConversation(id);
    }
    for (const view of this.getAllViews()) {
      const tabManager = view.getTabManager();
      if (!tabManager) continue;
      for (const tab of tabManager.getAllTabs()) {
        if (tab.conversationId === id) {
          (_b = tab.controllers.inputController) == null ? void 0 : _b.cancelStreaming();
          await ((_c = tab.controllers.conversationController) == null ? void 0 : _c.createNew({ force: true }));
        }
      }
    }
  }
  /** Renames a conversation. */
  async renameConversation(id, title) {
    const conversation = this.conversations.find((c3) => c3.id === id);
    if (!conversation) return;
    conversation.title = title.trim() || this.generateDefaultTitle();
    conversation.updatedAt = Date.now();
    if (conversation.isNative) {
      await this.storage.sessions.saveMetadata(
        this.storage.sessions.toSessionMetadata(conversation)
      );
    } else {
      await this.storage.sessions.saveConversation(conversation);
    }
  }
  /**
   * Updates conversation properties.
   *
   * For native sessions, saves metadata only (SDK handles messages including images).
   * For legacy sessions, saves full JSONL.
   *
   * Image data is cleared from memory after save (SDK/JSONL has persisted it).
   */
  async updateConversation(id, updates) {
    const conversation = this.conversations.find((c3) => c3.id === id);
    if (!conversation) return;
    Object.assign(conversation, updates, { updatedAt: Date.now() });
    if (conversation.isNative) {
      await this.storage.sessions.saveMetadata(
        this.storage.sessions.toSessionMetadata(conversation)
      );
    } else {
      await this.storage.sessions.saveConversation(conversation);
    }
    for (const msg of conversation.messages) {
      if (msg.images) {
        for (const img of msg.images) {
          img.data = "";
        }
      }
    }
  }
  /**
   * Gets a conversation by ID from the in-memory cache.
   *
   * For native sessions, loads messages from SDK storage if not already loaded.
   */
  async getConversationById(id) {
    const conversation = this.conversations.find((c3) => c3.id === id) || null;
    if (conversation) {
      await this.loadSdkMessagesForConversation(conversation);
    }
    return conversation;
  }
  /**
   * Gets a conversation by ID without loading SDK messages.
   * Use this for UI code that only needs metadata (title, etc.).
   */
  getConversationSync(id) {
    return this.conversations.find((c3) => c3.id === id) || null;
  }
  /** Finds an existing empty conversation (no messages). */
  findEmptyConversation() {
    return this.conversations.find((c3) => c3.messages.length === 0) || null;
  }
  /** Returns conversation metadata list for the history dropdown. */
  getConversationList() {
    return this.conversations.map((c3) => ({
      id: c3.id,
      title: c3.title,
      createdAt: c3.createdAt,
      updatedAt: c3.updatedAt,
      lastResponseAt: c3.lastResponseAt,
      messageCount: c3.messages.length,
      preview: this.getConversationPreview(c3),
      titleGenerationStatus: c3.titleGenerationStatus,
      isNative: c3.isNative
    }));
  }
  /** Returns the active Claudian view from workspace, if open. */
  getView() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_CLAUDIAN);
    if (leaves.length > 0) {
      return leaves[0].view;
    }
    return null;
  }
  /** Returns all open Claudian views in the workspace. */
  getAllViews() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_CLAUDIAN);
    return leaves.map((leaf) => leaf.view);
  }
  /**
   * Checks if a conversation is open in any Claudian view.
   * Returns the view and tab if found, null otherwise.
   */
  findConversationAcrossViews(conversationId) {
    for (const view of this.getAllViews()) {
      const tabManager = view.getTabManager();
      if (!tabManager) continue;
      const tabs = tabManager.getAllTabs();
      for (const tab of tabs) {
        if (tab.conversationId === conversationId) {
          return { view, tabId: tab.id };
        }
      }
    }
    return null;
  }
  /**
   * Gets SDK supported commands from any ready service.
   * The command list is the same for all services, so we just need one ready.
   * Used by inline edit and other contexts that don't have direct TabManager access.
   */
  async getSdkCommands() {
    for (const view of this.getAllViews()) {
      const tabManager = view.getTabManager();
      if (tabManager) {
        const commands = await tabManager.getSdkCommands();
        if (commands.length > 0) {
          return commands;
        }
      }
    }
    return [];
  }
};
